{"meta":{"title":"AIfish","subtitle":"think how to think","description":"NLP AI","author":"aifish","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About Me","date":"2019-03-27T06:54:06.363Z","updated":"2019-03-27T06:54:06.363Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"王晓宇研究方向：自然语言处理 微信二维码： github: https://github.com/ofooo 博客: https://ofooo.github.io 邮箱: ofyu@163.com"},{"title":"Categories","date":"2019-03-18T02:07:20.002Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-03-18T02:07:20.002Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vim","slug":"编程基础/软件使用备忘/使用vim","date":"2019-07-12T01:22:33.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/编程基础/软件使用备忘/使用vim/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/使用vim/","excerpt":"","text":"参考资料 命令模式 u 撤销操作 Ctrl+r 恢复上一步被撤销的操作 yy 复制单行 p 粘贴（到当前行下面） 数字yy 复制当前行到下面N行（适用于少量行复制） 6,9 co 12 把6至9行copy到12行下面 编辑模式修改配置 ~/.vimrc 命令 说明 set nu 显示行号","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"错误处理","slug":"编程思维/错误处理","date":"2019-07-12T01:14:28.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/编程思维/错误处理/","link":"","permalink":"http://yoursite.com/wiki/编程思维/错误处理/","excerpt":"","text":"参考资料 报错和日志的判断异常应该抛出而不是返回。 只判断允许出现的情况的条件分支。不要用try来包裹不允许出现的情况。 不允许出现的情况就在server的最底层报错机制中展示出来。这样能避免小错误无法找到。 异常的分类就是定几个大类，如 参数校验出错的异常CheckException，返回到前台是1，没有登录是UnloginException，返回到前台是2，没有权限是3. 前台拿到了异常，发现是1，就提示返回结果的msg，发现是2，就打开登录对话框，发现是3，然后又怎么样处理。。。 异常不能不分，但不能分太细，否则前台无法玩。","categories":[{"name":"编程思维","slug":"编程思维","permalink":"http://yoursite.com/categories/编程思维/"}],"tags":[{"name":"编程风格","slug":"编程风格","permalink":"http://yoursite.com/tags/编程风格/"}]},{"title":"编程的基础知识","slug":"编程思维/什么才是编程的基础知识？","date":"2019-07-12T01:12:19.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/编程思维/什么才是编程的基础知识？/","link":"","permalink":"http://yoursite.com/wiki/编程思维/什么才是编程的基础知识？/","excerpt":"","text":"参考资料 什么才是java的基础知识？https://xwjie.github.io/note/basic.html 近日里，很多人邀请我回答各种j2ee开发的初级问题，我无一都强调java初学者要先扎实自己的基础知识，那什么才是java的基础知识？又怎么样才算掌握了java的基础知识呢？这个问题还真值得仔细思考。 我做j2ee开发已经超过十载，作为过来人，心路历程估计和大家差不多。编码的前几年，很长一段时间觉得java简单，开发实现各种功能都很轻松，代码写起来根本不费劲（主要是因为写的代码都是一些功能业务逻辑）。但同时自己心里明白，自己其实没有什么水平，自己这3,4年以来学懂的东西就那么多，其他人几个月就可以学会，自己的竞争力在哪里？这种矛盾的心理，困扰了我非常长的时间，非常的苦恼！总有一种报国无门无处发力的感觉。 这个时期，热衷了使用各种框架，各种api，常以今天学习了某个api，组件，框架的使用就觉得自己学到了东西，设计模式也看过不止一次，但都没有啥感觉。一方面很努力学习，一方面又觉得不踏实，因为例如这个api我知道而你不知道，但我告诉你之后你就知道了，那我比你的优势在哪里呢？苦恼*2 过了很长一段这种惶惶不可终日的日子，决定自己要改变，改变的方向就是阅读自己用到的java相关的源代码，看看jdk是如何实现的。就从基本的数据结构看，然后看多线程相关，在学习前台等等。写的代码还是那些代码，代码还是那么简单，但我力求做到知道代码背后的真相，这就是我最开始努力的方向。于是不再把时间都花在追求各种新框架、新API的使用上，每天都花时间在看实现原理上。就这样过了大半年左右，终于不再迷茫，不会在觉得自己只懂api的使用，觉得自己没有那么肤浅了，说脱胎换骨也不为过。那段时间，是我成长最快的时期，也是最充实的一段时光。 Talk is cheap，show me the code。举例说明大家会比较有感觉。 如学习了hashmap的源代码知道了工作原理之后，使用hashmap 1Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); 代码还是那个代码，但我已经知道了hashmap背后的东西 数据结构是链表的数组（注：后面的版本为了提升性能，已经是改成链表或者树（节点较多）了） 思想上是空间换时间的算法 构造函数上有容量和负载因子2个参数以及作用 决定性能的是key的hashcode是否够快、结果够分散（不分散就会变成链表的性能了），和扩容的开销（什么时候扩容，和负载因子有关） 然后写代码的时候，如果知道了最终的容量（尤其是数据量大的时候），我都会指定初始化容量，类似如下 12List&lt;SomeBean&gt; list = doSomeThing(); Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;((int)(list.size()/0.75));//0.75为默认负载因子 如果工作中某个map使用特别多，性能还需要继续优化，我就会考虑从以下方面优化 如果key是自己定义的对象，那么hashcode方法是否够快（最少应该缓存保证只计算一次，而且放入之后不能改变，决定hashcode的字段不能改变）？ hash的结果是否够分散？ 可以考虑调小负载因子，花更多的空间来换时间 学习源代码的时候，特别有意思，你会强烈感觉到一个词：举一反三！触类旁通！ 学习api使用的时候，如果你只知道使用不知道原理，很难举一反三，感觉的是死记硬背。但学习了原理之后，知识成体系后，很容易举一反三，学的越多就容易，还是以hashmap为例，我举一个hashmap反三个点。 你会知道但凡有数组的数据结构，构造函数都有一个容量的初始化参数（或者说构造函数有初始化容量的可能都是数组的数据结构）。构造函数如下 123public ArrayList(int initialCapacity) //LinkedList不是数组就没有public HashMap(int initialCapacity) public StringBuffer(int capacity) 你就会知道，数组扩容很耗性能（数据量大容易oom），尽量指定容量。 算法是空间换时间，还有没有其他算法是这种思想的？你最少能找到一个桶排序。 数据库的分库分表，思路和hashmap大同小异 各种分布式的hash一致性算法，第一步都是创建一个最大的数组（Integer.MAX_VALUE）,就是避免了hashmap最耗性能的扩容运算。 学习了hashmap之后，你很自然就会去了解其他的map，如TreeMap，LinkedHashmap（超级有用），HashTable，ConcurrentSkipListMap（算法思路很有意思），ConcurrentHashMap等，你会知道set就是用map做的，都不需要学。到了这步，map相关就可以暂告一段落。 在学习中，我发现思想上的东西是最重要的，你理解了思想，一下子就豁然开朗了，在也不需要死记硬背了。如学习CAS的时候，大家都知道这是一种指令级的免锁实现。看代码的时候，我一度疑惑为什么会有个while死循环（原谅我天资驽钝） 12345678public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev;&#125; 后来从思想上理解，才知道乐观锁的概念，就是很乐观，假设你不会出错，但你要是出错了我就重试有办法给你修复，对应的就是悲观锁，就是很悲观，觉得不锁就会出错，如synchronize关键字和reentrantlock。这体现了2种不同截然不同的管理思想。这种思想经常体现在多个系统集成的设计，有些时候如果你用悲观的思想设计，实现起来很麻烦或者无法实现，但如果你用乐观的思想，减少出错条件，然后出错了能解决，代价就会小很多。 说了这么多，我想说的就是，j2ee的基础知识就是你做项目中代码背后的东西。提高自己水平的方法很简单，就是把大部分时间去了解实现原理，了解思想，让自己的知识串起来，形成体系。j2ee的知识特别多，学得人想哭，千万不要一开始把时间花在各种框架、组件的使用上，在我看来那是本末倒置。简单来说：先修内功再练招式。 我觉得重要的、工作会用得到的知识就是一个请求从前台到后台处理的过程需要用到的东西，最少包括以下点：js，html，css，ajax，ajax跨域，跨站脚本，web缓存，web优化，nginx，apache作用，鉴权方式，cookie，session，servlet，filter，基本数据结构，线程池，线程并发，缓存，io等等，知识点非常多。如你前台用jq，你应该了解他的选择器和ajax是如何实现的（其实去了解就会发现不复杂）？而不是只是会用。后台你用springmvc，你要了解他是如何工作，每一个配置是做什么，为什么？ j2ee知识点特别多，每一个都能写很多，我也在不断学习中。具体要写我还真不知道如何下手，我就列举一下我觉得基础的东西（面试的时候问的问题），有简单有难，你觉得偏可能是你没有做过这块的开发或者做得比较浅： map有哪些，特点和使用场景？（只知道hashmap，hashtable是不够的。。。） 哪些方面会影响hashmap的性能？ 线程安全的map有哪些，concurrenthashmap是如何实现线程安全的（jdk1.8大不同）？ 锁有哪几种？ 公平锁，读写锁等如何实现？ synchronize能加在哪些地方？什么区别？ 死锁的形成条件？现在很少死锁了，很少问 原子数据对象的原理？ reentrantlock相关知识，condition如何使用？（很重要的知识点，强烈推荐阅读ArrayBlockingQueue源码，教科书般） volatile的相关知识（内存屏障，重排） ThreadLocal原理和使用？（超级有用的知识点，工作中使用很多，让代码漂亮很多，后面专门开贴写） 多个线程同步等待？（CountDownLatch，CyclicBarrier，Semaphore信号量很多语言都有，实际上使用不是很多，线程池就可以实现大部分等待功能） 线程池？（种类，重要的方法，这个一般是使用层面，简单） 动态代理？反射？内省？（考察知识面） session相关知识？和cookie关系？分布式session实现原理？ cookie相关知识？有哪些属性？（有些属性很有用，只是我们很少留意而已！） nginx，apache 实际项目能做哪些？（鉴权，转发，缓存，反向代理等）和tomcat什么关系？最少了解 ajax跨域原因？解决方式？（重点知识，做SE避免不了的问题。这里很多知识点。） jsonp原理？后台需要改动吗？（jsonp虽然现在落伍了，但还是会问问） web优化知识点？（常规知识点） 前台缓存相关？（200cache,304，ajax缓存，如何实现缓存） 一列举就根本停不下来了。。。其他的spring框架的东西也很多，还有jvm的东西，系统集成相关，数据库相关，io做得很少也不懂问，后面再慢慢把我的学习过程和偶得写下来。很多东西我也是了解个大概，就是看看你有没有学习过，不断学习是程序员最重要的特征。 我不算高手，只能算一个合格的老程序员。这里只是说了一下自己之前学习的方向和列举了几个学习中的例子，大家见仁见智。帖子也是针对迷茫的初学者有感而发，希望能帮助到大家。 最后我总结一下：初学者先广在精，关注代码背后的实现，关注内功修炼，了解实现原理和思想，形成自己完整的技术体系，知识成片之后就容易触类旁通，进步的速度就会越来越快。最后以我在每一个项目组和开发人员聊天都会说的几个例子结尾：“少林功夫里面有功和拳之分，马步功，石锁功是功，蛇拳猴拳是拳，你不可能练会了蛇拳猴拳就能打人，你必须先重点练功。乔峰在聚贤庄用太祖长拳把大家打得落花流水，我们用太祖长拳就只是个广播体操。同样，我们要分清编程里面那些是功那些是拳，代码背后的实现和思想是功，各个框架、api使用是拳。初学者应该大部分时间花在练功上，功到了拳自然就有了，切勿本末倒置。”谢谢大家阅读！","categories":[{"name":"编程思维","slug":"编程思维","permalink":"http://yoursite.com/categories/编程思维/"}],"tags":[{"name":"编程风格","slug":"编程风格","permalink":"http://yoursite.com/tags/编程风格/"}]},{"title":"pytorch报错","slug":"人工智能/深度学习/pytorch/pytorch报错","date":"2019-07-12T01:09:53.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/人工智能/深度学习/pytorch/pytorch报错/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/pytorch/pytorch报错/","excerpt":"","text":"参考资料 eq() received an invalid combination of arguments - got (type), but expected one of:(float other) net-Module内部的 self.type 不能被覆盖。 不能self.type=net() 这样～～～ RuntimeError: multi-target not supported at /pytorch/torch/lib/THNN/generic/ClassNLLCriterion.c:22 CrossEntropyLoss(y, truey)应该： y二维(n, 分类数) truey一维(n) RuntimeError: invalid argument 1: input is not contiguous at /pytorch/torch/lib/TH/generic/THTensor.c:231 对象不是连续的（在显存或内存里） input.contiguous() 即可 RuntimeError: save_for_backward can only save input or output tensors, but argument 0 doesn’t satisfy this condition 函数需要需要反向传播时，输入必须是Variable，不能是tensor ValueError: Expected more than 1 value per channel when training 在训练时，期望多余1个值（例如nn.BatchNorm1d必须输入batch&gt;1的数据） 可以用model.eval() 来进入预测模式，避免此问题","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"pytorch","slug":"人工智能/深度学习/pytorch","permalink":"http://yoursite.com/categories/人工智能/深度学习/pytorch/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"},{"name":"GPU","slug":"GPU","permalink":"http://yoursite.com/tags/GPU/"},{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"}]},{"title":"pytorch--tensor","slug":"人工智能/深度学习/pytorch/pytorch-tensor","date":"2019-07-12T01:09:44.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/人工智能/深度学习/pytorch/pytorch-tensor/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/pytorch/pytorch-tensor/","excerpt":"","text":"参考资料 Tensor 作用 tensor的方法() 查看具体的数据类型 tensor.type() 转成list tensor.tolist() 取值（只有一个元素） tensor.item() 使tensor可以求导 tensor. requires_grad() 作用 tensor的属性 是否求导 tensor.requires_grad 创建tensor 创建0维张量（标量scalar） torch.tensor(3.1416) （注意小写）","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"pytorch","slug":"人工智能/深度学习/pytorch","permalink":"http://yoursite.com/categories/人工智能/深度学习/pytorch/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"},{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"}]},{"title":"文本操作","slug":"python/文本操作","date":"2019-07-12T01:07:47.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/文本操作/","link":"","permalink":"http://yoursite.com/wiki/python/文本操作/","excerpt":"","text":"参考资料 format 代码 说明 print(‘{:0&gt;2}’.format(3)) 2位数，空的用0补充，&gt;在左边补","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python基本概念","slug":"python/迭代器和生成器","date":"2019-07-12T01:07:00.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/迭代器和生成器/","link":"","permalink":"http://yoursite.com/wiki/python/迭代器和生成器/","excerpt":"","text":"参考资料 迭代器 Iterator12345i = iter(nums) next(i) 迭代器没有长度，它们不能被索引。惰性，只能使用一次，只能循环遍历一次。可以无限长，因为不调用next时什么也不做，不占多余的内存 生成器 Generator1234生成器是迭代器的子类。g = (n**2 for n in nums)生成器所使用的场景是迭代前不生成这些数据，迭代后不再需要这些数据。如果需要多次使用的数据，不应使用生成器。 可迭代对象 Iterable1可以用for遍历的对象 Python 中的每一种迭代都依赖于迭代器协议，因此理解迭代器协议是理解 Python 中的循环的关键。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-xml解析","slug":"python/python-xml","date":"2019-07-12T00:58:58.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/python-xml/","link":"","permalink":"http://yoursite.com/wiki/python/python-xml/","excerpt":"","text":"参考资料 asd xml–可扩展标记语言12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;catalog&gt; &lt;maxid&gt;4&lt;/maxid&gt; &lt;login username=\"pytest\" passwd='123456'&gt; &lt;caption&gt;Python&lt;/caption&gt; &lt;item id=\"4\"&gt; &lt;caption&gt;test&lt;/caption&gt; &lt;/item&gt; &lt;/login&gt; &lt;item id=\"2\"&gt; &lt;caption&gt;Zope&lt;/caption&gt; &lt;/item&gt;&lt;/catalog&gt; xml是由标签对组成，1- 标签可以有属性： ``` &lt;aa id=&apos;123&apos;&gt;&lt;/aa&gt; 标签对可以嵌入数据：1234567891011121314151617181920 - 标签可以嵌入子标签（具有层级关系）### 获取标签和属性```python#coding: utf-8import xml.dom.minidomdom = xml.dom.minidom.parse(&quot;xxx.xml&quot;) #打开xml文档root = dom.documentElement #得到xml文档对象print(&quot;nodeName:&quot;, root.nodeName) #每一个结点都有它的nodeName，nodeValue，nodeType属性print(&quot;nodeValue:&quot;, root.nodeValue) #nodeValue是结点的值，只对文本结点有效print(&quot;nodeType:&quot;, root.nodeType)print(&quot;ELEMENT_NODE:&quot;, root.ELEMENT_NODE)# 输出 nodeName: catalog# 输出 nodeValue: None# 输出 nodeType: 1# 输出 ELEMENT_NODE: 1 nodeType是结点的类型。catalog是ELEMENT_NODE类型 节点编号： 节点类型的名称： 说明 返回的节点名称 返回的节点值 1 Element 表示一个元素 元素名称 null 2 Attribute 代表一个属性 属性名称 属性值 3 Text 代表元素或属性的文本内容 #text 节点的内容 4 CDATA Section 代表文档中的 CDATA 区段（文本不会被解析器解析） #cdata-section 节点的内容 5 Entity Reference 代表一个实体引用 实体引用名称 null 6 Entity 代表一个实体 实体名称 null 7 Processing Instrucion 代表一个处理指令 目标 节点的内容 8 Comment 代表一个注释 #comment 注释文本 9 Document 代表整个文档（DOM 树的根节点） #document null 10 Document Type 为文档中定义的实体提供了一个接口 文档类型名称 null 11 Document Fragment 代表”轻量级”的 Document 对象，它可以保留文档中的一部分 #document fragment null 12 Notation 定义一个在 DTD 中声明的符号 符号名称 null w3school 菜鸟教程–更详细 获取子标签123456bb = root.getElementsByTagName('maxid')print(type(bb)) # === &lt;class 'xml.dom.minicompat.NodeList'&gt;print(bb) # === [&lt;DOM Element: maxid at 0x2707a48&gt;]b = bb[0]print(b.nodeName) # === maxidprint(b.nodeValue) # === None 12345678910111213141516171819202122232425262728minidom.parse(filename)加载读取XML文件 doc.documentElement获取XML文档对象 node.getAttribute(AttributeName)获取XML节点属性值 node.getElementsByTagName(TagName)获取XML节点对象集合 node.childNodes #返回子节点列表。 node.childNodes[index].nodeValue获取XML节点值 node.firstChild#访问第一个节点。等价于pagexml.childNodes[0] doc = minidom.parse(filename)doc.toxml('UTF-8')返回Node节点的xml表示的文本 Node.attributes[\"id\"]a.name #就是上面的 \"id\"a.value #属性的值访问元素属性","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"}]},{"title":"C++基础","slug":"编程基础/C++/base-cpp","date":"2019-07-12T00:57:45.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/编程基础/C++/base-cpp/","link":"","permalink":"http://yoursite.com/wiki/编程基础/C++/base-cpp/","excerpt":"","text":"参考资料 安装g++编译器12sudo apt-get install build-essentialgcc --version 编译源文件1234567891011121314151617//《hello.cpp》源文件内容：#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; \"Hello, world!!!!\" &lt;&lt; endl; return 0;&#125;// 编译hello.cpp （-c 表示只编译，不链接）g++ -c hello.cpp// 链接hello.o生成hello.out (-o 表示输出文件)g++ -o hello.out hello.cpp// 运行hello.out./hello.out 构建项目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// .h和.cpp文件相互配合 需要用 Make工具来构建项目# hw2.cpp#include \"solution.h\"int main () &#123; Solution sln; sln.Say(); return 0;&#125;# solution.h/* solution.h */class Solution &#123;public: void Say();&#125;;# solution.cpp/* solution.cpp */#include &lt;iostream&gt;#include \"solution.h\"void Solution::Say()&#123; std::cout &lt;&lt; \"HI!!!!!!\" &lt;&lt; std::endl;&#125;// 创建一个makefile文件，以告诉Make如何编译和链接程序# 生成可执行文件build，prerequisites有两个.o文件，是因为代码里hw2引用了solution.h。build : hw2.o solution.o g++ -o build hw2.o solution.o #注意前面必须是tab，不能是空格# 编译hw2.cpp，生成hw2.o文件，-g 表示生成的文件可用gdb调试，如果没有-g，调试时无法命中断点hw2.o : hw2.cpp solution.h g++ -g -c hw2.cpp# 编译solution.cpp文件，生成solution.o文件。solution.o : solution.h solution.cpp g++ -g -c solution.cpp# 清除标签: make不找冒号后的依赖关系，也不自动执行命令。如果要执行该命令，必须在make后指出动作名字，如make cleanclean : rm hw2.o solution.o build # makefile的格式:target ... : prerequisites ...(空格区分多个文件) command #注意前面是tab // target这一个或多个目标，依赖于prerequisites列表中的文件，其执行规则定义在command里。// 如果prerequisites列表中文件比target要新，就会执行command，否则就跳过。// make命令的流程1 make在当前目录下找名为makefile或Makefile的文件；2 如果找到，它会找文件中的第一个target，如上述文件中的build，并作为终极目标文件;3 如果第一个target的文件不存在，或其依赖的.o 文件修改时间要比target这个文件新，则会执行紧接着的command来生成这个target文件;4 如果第一个target所依赖的.o文件不存在，则会在makefile文件中找target为.o的依赖，如果找到则执行command，.o的依赖必是.h或.cpp，于是make可以生成 .o 文件了5 回溯到第2步执行最终目标./build # 执行文件// makefile:2: *** missing separator。 停止。 可能是Tab被替换成了空格~ VSCode 配置 makefile用tab(不替换成空格)“[makefile]”: { &quot;editor.quickSuggestions&quot;: false, &quot;editor.formatOnSave&quot;: true, &quot;editor.renderWhitespace&quot;: &quot;all&quot;, &quot;editor.acceptSuggestionOnEnter&quot;: &quot;off&quot;, &quot;editor.detectIndentation&quot;: false, }","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"C++","slug":"编程基础/C","permalink":"http://yoursite.com/categories/编程基础/C/"}],"tags":[]},{"title":"javascript基础","slug":"编程基础/javascript/javascript","date":"2019-07-12T00:55:19.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/编程基础/javascript/javascript/","link":"","permalink":"http://yoursite.com/wiki/编程基础/javascript/javascript/","excerpt":"","text":"参考资料 网页中的JavaScript位置 onclick1234567891011121314152. ```&lt;a href=&quot;javascript:脚本的文本内容&quot;&gt;&lt;/a&gt; ``` 超链接href属性3. ```&lt;head&gt;&lt;script&gt;脚本内容&lt;/script&gt;&lt;/head&gt; ``` 内部脚本4. ```&lt;head&gt;&lt;script src=&quot;脚本位置&quot;&gt;&lt;/script&gt;&lt;/head&gt; ``` 引用脚本文件（若有src，内部脚本无效）### 网页中的JavaScript命令```JavaScript# 基本语法规则# 每个语句以分号结尾# 空格和换行都会被无视# 显示命令alert(&quot;提醒框文本&quot;)console.log(&quot;控制台输出文本&quot;)document.write(&quot;网页body中要写入的内容&quot;) 代码/代码块/函数12345678910111213141516171819202122232425262728293031# 语句用分号分隔(分号可选)。JavaScript语句是发给浏览器的命令。语句的作用是告诉浏览器该做什么。# JavaScript代码是 JavaScript语句的序列。 浏览器按照编写顺序依次执行每条语句# 代码块把代码分批地组合起来。 代码块以左花括号开始，以右花括号结束。# 函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。// 注释用2个撇// JavaScript的关键字必须以 字母 下划线_ 美元符$ 开始。// 函数字面量 或 定义一个函数function myFunction(a, b) &#123; return a * b;&#125; // 定义一个函数const Test = function () &#123; &#125;// ES6 新增箭头函数! 使用箭头函数定义函数时可以省略 function 关键字const Test = (...params) =&gt; &#123; &#125;// ES6 新增箭头函数! 该函数只有一个参数时可以简写成：const Test = param =&gt; &#123; return param; &#125;x = 123 + 'wxy' # x = '123wxy' JavaScript会自动把数字转化成字符串// 文本字符串中使用反斜杠对代码行进行换行document.write(\"你好 \\世界!\");// 字典在JavaScript里就是一个对象// 访问一个对象的属性 obj.param obj['param'] x = obj.param 变量1234567891011121314151617181920// var 声明一个变量，如果再次声明这个变量值不变# 未赋值的变量实际 = undefined var lastname=\"Doe\", age=30, job=\"carpenter\"; // 赋值未null来清空变量：cars=null;// let 声明一个块级作用域的变量、语句或者表达式。在Function中局部变量推荐使用let变量，避免冲突// 作用域规则 let 声明的变量只在其声明的块或子块中可用作用域1 var var1 在其子作用域 var var1=2 则在作用域1的var1也=2作用域1 let var2 在其子作用域 let var2=2 则在作用域1的var2=undefined# 全局 JavaScript 变量// 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。# JavaScript 变量的生存期// JavaScript 变量的生命期从它们被声明的时间开始。// 局部变量会在函数运行以后被删除。// 全局变量会在页面关闭后被删除。# 如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。 对象12345678910111213141516171819202122232425// JavaScript 对象是属性和方法的容器。// 对象的属性之间一定要用逗号隔开(同名属性只保留最后赋的值,方法也是属性)// 对象的方法定义了一个函数，并作为对象的属性存储。对象方法通过添加 () 调用 (作为一个函数)。// 创建一个对象,并且有一个方法:fullnamevar person = &#123; firstName: \"John\", lastName : \"Doe\", id : 5566, fullName : function() &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;;# 对象构造器function person(firstname,lastname,age,eyecolor)&#123; this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor;&#125;var myFather=new person(\"John\",\"Doe\",50,\"blue\");//JavaScript中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象（运行时） 对象123456789101112131415HTML 事件是发生在 HTML 元素上的事情。HTML 事件可以是浏览器行为，也可以是用户行为。 HTML 页面完成加载 HTML input 字段改变时 HTML 按钮被点击//HTML 元素中可以添加事件属性，使用 JavaScript 代码来添加 HTML 元素。单引号/双引号:&lt;some-HTML-element some-event='JavaScript 代码'&gt;&lt;some-HTML-element some-event=\"JavaScript 代码\"&gt; 事件可以用于处理表单验证，用户输入，用户行为及浏览器动作: 页面加载时触发事件 页面关闭时触发事件 用户点击按钮执行动作 验证用户输入内容的合法性 等等 ... 常见事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 更多事件列表: JavaScript 参考手册 - HTML DOM 事件。 浏览器对象模型（Browser Object Model (BOM)）和 HTML DOM Document 对象123456789101112131415161718192021222324252627282930313233343536373839404142#window 对象。它表示浏览器窗口。所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。// HTML DOM 的 document 也是 window 对象的属性之一, 下面两条语句相同:window.document.getElementById(\"header\"); document.getElementById(\"header\"); // 所有浏览器的窗口宽度和高度（不包括工具栏/滚动条）(兼容)var w=window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var h=window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight;# 注意 window的属性作为保留字,不能定义成变量//screen 对象包含有关用户屏幕的信息。 screen.availWidth //可用的屏幕宽度 screen.availHeight //可用的屏幕高度//location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。 location.hostname //返回 web 主机的域名 location.pathname //返回当前页面的路径和文件名 location.port //返回 web 主机的端口 （80 或 443） location.protocol //返回所使用的 web 协议（http:// 或 https://）//history 对象包含浏览器的历史。Window History history.back() //与在浏览器点击后退按钮相同 history.forward() //与在浏览器中点击向前按钮相同//navigator 对象包含有关访问者浏览器的信息。alert(\"sometext\"); //警告框r=confirm(\"sometext\"); //确认框p=prompt(\"请输入你的名字\",\"Harry Potter\"); //（提示框） 输入框#document 对象当浏览器载入 HTML 文档, 它就会成为 document 对象。document 对象是HTML文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）。document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的网页&lt;/h1&gt; &lt;p id=\"demo\"&gt;我的第一个段落。&lt;/p&gt; &lt;p id=\"demo2\"&gt;我的第2个段落。&lt;/p&gt;&lt;script&gt; # 向 id=\"demo\" 的 HTML 元素输出文本 \"你好 Dolly\" ： document.getElementById(\"demo\").innerHTML = \"你好 Dolly\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 调试123F12 打开浏览器调试器, 控制台查看日志.console.log('some thing') JavaScript 语句标识符 (关键字) ： 语句 描述 break 用于跳出循环。 catch 语句块，在 try 语句块执行出错时执行 catch 语句块。 continue 跳过循环中的一个迭代。 do … while 执行一个语句块，在条件语句为 true 时继续执行该语句块。 for 在条件语句为 true 时，可以将代码块执行指定的次数。 for … in 用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。 function 定义一个函数 if … else 用于基于不同的条件来执行不同的动作。 return 退出函数 switch 用于基于不同的条件来执行不同的动作。 throw 抛出（生成）错误 。 try 实现错误处理，与 catch 一同使用。 var 声明一个变量。 while 当条件语句为 true 时，执行语句块。","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"javascript","slug":"编程基础/javascript","permalink":"http://yoursite.com/categories/编程基础/javascript/"}],"tags":[{"name":"javascript语法","slug":"javascript语法","permalink":"http://yoursite.com/tags/javascript语法/"}]},{"title":"node","slug":"编程基础/javascript/node","date":"2019-07-12T00:55:09.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/编程基础/javascript/node/","link":"","permalink":"http://yoursite.com/wiki/编程基础/javascript/node/","excerpt":"","text":"参考资料 npm最常用命令12# 安装模块, 并将模块名加入到package.jsonnpm install xxxxxx --save npm常用命令123456# 查看已安装模块的版本(-g查看全局,否则查看本地)npm ls jquery -gnpm view jquery version #查看jquery的最新的版本npm view jquery versions #查看npm服务器上所有的jquery版本信息npm info jquery #查看npm服务器上所有的jquery版本信息","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"javascript","slug":"编程基础/javascript","permalink":"http://yoursite.com/categories/编程基础/javascript/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"ubuntu的KDE开启触摸板","slug":"编程基础/软件使用备忘/ubuntu的KDE开启触摸板","date":"2019-07-11T14:37:20.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/编程基础/软件使用备忘/ubuntu的KDE开启触摸板/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/ubuntu的KDE开启触摸板/","excerpt":"","text":"安装KDE后触摸板失效了, 今天终于解决了问题 xinput123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 查看设备xinput# TouchPad是触摸板, Mouse是鼠标, Touchscreen是触摸屏, 根据名字找到触摸板的设备ID(我这里是17)# 禁用xinput --disable 17# 启用xinput --enable 17# 查看设备的属性xinput --list-props 17# 结果如下: Device 'SynPS/2 Synaptics TouchPad': Device Enabled (143): 1 Coordinate Transformation Matrix (145): 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000 libinput Tapping Enabled (302): 0 libinput Tapping Enabled Default (303): 0 libinput Tapping Drag Enabled (304): 1 libinput Tapping Drag Enabled Default (305): 1 libinput Tapping Drag Lock Enabled (306): 0 libinput Tapping Drag Lock Enabled Default (307): 0 libinput Tapping Button Mapping Enabled (308): 1, 0 libinput Tapping Button Mapping Default (309): 1, 0 libinput Natural Scrolling Enabled (280): 0 libinput Natural Scrolling Enabled Default (281): 0 libinput Disable While Typing Enabled (310): 1 libinput Disable While Typing Enabled Default (311): 1 libinput Scroll Methods Available (282): 1, 1, 0 libinput Scroll Method Enabled (283): 1, 0, 0 libinput Scroll Method Enabled Default (284): 1, 0, 0 libinput Click Methods Available (312): 1, 1 libinput Click Method Enabled (313): 1, 0 libinput Click Method Enabled Default (314): 1, 0 libinput Middle Emulation Enabled (287): 0 libinput Middle Emulation Enabled Default (288): 0 libinput Accel Speed (289): 0.000000 libinput Accel Speed Default (290): 0.000000 libinput Left Handed Enabled (294): 0 libinput Left Handed Enabled Default (295): 0 libinput Send Events Modes Available (265): 1, 1 libinput Send Events Mode Enabled (266): 0, 0 libinput Send Events Mode Enabled Default (267): 0, 0 Device Node (268): \"/dev/input/event4\" Device Product ID (269): 2, 7 libinput Drag Lock Buttons (296): &lt;no items&gt; libinput Horizontal Scroll Enabled (297): 1其中 libinput Tapping Enabled (302) 这个属性是触摸板点击生效属性# 设置设备17的属性302的值为1xinput --set-prop 17 302 1 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"NAS","slug":"其他/NAS","date":"2019-07-05T00:40:32.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/其他/NAS/","link":"","permalink":"http://yoursite.com/wiki/其他/NAS/","excerpt":"","text":"软件系统对比 系统 类别 开源 优缺点 群晖 平台NAS 否 硬盘格式独特, 无法直接给其他系统使用 FreeNAS 平台NAS 开源 操作系统是FreeBSD Kodi 播放器 开源 plex 播放器 收费 OpenMediaVault 平台NAS nPlayer 播放器 30元 infuse 播放器 oplayer 播放器 参考资料","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[]},{"title":"elastic-debug","slug":"人工智能/搜索引擎/elastic-debug","date":"2019-06-27T03:20:54.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/人工智能/搜索引擎/elastic-debug/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/elastic-debug/","excerpt":"","text":"搜索结果的 _score都是None因为使用了自定义的排序, 例如使用时间戳排序, 这时elastic会省略_socre. 如果你希望排序并查看分数, 可以使用 track_scores 参数. 参考 stackoverflow 无法写入数据: cluster_block_exception [FORBIDDEN/12/index read-only / allow delete (api)];因为ES默认监控硬盘使用空间超过95%时会自动设置为自读状态. 解决方案: 清理磁盘空间 配置阈值 123456789PUT _cluster/settings&#123; \"transient\": &#123; \"cluster.routing.allocation.disk.watermark.low\": \"100gb\", \"cluster.routing.allocation.disk.watermark.high\": \"50gb\", \"cluster.routing.allocation.disk.watermark.flood_stage\": \"10gb\", \"cluster.info.update.interval\": \"1m\" &#125;&#125; 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[]},{"title":"配置chrome","slug":"编程基础/安装与配置/配置chrome","date":"2019-06-27T01:51:37.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/编程基础/安装与配置/配置chrome/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/配置chrome/","excerpt":"","text":"插件Ctrl-Z Reopen Closed Tab使用 快捷键 Ctrl+Z 恢复上次关闭的标签页 Reopen closed tab Button点击插件图标 恢复上次关闭的标签页 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"nvidia_docker","slug":"人工智能/深度学习/nvidia-docker","date":"2019-06-14T01:54:32.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/人工智能/深度学习/nvidia-docker/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/nvidia-docker/","excerpt":"","text":"GPU相关命令查看当前GPU使用情况 nvidia-smi 设置使用哪个GPU CUDA_VISIBLE_DEVICES=”1” 查看CUDA版本 nvcc –version 12# 查看显卡版本lspci | grep -i nvidia nvidia-docker简介Docker容器与平台无关, 但也与硬件无关.这有一个问题, 当使用专门的硬件,如NVIDIA显卡时, 需要内核模块和用户级别的库来操作. 因此docker本身并不支持容器内的NVIDIA显卡. NVIDIA提供了 nvidia-docker: 驱动无关的CUDA镜像 一个docker命令行包装, 在启动时将驱动程序的用户模式组件和GPU设备装入容器 安装nvidia-docker12 使用镜像镜像仓库https://hub.docker.com/r/nvidia/cuda 12345678910CUDA镜像的三种风格:base: 基础镜像runtime: 扩展于base, 增加了CUDA toolkit 共享库devel: 扩展于runtime, 增加了debugging工具/编译器工具链/头文件和静态库# 选择版本后, 拉取nvidia/cuda镜像nvidia-docker pull nvidia/cuda:10.0-cudnn7-devel-ubuntu18.04# 查看拉取镜像的版本nvidia-docker run --rm -ti 镜像名称 nvcc --version 安装pytorch获取安装文件https://pytorch.org/get-started/locally/ 1根据上面的版本, 选择1.1, linux, python3.7 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"},{"name":"GPU","slug":"GPU","permalink":"http://yoursite.com/tags/GPU/"},{"name":"显卡","slug":"显卡","permalink":"http://yoursite.com/tags/显卡/"}]},{"title":"tornado","slug":"python/tornado","date":"2019-06-12T01:46:09.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/tornado/","link":"","permalink":"http://yoursite.com/wiki/python/tornado/","excerpt":"","text":"监控文件改动, 自动重载服务12345# 设置 debug=True 或 autoreload=True 会监控所有.py文件, 在改动后自动重载tornado服务app = tornado.web.Application(handlers, debug=True)# 添加监控文件列表tornado.autoreload.watch(filename: str) 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"pytorch常用代码","slug":"人工智能/深度学习/pytorch/pytorch常用代码","date":"2019-06-05T01:35:55.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/人工智能/深度学习/pytorch/pytorch常用代码/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/pytorch/pytorch常用代码/","excerpt":"","text":"pytorch版本: 1.1.0 张量创建一个张量12345678910111213141516171819202122232425262728293031# 通用注释: x表示其他张量 # size0,size1表示张量维度, 数量不固定# data 表示张量的数组值(python数组类型)zeros = torch.zeros( size0, size1, dtype=x.dtype, device=x.device, requires_grad=True)zeros = torch.zeros(data, dtype=torch.long) # 指定具体地数据类型# 随机化生成x = torch.rand(size0, size1) # 默认 torch.float32x = torch.rand(size0, size1, dtype=torch.float)x = torch.rand(size=[size0, size1], dtype=torch.float)t=torch.rand(t.size()) //均匀分布t=torch.randn(t.size()) //标准正态分布t=torch.normal(mean,std) //size同t.Tensor()，每个数以对应的均值mean和标准差std[i,j,...]正态采样。x = torch.randint(low=1, high=100, size=[12, 2], dtype=torch.long)x = torch.LongTensor(size0, size1) # 在pycharm中有错误提示#均分区间生成Tensor、t=T.arange(m,n,step_length) //[m,n)中m开始以步长step_length生成t=T.range(m,n,step_length) //[m,n-1]中m开始以步长step_length生成t=T.linspace(m,n,step_num) //[m,n]中以m为首项，n为末项，均分区间为step_num段# 可以与list或numpy中的array互相转化：t=T.Tensor(list)t=T.Tensor(np.array)t=T.from_numpy(np.array)list=T.tolist(t)array=t.numpy() 观察一个张量1234567t.size() //返回size类型t.numel() //返回总元素个数t.view(d1,d2,d3....)//维度重整t.unsqueeze(di) //在di个维度处升维、t.squeeze(di) //若di维是1，压缩，否则不变。若无参数，压缩所有“1”维torch.cat((t,t,...),dim=1) //按第di的维度按照tuple的格式复制ttorch.chunk(t,i,dim) //在di维上将t分成i份，最后一份的维度不定（若不能整除） 采数据 123torch.index_select(t, di, indices) //在第di维上将t的indices抽取出来组成新Tensor。torch.masked_select(t, mask) //按照0-1Tensor mask的格式筛选t，返回一维Tensortorch.nonzero(t) //输出n×2维Tensor，非零元素的index 计算 功能 代码 P范数（N方求和后开方） torch.norm(input, p=2) 指定GPU（3种方式） 123torch.cuda.set_device(id)os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;2&quot;CUDA_VISIBLE_DEVICES=1 python main.py 网络层 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"pytorch","slug":"人工智能/深度学习/pytorch","permalink":"http://yoursite.com/categories/人工智能/深度学习/pytorch/"}],"tags":[]},{"title":"RNN","slug":"人工智能/深度学习/RNN","date":"2019-05-31T08:26:31.000Z","updated":"2019-06-05T10:07:46.198Z","comments":true,"path":"wiki/人工智能/深度学习/RNN/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/RNN/","excerpt":"","text":"参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"}],"tags":[]},{"title":"debug思路备忘","slug":"编程思维/debug思路备忘","date":"2019-05-31T01:39:46.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/编程思维/debug思路备忘/","link":"","permalink":"http://yoursite.com/wiki/编程思维/debug思路备忘/","excerpt":"","text":"debug整体思路(如何升级)出现bug后, 一定要查询到bug原因 半懂不懂的解决bug是非常错误的行为. 即便误打误撞解决了bug, 下次这个bug大概率还会重现, 因为没有针对根本原因进行解决. 代码相同, 结果不同的可能性硬盘空间是否不足例如elastic search当硬盘空间占用大于95%时不能写入数据 网络情况不同例如某些前端框架使用了某些网络资源, 当不联网时网页显示会出错 代码调用的网络接口不同例如调用API的ip和uri等配置 调试方法: 实时查看被调用APi的日志, 手工触发调用, 查看调用过程的区别 调用数据库的数据不同例如调用了不同的数据库, 或者相同数据库里的数据不一样 读取文件不同例如配置文件, 数据文件, 字典等内容 环境变量不同例如oracle需要读取一些环境变量才能成功启动 电脑性能不同电脑运行速度导致一些依赖程序启动的慢, 或者文件复制没有结束, 都可能导致代码运行结果不一致 调试方法: 在一些差异点代码之前sleep几秒, 然后再执行 第三方库的版本不同例如tornado, pytorch版本等 语言版本不同例如Python, node版本等 操作系统不同例如Windows和linux的多进程机制不同, linux种类不同, linux小版本不同 前端: 浏览器不同例如浏览器不同, 浏览器版本不同 Shell脚本命令不能加引号，如果是变量名表示执行命令则可以赋值时可以使用引号 print无法输出内容(特别是docker容器里)设置环境变量: PYTHONUNBUFFERED=1 参考资料","categories":[{"name":"编程思维","slug":"编程思维","permalink":"http://yoursite.com/categories/编程思维/"}],"tags":[{"name":"debug","slug":"debug","permalink":"http://yoursite.com/tags/debug/"}]},{"title":"使用 htop","slug":"编程基础/软件使用备忘/use-htop","date":"2019-05-29T06:56:59.000Z","updated":"2019-06-05T10:06:20.734Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-htop/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-htop/","excerpt":"","text":"隐藏重复的进程操作: F2(setup)—&gt;Display options—&gt;使用空格勾选”Hide userland process threads” 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"使用Adblock广告屏蔽插件","slug":"编程基础/软件使用备忘/use-Adblock","date":"2019-05-27T13:49:42.000Z","updated":"2019-05-27T10:06:39.575Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-Adblock/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-Adblock/","excerpt":"","text":"## 插件图标： 屏蔽规则12345678# 隐藏元素：host--网站域名 class_name--类名 id_name--id名host##.class_name host###id_name # 属性选择符##div[title*=\"adv\"] 隐藏 title 属性包含 adv 字符的 div 元素##table[width=\"80%\"] 隐藏 width 属性值为 80% 的表格元素##div[title^=\"adv\"][title$=\"ert\"] 隐藏 titile 属性以 adv 开始并且以 ert 结束的 div 元素 我的自定义配置文件：123sohu.com###right-side-barsohu.com###float-btnsohu.com##.groom-read 参考资料 https://adblockplus.org/filters","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"python源码转UML图","slug":"python/python源码转UML图","date":"2019-05-25T11:08:46.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/python源码转UML图/","link":"","permalink":"http://yoursite.com/wiki/python/python源码转UML图/","excerpt":"","text":"用conda制作模块安装12345# 需要安装的软件：## Graphviz：贝尔实验室开源的图形绘制工具包## Pyreverse：用来分析Python代码和类关系的工具，包含在Pylint中sudo apt install graphvizpip install pylint 调用12345678910pyreverse -o png -ASmy xxx.py# xxx.py 要解析的源代码文件# -o png 指定输出图片格式。 默认的dot格式。# -o tail.png 也可以携带tail 输出文件名= classes.tail.png# -A, --all-ancestors 展示项目中的所有祖先类# -a Ｎ 展示项目中的Ｎ代祖先类# -S, --all-associated 以递归方式显示所有关联的关联类# -m, --module-names=[yn] 在表示类中包含模块名称# 用法 -m y 或者 -my# -k, --only-classnames 类框中不显示属性和方法;这会禁用-f值","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"debug：pytorch_梯度出现NaN","slug":"人工智能/深度学习/pytorch/debug_pytorch_梯度出现NaN","date":"2019-05-22T11:00:45.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/人工智能/深度学习/pytorch/debug_pytorch_梯度出现NaN/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/pytorch/debug_pytorch_梯度出现NaN/","excerpt":"","text":"计算 梯度出现NaN 梯度出现异常值：NaN定位方法：使用如下代码设置，在出现NaN异常时程序会报错，便于定位错误代码 1234567import torch# 正向传播时：开启自动求导的异常侦测torch.autograd.set_detect_anomaly(True)# 反向传播时：在求导时开启侦测with torch.autograd.detect_anomaly(): loss.backward() 原因：很多网友提到，pytorch的求标准差的函数STD可能有问题。如果使用了类似会调用STD函数的各种Norm层就可能导致NAN问题。 官方文档参考","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"pytorch","slug":"人工智能/深度学习/pytorch","permalink":"http://yoursite.com/categories/人工智能/深度学习/pytorch/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"},{"name":"NaN","slug":"NaN","permalink":"http://yoursite.com/tags/NaN/"}]},{"title":"使用虚拟机","slug":"编程基础/软件使用备忘/使用虚拟机","date":"2019-05-09T02:55:35.000Z","updated":"2019-06-24T05:44:30.970Z","comments":true,"path":"wiki/编程基础/软件使用备忘/使用虚拟机/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/使用虚拟机/","excerpt":"","text":"安装虚拟机VirtualBox1234567891011# 首先添加VirtualBox的源sudo sh -c 'echo \"deb http://download.virtualbox.org/virtualbox/debian xenial contrib\" &gt;&gt; /etc/apt/sources.list.d/virtualbox.list'# 添加秘钥wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -# 执行更新sudo apt update# 安装virtualboxsudo apt install virtualbox 卸载1234567sudo apt remove virtualbox*# TODO: 未卸载完全, 需要删除文件/home/vbox/home/fish3/VirtualBoxVMs/usr/bin/VirtualBox -&gt; VBox*/usr/bin/VBox 使用方法简介 设置一个虚拟机 载入一个系统iso，安装系统 把系统导出，方便以后导入使用 ubtuntu虚拟机–设置共享文件夹宿主机上操作 123456789# 下载增强插件（注意插件版本要和虚拟机程序版本一致）https://www.virtualbox.org/wiki/DownloadsVirtualBox 6.0.6 Oracle VM VirtualBox Extension Pack All supported platforms # 老版本下载：Extension Pack https://www.virtualbox.org/wiki/Download_Old_Builds_5_2 # 安装宿主机上的插件 管理--全局设定--扩展--加号---选择下载插件-安装 选中虚拟机项目，右键—设置—共享文件夹—点击最右侧的加号按钮 在共享文件夹路径里设置宿主机里的某个路径，再设置一个共享文件夹名称 虚拟机内操作 安装增强插件 创建虚拟机内路径，然后挂载到该路径 1234567891011# ubuntu16.04sudo apt-get install virtualbox-guest-additions-isoapt-get install virtualbox-guest-utils# 参考# 创建路径mkdir /home/user/share# 挂载# 其中“share”就是共享文件夹的名称sudo mount -t vboxsf share /home/$user/share 参考网页 debug: 升级ubuntu的kernel后无法使用卸载老版本, 安装新版本(6.0以上支持kernel5.0) 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"use_tmux","slug":"编程基础/软件使用备忘/use-tmux","date":"2019-05-01T08:19:49.000Z","updated":"2019-05-13T08:59:49.096Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-tmux/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-tmux/","excerpt":"","text":"安装1sudo apt install tmux 概念 会话（session）：建立一个tmux工作区会话 窗口（window）：容纳多个窗格 窗格（pane）： 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"use-vscode","slug":"编程基础/软件使用备忘/use-vscode","date":"2019-04-27T09:49:58.000Z","updated":"2019-05-14T08:23:51.640Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-vscode/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-vscode/","excerpt":"","text":"使用正则表达式替换搜索文本：static/(.*).css 替换文本中用 $1来表示括号里匹配的内容 安装插件Setting Sync 在不同电脑同步你的配置和插件。上传配置： 安装插件 用默认浏览器登录github网站 shift+alt+U 上传配置：vscode会打开github网站的tokens页面 在网页选择 Generate new token 输入token key 勾选gist 点击Generate token 创建token 复制网页返回的token文本 在vscode的命令可输入token文本，回车 上传成功 下载备份： 在另一个电脑的vscode安装插件 shift+alt+D 下载配置：vscode会打开github网站的tokens页面 先输入token key 再输入token id 回车即可 如果在下载备份过程中出错，需要执行 Sync:Reset Extension Settings 重置选项才可以再次执行 shift+alt+d SFTP查看远程代码 ctrl+shift+P 输入 SFTP: config 如果提示要打开文件夹，则在某个位置打开一个存储SFTP配置的文件夹 然后进行配置json，示范如下： 12345678910&#123; \"name\": \"远程项目名称\", \"host\": \"192.168.1.10\", \"protocol\": \"sftp\", \"syncMode\": \"update\", \"username\": \"demo\", \"remotePath\": \"/home/demo/demo1\", \"privateKeyPath\": \"/home/user/.ssh/id_rsa\", \"uploadOnSave\": true&#125; Path Intellisense自动提示文件路径，支持各种快速引入文件。 Paste Json As Code把粘贴内容格式化。打开命令板，输入Paste Json As Code的命令即可 Gitlens查看代码的最后一行git日志。点击右上角图标即可对比展示你的代码与原repo的区别 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"尼康D5600相机","slug":"其他/nikon-d5600","date":"2019-04-23T03:49:54.000Z","updated":"2019-06-11T02:08:14.276Z","comments":true,"path":"wiki/其他/nikon-d5600/","link":"","permalink":"http://yoursite.com/wiki/其他/nikon-d5600/","excerpt":"","text":"操作设置查看照片信息菜单–播放菜单–播放显示选项 对焦点 无（仅图像） 查看照片播放按钮，左右是切换，上下是查看信息 闪光灯按钮： 镜头前左侧，最上方闪电图标的按钮 按下闪光按钮，波动拨盘，可以调整闪光幅度 拍摄P档：自动曝光拨盘：修改曝光参数组合（曝光时间、光圈） A档：光圈优先拨盘：修改光圈 F3.5大光圈（拍人物，背景会虚化） F22小光圈（大场景的风景照） S档：快门优先拨盘：修改快门时间 当改变快门到光圈的极限，光圈值会闪烁。这时候可以修改ISO （ISO增大，相同快门时间匹配更小的光圈） M档：手动曝光光圈、快门分别手工控制，不会关联变动。 曝光补偿使照片更亮，或更暗。 在AS档，曝光补偿会联动改变光圈或快门。 测光模式测光模式影响整个效果 ×××××××××××× i按钮info按钮BKT按钮 包围曝光的张数3F： 曝光补偿 0 1 2档 分别拍摄1张 -3F： 曝光补偿 0 -1 -2档 分别拍摄1张 QUAR–放大镜 按钮QUAR设置照片大小和格式 色温值 白平衡 固定参数：拍人像，用光圈优先模式和手动模式 室内灯光（曝光补偿会白）快门=1/50 光圈=F4.5 ISO=3200 曝光补偿=+0.7 白平衡4日光灯 快门=1/30 光圈=F4.5 ISO=3200 曝光补偿=+1.3 白平衡4日光灯 曝光锁定|对焦锁定 AE-L AF-L AF 自动对焦 d5600没有？ 模式AF-C AF-A AF-S 对焦区域 参考资料","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[]},{"title":"安装python","slug":"python/安装python","date":"2019-04-17T00:55:46.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/安装python/","link":"","permalink":"http://yoursite.com/wiki/python/安装python/","excerpt":"","text":"在ubuntu中安装python3.612345678sudo apt update \\ &amp;&amp; apt install -y software-properties-common \\ &amp;&amp; add-apt-repository -y ppa:jonathonf/python-3.6 \\ &amp;&amp; apt update \\ &amp;&amp; apt install -y python3.6 \\ &amp;&amp; update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.6 100 \\ &amp;&amp; update-alternatives --install /usr/bin/python python /usr/bin/python3.6 100 \\ &amp;&amp; apt install -y python3-pip \\ update-alternatives是Ubuntu中管理软件版本的工具 如果不设置名称, 则默认的python3实际是3.5 这时候安装python3-pip时会针对python3.5安装 update-alternatives用法说明: 12345678910# 查看python3这个名称对应了什么软件update-alternatives --display python3 # 把软件路径设置到某个链接和某个名称update-alternatives --install &lt;链接&gt; &lt;名称&gt; &lt;路径&gt; &lt;优先级&gt;链接是类似/usr/bin/python3 这样的软链接路径名称是类似python3 这样的软件名称路径是指软件的实际位置优先级数字越大越优先 用conda制作模块有时安装不上某个模块，可以尝试用conda安装。conda安装不上时，可以尝试去anaconda.org查询是否有这个模块是否在某个源 12conda install -c 某个源 模块名conda install -c conda-forge jsonnet conda创建虚拟环境conda创建虚拟环境，jupyter可以使用。 这个过程jupyter貌似不用重启，刷新页面即可。 12345678910111213141516171819# 1、创建环境conda create -n py36 python=3.6# 2、进入环境source activate py36# 3、然后添加kernel# 错误命令: 如果当前虚拟环境不是root用户的，而仅用有user权限。则sudo安装的kernel位置不会是当前虚拟环境的位置。sudo python -m ipykernel install --name py36 # 正确命令: 仅安装到当前用户，这个位置正确。如果提示没有权限，则给要写入的文件夹权限。python -m ipykernel install --user --name py36 # 如果提示没有ipykernel，使用:python -m pip install ipykernel# 4、退出虚拟环境source deactivate# 5、删除虚拟环境conda remove -n 环境名称 --all 删除kernel先找到配置文件kernel.json sudo find / -name “kernel.json” 判断倒数第一行是我的配置，所以删除/usr/local/share/jupyter/kernels/py36/的话即是删除了这个kernel。 /usr/local/share/jupyter/kernels/py36/kernel.json /home/fish/.local/share/jupyter/kernels/py27 用virtualenv安装虚拟环境1234567891011121314151617# 安装virtualenvpip install virtualenv# 列出所有环境lsvirtualenv# 创建环境virtualenv venvname# 创建环境，以 /usr/bin/python3 为python程序virtualenv -p /usr/bin/python3 venvname# 激活环境activate venvname# 退出环境deactivate# 删除环境rmvirtualenv venvname","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"python常见错误","slug":"python/python常见错误","date":"2019-04-15T00:46:54.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/python常见错误/","link":"","permalink":"http://yoursite.com/wiki/python/python常见错误/","excerpt":"","text":"用系统内置函数作为变量名比如下面的一些语句，会使你失去系统内置的功能： 123# 把内置类型或函数作为变量复制，导致原有功能失效set = &#123;1, 2, 3&#125;print = 'Hello' 将.py文件命名为内置模块的名称常常被覆盖的模块名有：abc、match、turtle等。比如，为了计算一个公式的值，把源代码文件命名为math.py，内容如下： 123456789import mathprint(math.sqrt(2)*2)# 报错Traceback (most recent call last):File \"/Users/chenbin/Documents/homework/math.py\", line 1, in &lt;module&gt;import mathFile \"/Users/chenbin/Documents/homework/math.py\", line 2, in &lt;module&gt;print(math.sqrt(2)*2)AttributeError: module 'math' has no attribute 'sqrt' 以为input函数是万能的初学者经常会以为input函数可以随心所欲得到想要的那种类型数值，特别是整数，比如： 12n = input(\"请输入年龄：\")print(\"明年你就\", n + 1, \"岁了！\") 结果出错，因为python3中的input函数返回的是字符串，必须要套一层int()才能得到整数。 可变类型的连续赋初值初学者觉得a=b=c=1这样赋初值特别cool，然后： 123456# 初始化了3个空列表，但这其实是幻觉# 因为它们仨指向了同一个可变类型的列表容器对象a=b=c=[] # 给a添加了一个元素a.append(123) # 其实a,b,c指向的是同一个列表，结果a,b,c都是[123] 记住，只有不可变类型的对象可以这么赋初值，或者你确实需要几个指向同一个可变对象的变量（这几乎不会出现）。 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"npm","slug":"编程基础/软件使用备忘/npm","date":"2019-04-12T08:38:37.000Z","updated":"2019-06-11T02:07:34.993Z","comments":true,"path":"wiki/编程基础/软件使用备忘/npm/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/npm/","excerpt":"","text":"npm run dev 热更新代码123./config/index.jsmodule.exports = &#123;poll: true&#125; # 确定改成true即可热更新 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"python常用代码","slug":"python/python常用代码","date":"2019-04-10T14:46:50.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/python常用代码/","link":"","permalink":"http://yoursite.com/wiki/python/python常用代码/","excerpt":"","text":"计数器对象 class collections.Counter12c = Counter() # 创建c.most_common(3) # 返回频次前3的二维数组，降序排列。不加参数则返回全部。 [(word, count)] 向上取整1(分子 + 分母 - 1) // 分母 tqdm进度条12345from tqdm import tqdmgen_tqdm = tqdm(gener, total=len(gener))for i in gen_tqdm: # 实时修改进度条上的描述文本 gen_tqdm.set_description(description, refresh=False) 交换变量快捷写法：最多支持4个变量互换123a, b, c = 1,2,3a,b,c = c,a,b# 结果： a=3 b=1 c=2 如果交换内容涉及：对象及其属性，需要考虑先后顺序123456789101112131415161718class ListNode: def __init__(self, x): self.val = x self.next = None # 正确的交换 node = ListNode(1) ; node.next = 2node.next, node = node.val, node.next# 结果： node=2 # 错误的交换 node = ListNode(1) ; node.next = 2node, node.next = node.next, node.val# 结果报错信息：# AttributeError: 'int' object has no attribute 'next'# node = node.next (2)# node.next = node.val int没有next属性 原因 交换的不是变量，而是变量的地址。地址变化是有顺序的，并不是同时完成的。 如果没有涉及到对象及其属性，地址变化不会影响取值过程，所以不会报错。所以看起来像是一句代码同时完成了一样。 python解释得出的执行码中有4个指令：ROT_TWO /ROT_THREE/ROT_FOUR 所以交换赋值语句最多支持4个变量 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"jupyter_notebook","slug":"python/jupyter-notebook","date":"2019-04-07T09:58:44.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/jupyter-notebook/","link":"","permalink":"http://yoursite.com/wiki/python/jupyter-notebook/","excerpt":"","text":"配置远程密码12345678910111213141516171819202122232425# 生产配置文件jupyter notebook --generate-config# 生成密码# 1. 打开ipython 执行下面2行代码from notebook.auth import passwdpasswd()# 输入2两次密码，生成sha值# 编辑配置文件 ~/.jupyter/jupyter_notebook_config.pyc.NotebookApp.ip='127.0.0.1'c.NotebookApp.allow_remote_access=Truec.NotebookApp.password=u'sha:xxxxxx生成内容'c.NotebookApp.open_browser=Falsec.NotebookApp.port=8888# 配置代码根目录c.ContentsManager.root_dir = '/home/aifish/FishCode'# 启动服务jupyter notebook# 设置开机启动# 加入 rc.localnohup /home/aifish/anaconda3/bin/jupyter notebook&gt;/home/aifish/.jupyter/notebook.log 2&gt;&amp;1 &amp; 把虚拟环境添加到jupyter的kernel1234567进入虚拟环境# 安装 ipykernelpip install ipykernel# 找到python位置（因为加入kernel时需要sudo权限，要制定python路径which python# 使用python绝对路径, 把虚拟环境XXXX加入kernelsudo /anaconda/env/python -m ipykernel install --name XXXX 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"jupyter","slug":"jupyter","permalink":"http://yoursite.com/tags/jupyter/"},{"name":"notebook","slug":"notebook","permalink":"http://yoursite.com/tags/notebook/"}]},{"title":"linux刻录光盘","slug":"编程基础/软件使用备忘/linux_write_DVD","date":"2019-04-02T07:26:08.000Z","updated":"2019-05-27T07:49:50.829Z","comments":true,"path":"wiki/编程基础/软件使用备忘/linux_write_DVD/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/linux_write_DVD/","excerpt":"","text":"ubuntu–Brasero 在Ubuntu软件商店安装brasero 光驱插入光盘 打开brasero 选择：数据项目(A)：创建一个视频DVD或SVCD 点击添加按钮，加入文件夹或文件 给光盘命名（默认是日期文本） 显示进度条，等待刻录完成 注意：带很多代码和数据文件的文件夹，要先压缩再刻盘。 不然有可能刻盘失败。 光盘也不能用了。。。。大小：4000M比较靠谱（存储空间比真实文件更大）sudo tar cjf - police_model |split -b 4000m - police.v9. 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"allennlp 类","slug":"人工智能/深度学习/allennlp/allennlp-classes","date":"2019-03-31T12:14:52.000Z","updated":"2019-06-05T10:06:20.722Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-classes/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-classes/","excerpt":"","text":"allennlp/data/vocabulary.py allennlp/data/tokenizers/token.py allennlp/data/dataset_readers/dataset_reader.py allennlp/models/simple_tagger.py allennlp.data.token_indexers.TokenIndexerallennlp.data.token_indexers.single_id_token_indexerallennlp.common.util.get_frozen_and_tunable_parameter_namesallennlp.common.params.Paramsallennlp.training.trainer.Trainerallennlp.models.archival.archive_modelallennlp.data.iterators.data_iteratorallennlp.models.modelallennlp.data.vocabularyallennlp.data.dataset_reader 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[]},{"title":"allennlp 命令执行流程","slug":"人工智能/深度学习/allennlp/allennlp-command","date":"2019-03-31T11:09:04.000Z","updated":"2019-07-12T00:51:14.811Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-command/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-command/","excerpt":"","text":"Successfully installed Jinja2-2.10.1 MarkupSafe-1.1.1 PyYAML-5.1 Pygments-2.4.2 Werkzeug-0.15.4 alabaster-0.7.12 allennlp-0.8.4 atomicwrites-1.3.0 attrs-19.1.0 awscli-1.16.190 babel-2.7.0 blis-0.2.4 boto3-1.9.180 botocore-1.12.180 click-7.0 colorama-0.3.9 conllu-0.11 cycler-0.10.0 cymem-2.0.2 docutils-0.14 editdistance-0.5.3 flaky-3.6.0 flask-1.0.3 flask-cors-3.0.8 ftfy-5.5.1 gevent-1.4.0 greenlet-0.4.15 h5py-2.9.0 imagesize-1.1.0 importlib-metadata-0.18 itsdangerous-1.1.0 jmespath-0.9.4 joblib-0.13.2 jsonnet-0.13.0 jsonpickle-1.2 jsonschema-3.0.1 kiwisolver-1.1.0 matplotlib-3.1.0 more-itertools-7.1.0 murmurhash-1.0.2 nltk-3.4.3 numpy-1.16.4 numpydoc-0.9.1 overrides-1.9 packaging-19.0 parsimonious-0.8.1 plac-0.9.6 pluggy-0.12.0 preshed-2.0.1 protobuf-3.8.0 py-1.8.0 pyasn1-0.4.5 pyparsing-2.4.0 pyrsistent-0.15.2 pytest-5.0.0 python-dateutil-2.8.0 pytorch-pretrained-bert-0.6.2 pytz-2019.1 regex-2019.6.8 responses-0.10.6 rsa-3.4.2 s3transfer-0.2.1 scikit-learn-0.21.2 scipy-1.3.0 snowballstemmer-1.9.0 spacy-2.1.4 sphinx-2.1.2 sphinxcontrib-applehelp-1.0.1 sphinxcontrib-devhelp-1.0.1 sphinxcontrib-htmlhelp-1.0.2 sphinxcontrib-jsmath-1.0.1 sphinxcontrib-qthelp-1.0.2 sphinxcontrib-serializinghtml-1.1.3 sqlparse-0.3.0 srsly-0.0.7 tensorboardX-1.7 thinc-7.0.4 torch-1.1.0 tqdm-4.32.2 unidecode-1.1.1 wasabi-0.2.2 wcwidth-0.1.7 word2number-1.1 zipp-0.5.1 安装tensorboard12345# 先要安装tensorboard和tensorflowpip install tensorflow tensorboard# 再安装tensorboardxpip install tensorboardX Allennlp代码整体逻辑 自定义对象 datareader(数据读取器) 必须有方法.read dataset = datareader.read(数据文件) 默认dataset.instances 是数据集的每个实例，Instance 是由一个命名的field集合组成的 instance.fields 是一个实例的所有字段 fields[‘title’].tokens 是文本标记序列 tokens[0].text 是一个词汇文本 fields[‘label’].label 是实例的正确分类标签文本key=‘label’ 能让数据变得更加通用（而不写具体数据种类） Field字段类(字段数据) 这些字段的数据是普通字符串，但是进入模型前会转化成ID TextField文本字段类 LabelerField 范畴标签字段类 Vocabulary类(词典) 有多个命名空间 默认命名空间 token 输入的词汇标记 默认命名空间 label 输出的标签 Predictor类(预测器) 包装一个模型，进行预测：json输入，json输出（而非张量） 需要重写predicotr.predict_json()函数，从输入json转成instance（带张量） 预测命令：predict```12345678910111213141516171819202122232425262728293031323334 1. 需要一个归档文件 ( 即一个训练好的模型 ) 2. 需要一个输入文件 ( 每行有一个 JSON 输入 ) 6. 网页演示 1. 需要一个训练好的模型 2. 需要写好预测器2. 自定义对象 model 1. 输入输出字典的value是张量3. 配置一个json文件：写入模型和训练等参数## 命令执行流程```python# 程序入口： allennlp.commands.main()# subparser 子命令:&quot;configure&quot;: allennlp.commands.configure.Configure()&quot;train&quot;: allennlp.commands.train.Train()&quot;evaluate&quot;: allennlp.commands.evaluate.Evaluate()&quot;predict&quot;: allennlp.commands.predict.Predict()&quot;make-vocab&quot;: allennlp.commands.make_vocab.MakeVocab()&quot;elmo&quot;: allennlp.commands.elmo.Elmo()&quot;fine-tune&quot;: allennlp.commands.fine_tune.FineTune()&quot;dry-run&quot;: allennlp.commands.dry_run.DryRun()&quot;test-install&quot;: allennlp.commands.test_install.TestInstall()&quot;find-lr&quot;: allennlp.commands.find_learning_rate.FindLearningRate() 训练流程调用的类和方法123456789&gt;&gt;&gt; allennlp train XXXallennlp/commands/__init__.py main()allennlp/commands/train.py Train()allennlp/commands/train.py Train.train_model_from_args()allennlp/commands/train.py Train.train_model_from_file()allennlp/commands/train.py Train.train_model()allennlp/training/trainer.py Trainer()allennlp/training/trainer.py Trainer.train()allennlp/training/trainer.py Trainer._train_epoch() 12345678# 训练# -r就会使用之前已经创建好的词典allennlp train XXX -s XXX# 启动配置助手(网页)allennlp configure --port 8123 词汇对照表 英文 中文 tag 序列标记（NER输出等） label 类别标签（分类任务输出等） index 索引 padding 填充 Trainer初始化参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Trainer初始化参数----------model：``Model``，必需。要优化的AllenNLP模型，或者是Pytorch模块（它的forward方法必须返回字典，并包含key=“loss”，value=scalar tensor）optimizer：``torch.nn.Optimizer``，必需。 Pytorch Optimizer的一个实例，使用要优化的模型的参数进行实例化。 iterator：``DataIterator``，必需。 迭代“Dataset”的方法，产生填充并转成索引的批次数据。 train_dataset：``Dataset``，必需。 要训练的“Dataset”。数据集应该已经转成索引。 validation_dataset：``Dataset``，可选，（默认=None）。 要评估的“Dataset”。数据集应该已经转成索引。 patience：可选[int]&gt; 0，可选（默认=None） 在early stopping之前要观察的epoch数量：在“patience”个epoch都没有改善则提早停止。如果给出，它必须是“&gt; 0”。 如果为None，则禁用early stopping。 validation_metric：str，optional（default =“loss”） 用来衡量是否使用提早停止以及是否在每个epoch存储is_best模型。度量标准名称必须以“+”或“ - ”为前缀，指定度量标准是增加还是减少。 validation_iterator：``DataIterator``，可选（默认=None） 用于验证集的迭代器。如果是None，那么使用训练集的iterator。 shuffle：``bool``，可选（默认= True） 是否在迭代器中对实例进行随机洗牌。 num_epochs：int，optional（默认值= 20） 培训epoch数量。 serialization_dir：str，optional（默认=None） 用于保存和加载模型文件的目录路径。如果未传递此参数，则不会保存模型。 num_serialized_models_to_keep：``int``，可选（默认= 20） 要保留的先前模型检查点的数量。默认是保留20个检查点。 值为None或-1表示将保留所有检查点。 keep_serialized_model_every_num_seconds：``int``，可选（默认=None） 如果num_serialized_models_to_keep不是None，那么除了最后一个num_serialized_models_to_keep之外，偶尔以给定间隔保存模型也很有用。 为此，请将keep_serialized_model_every_num_seconds指定为永久保存的检查点之间的秒数。请注意，此选项仅在以下情况下使用 num_serialized_models_to_keep不是None，否则保留所有检查点。 model_save_interval：``float``，可选（默认=None） 如果提供，则在单个epoch中每隔N秒存储一次模型。如果提供serialization_dir在每个epoch结束时也会保存模型。 cuda_device：``int``，可选（默认= -1） 一个整数，指定要使用的CUDA设备。如果为-1，则使用CPU。 grad_norm：``float``，可选，（默认=None）。 如果提供，则会按最大值调整梯度。 grad_clipping：``float``，可选（默认=``无``）。 如果提供，渐变将在“向后传递”期间被剪切以具有该值的（绝对）最大值。如果你在训练期间在渐变中得到“NaNs” 使用``grad_norm``无法解决，你可能需要这个。 learning_rate_scheduler：``PytorchLRScheduler``，可选，（默认=None） Pytorch学习速率调度程序。在每个epoch结束时，学习率将相对于该时间表衰减。如果你使用`torch.optim.lr_scheduler.ReduceLROnPlateau类`，这将使用提供的`validation_metric`来确定学习是否已达到稳定状态。支持每个batch更新学习率，这可以选择实现step_batch（batch_num_total），它更新给定batch的学习率。 summary_interval：``int``，可选，（默认= 100） 记录标量到tensorboard之间的批次数 histogram_interval：``int``，optional，（default =``None``） 如果不是None，则每N个batch的柱状图记录到tensorboard。 指定此参数后，将启用以下附加日志记录： *模型参数的柱状图 *参数更新率 *层激活的柱状图 我们记录model.get_parameters_for_histogram_tensorboard_logging 返回的参数的柱状图。 对于``Model``中具有属性``should_log_activations``设置为``True``的任何模块，都会记录图层激活。记录柱状图在训练期间需要许多GPU-CPU副本，并且通常很慢，因此我们建议相对不频繁地记录柱状图。 注意：只有返回张量的模块，张量的元组或dict支持activations日志。 should_log_parameter_statistics：``bool``，可选，（默认= True）是否发送参数统计（平均值和标准差）参数和梯度）到张量板。should_log_learning_rate：``bool``，可选，（默认= False）是否将参数特定学习率发送到tensorboard。log_batch_size_period：``int``，optional，（default =``None``）如果已定义，则记录平均批量大小的频率。“” Vocabulary12345678910111213141516171819202122232425262728293031词汇表将字符串映射到整数，允许将字符串映射到OOV标记（out-of-vocabulary OOV）。词汇表适合特定的数据集，我们用它来决定哪些tokens是词汇表内的。词汇表还允许使用多个不同的命名空间，因此你可以有不同的index对应单词“a”和字符“a”。例如我们可以使用此对象将tags和labels文本映射到index，用一个统一的类：xxx_Field。此类中的大多数方法都允许你传入命名空间; 默认情况下，我们使用'tokens'命名空间，你可以在任何地方省略命名空间参数，只使用默认值。参数----------counter：`Dict [str，Dict [str，int]]`，可选（默认=`None`） 用于初始化此词汇表的计数集合。我们将检查计数，并与该类的其他参数一起使用它们来决定哪些单词是词汇表。如果这是None，我们就不会用任何东西初始化词汇表。min_count：`Dict [str，int]`，可选（默认=None） 从计数器初始化词汇表时，你可以指定最小计数，并且计数小于此值的每个标记都不会添加到词典中。这些最小计数是“特定于命名空间的”，因此你可以为标签与单词指定不同的最小值。如果命名空间在给定的字典中没有key，我们将所有看到的标记添加到该命名空间。max_vocab_size：`Union [int，Dict [str，int]]`，可选（默认=None） 如果要限制词汇表中的令牌数量，可以使用此参数执行此操作。如果指定单个整数，则每个命名空间的词汇表都将固定为不大于此值。如果指定一个字典，那么`counter`中的每个命名空间都可以有一个单独的最大词汇量。任何缺失的键都将具有值“None”，这意味着词汇量大小没有上限。non_padded_namespaces：`Iterable [str]`，可选 默认情况下，我们假设你将单词/字符标记映射为整数，因此你希望为padding和OOV保留单词索引。但是，如果要将NER或SRL的tag或类别标签映射到整数，则可能不希望保留padding和OOV索引。使用此字段指定哪些名称空间不应添加padding和OOV标记。 这个元素的格式是一个字符串，它必须与字段名称完全匹配，或者`*`后跟一个字符串，我们将它们作为字段名称的后缀。 我们尝试使默认值合理，这样你就不必考虑这一点。 默认为（tags，labels），因此只要您的命名空间以“tags”或“labels”结尾（默认情况下，此代码中的所有tag和labels字段均为true）， 不必在这里指定任何东西。pretrained_files：`Dict [str，str]`，可选 如果提供，此映射指定每个命名空间的可选预训练嵌入文件的路径。这可以用于将词汇表限制为仅出现在此文件中的单词，或者确保此文件中的任何单词都包含在词汇表中，而不管其计数如何，具体取决于“only_include_pretrained_words”的值。 出现在预训练嵌入文件中但未出现在数据中的单词不包含在词汇表中。min_pretrained_embeddings：`Dict [str，int]`，可选 如果提供，则为每个命名空间指定与预训练嵌入文件保持一致的最小行数（通常是最常用的单词），即使对于未出现在数据中的单词也是如此。only_include_pretrained_words：`bool`，可选（默认= False） 这定义了使用可能在`pretrained_files`中指定的任何预训练嵌入文件的策略。如果为False，则使用包含策略：并且将“计数器”和预训练文件中的单词添加到“词汇表”中，而不管它们的计数是否超过“min_count”。如果为True，我们使用独占策略：如果单词位于预训练嵌入文件中，则单词仅包含在词汇表中（它们的计数必须至少为'min_count`）。tokens_to_add：`Dict [str，List [str]]`，可选（默认=None） 如果给定，这是一个要添加到词汇表的标记列表，由命名空间键入以添加标记。这是一种确保某些项目出现在词汇表中的方法，无论其他任何词汇计算如何。 tensorboard12345678910111213141516171819class TensorboardWriter(get_batch_num_total: Callable[int], serialization_dir: Optional[str] = None, summary_interval: int = 100, histogram_interval: int = None, should_log_parameter_statistics: bool = True, should_log_learning_rate: bool = False)get_batch_num_total：Callable [[]，int]到目前为止返回批次数的thunk。 很可能这将是一个围绕Trainer类中的实例变量的闭包。serialization_dir：str，optional（默认=None）如果提供，则这是Tensorboard日志的写入位置。summary_interval：int，optional（默认值= 100）大多数统计数据只会在这么多批次中写出来。histogram_interval：int，optional（default = None）如果提供，则每隔这些批次就会记录激活柱状图。 如果为None，则不会写。should_log_parameter_statistics：bool，optional（default = True）是否记录参数统计信息。should_log_learning_rate：bool，optional（默认= False）是否记录学习率。 indexer索引器12345678910111213141516171819202122232425262728TokenIndexer“TokenIndexer”确定字符串标记如何表示为模型中的索引数组。这个类在a的帮助下将字符串转换为数值：class：`~allennlp.data.vocabulary.Vocabulary`，它产生实际的数组。标记可以表示为单个ID（例如，单词“cat”由数字表示34），或作为字符ID列表（例如，“cat”由数字[23,10,18]表示），或以某种其他方式，你可以提出（例如，如果你有一些结构化的输入你想要在数据数组中以特殊方式表示，你可以在这里做到这一点）。default_implementation ='single_id'def count_vocab_items（self，token：Token，counter：Dict [str，dict [str，int]]）： ：class：`Vocabulary`需要为我们在训练数据中看到的任何字符串分配索引（可能进行一些频率过滤和使用OOV，或者使用词汇表，令牌）。对于令牌中存在的任何词汇项，此方法采用令牌和计数字典和增量计数。如果这是单个令牌ID表示，则词汇表项可能是令牌本身。如果这是令牌字符表示，则词汇表项是令牌中的所有字符。def tokens_to_indices（self，tokens：List [Token]，词汇：Vocabulary，index_name：str） - &gt; Dict [str，List [TokenType]]： 获取令牌列表并将其转换为一组或多组索引。这可能只是词​​汇表中每个标记的ID。或者它可以将每个标记分成字符并返回每个字符一个ID。或者（例如，在字节对编码的情况下）可能没有从单个令牌到索引的干净映射。def get_padding_token（self） - &gt; TokenType： 当我们需要添加填充令牌时，它们应该是什么样的？此方法返回由以下函数返回的任何类型的“空白”标记：func：`tokens_to_indices`。def get_padding_lengths（self，token：TokenType） - &gt; Dict [str，int]： 此方法返回给定标记的填充字典，该字典指定需要填充的所有数组的长度。例如，对于单个ID令牌，返回的字典将为空，但对于令牌字符表示，这将返回令牌中的字符数。def pad_token_sequence（self，tokens：Dict [str，List [TokenType]]，desired_num_tokens：Dict [str，int]，padding_lengths：Dict [str，int]） - &gt; Dict [str，List [TokenType]]： 此方法将令牌列表填充到“desired_num_tokens”并返回输入令牌的填充副本。如果输入标记列表长于“desired_num_tokens”，那么它将被截断。 `padding_lengths`用于提供在某些情况下需要的补充填充参数。例如，它包含在执行字符级填充时填充字符的宽度。def get_keys（self，index_name：str） - &gt; List [str]： 返回此索引器从`tokens_to_indices`返回的键列表。 Field 字段Field 字段基类1234567891011121314151617181920212223242526272829Field“字段”是instance数据实例的一部分，最终作为模型中的张量（作为输入或输出）。 数据实例只是字段的集合。 字段最多经历两个处理步骤：（1）将标记化字段转换为标记ID，（2）填充包含标记id（或任何其他数字数据）的字段（如果需要）并转换为张量。 `Field`API有这两个步骤的方法，虽然它们可能不需要一些具体的`Field`类 - 如果你的字段没有任何需要索引的字符串，你不需要实现`count_vocab_items` 或`索引`。 这些方法默认为`pass`。 一旦计算出词汇表并对所有字段编制索引，我们将确定填充长度，然后智能地将实例批处理并将它们填充到实际张量中。def count_vocab_items（self，counter：Dict [str，dict [str，int]]）：“”“如果这个字段中的字符串需要通过：class：`Vocabulary`转换成整数，这里就是我们统计它们的位置，以确定哪些令牌在词汇表之内或之外。 如果你的`Field`没有任何需要转换为索引的字符串，你不需要实现这个方法。 关于这个`counter`的注释：因为`Fields`可以代表概念上不同的东西，我们用`namespaces`分隔词汇项。这样，我们可以使用单个共享机制来处理从字符串到所有字段中的整数的所有映射，同时保持`TextField`中的单词与`LabelField`中的标签共享相同的id（例如，\"entailment\" or \"contradiction\"是蕴涵任务中的标签” 另外，单个`Field`可能想要使用多个名称空间 - “TextFields”可以表示为单词ID和字符id的组合，并且您不希望单词和字符共享相同的vocabulary - “a”作为单词应该从“a”作为一个字符获得不同的id，并且单词和字符的词汇量大小非常不同。 因此，`counter`对象中的第一个键是`namespace'，如“tokens”，“token_characters”，“tags”或“labels”，第二个键是实际的词汇表项item。 def index（self，vocab：Vocabulary）： 给定一个：class：`Vocabulary`，将该字段中的所有字符串转换为（通常）整数。这个`修改``Field`对象，它不返回任何东西。 如果你的`Field`没有任何需要转换为索引的字符串，你不需要实现这个方法。def get_padding_lengths（self） - &gt; Dict [str，int]： 如果此字段中有需要填充的内容，请在此处记下。为了填充一批实例，我们从批处理中获取所有长度，取最大值，并将所有内容填充到该长度（或使用预先指定的最大长度）。返回值是将键映射到长度的字典，例如&#123;'num_tokens'：13&#125;。 这总是在：func：`index`之后调用。 msgstr“”“引发NotImplementedErrordef as_tensor（self，padding_lengths：Dict [str，int]） - &gt; DataArray： 给定一组指定的填充长度，实际填充此字段中的数据并返回正确形状的割炬张量（或更复杂的数据结构）。我们还采用了一些在构建火炬传感器时很重要的参数。 参数---------- padding_lengths：`Dict [str，int]`这个字典将具有与func：`get_padding_lengths`相同的键。这些值指定填充每个相关维度时使用的长度，这些维度在批处理中的所有实例之间聚合。 msgstr“”“引发NotImplementedErrordef empty_field（self） - &gt;'Field'： 因此`ListField`可以填充列表中的字段数（例如，答案选项`TextFields`的数量），我们需要表示每种类型的空字段。这会返回。这只会在我们调用时调用：func：`as_tensor`，所以你不必担心在这个空字段上调用`get_padding_lengths`，`count_vocab_items`等等。 我们使这个实例方法而不是静态方法，这样如果Field中有任何状态，我们可以复制它（例如，`TextField`中的标记索引器）。 msgstr“”“引发NotImplementedErrordef batch_tensors（self，tensor_list：List [DataArray]） - &gt; DataArray：#type：ignore从`Instances`列表中获取`Field.as_tensor（）`的输出，并将其合并为一个批量张量为此`Field` 。这里基类的默认实现处理`as_tensor`为每个实例返回一个火炬张量的情况。如果您的子类返回除此之外的其他内容，则需要覆盖此方法。 这个操作不会修改`self`，但在某些情况下我们需要`self`中包含的信息来执行批处理，所以这是一个实例方法，而不是类方法。 “”#pylint：disable = no-self-use return torch.stack（tensor_list） SequenceField 序列字段12SequenceField`SequenceField`代表一系列事物。 这个类只是在`Field` :: func：`sequence_length`上添加了一个方法。 它的存在使得`SequenceLabelField`，`IndexField`和其他类似的`Fields`可以有一个类型要求，具有一致的API，它们是指向`TextField`中的单词，`ListField`中的项目，还是 别的。 TextField 文本字段123456TextField这个`Field`代表一个字符串标记列表。 在构造此对象之前，需要使用：class：`~allennlp.data.tokenizers.tokenizer.Tokenizer`来标记原始字符串。因为字符串标记可以通过多种方式表示为索引数组，所以我们还会使用以下字典：class：`~allennlp.data.token_indexers.token_indexer.TokenIndexer`对象，用于将标记转换为索引。 每个“TokenIndexer”可以将每个标记表示为单个ID，或者字符ID列表或其他内容。该字段将被转换为数组字典，每个`TokenIndexer`一个。 `SingleIdTokenIndexer`生成一个形状数组（num_tokens，），而`TokenCharactersIndexer`生成一个形状数组（num_tokens，num_characters）。 SequenceLabelField1234567891011121314151617181920212223SequenceLabelField`SequenceLabelField`为a中的每个元素分配一个分类标签产品类别：`〜allennlp.data.fields.sequence_field.SequenceField`。因为它是某个其他字段的标签，我们在此处将该字段作为输入，我们将其用于确定我们的填充和其他东西。此字段将转换为整数类ID列表，表示正确的类对于序列中的每个元素。参数----------标签：`Union [List [str]，List [int]]` 一系列分类标签，编码为字符串或整数。这些可能是POS标签，如[NN，JJ，...]，BIO标签，如[B-PERS，I-PERS，O，O，...]，或任何其他分类标签序列。如果标签被编码为整数，则不会使用词汇对其进行索引。sequence_field：`SequenceField` 包含此SequenceLabelField`标记序列的字段。大多数情况下，这是一个“TextField”，用于标记句子中的单个标记。label_namespace：`str`，optional（default ='labels'） 用于将标记字符串转换为整数的命名空间。我们将标记字符串转换为整数，并且此参数告诉`Vocabulary`对象从字符串到整数的映射使用（因此“O”作为标记不会获得与“O”作为单词相同的id） 。“””＃用户可能希望将此字段与使用OOV / PAD令牌的命名空间一起使用。＃对于此类的每个实例化（即每个数据），将重复此警告#instance），喷出很多警告，所以这个类变量只用于记录单个变量每个命名空间＃警告。 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[{"name":"allennlp","slug":"allennlp","permalink":"http://yoursite.com/tags/allennlp/"},{"name":"command","slug":"command","permalink":"http://yoursite.com/tags/command/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"allennlp_json_config","slug":"人工智能/深度学习/allennlp/allennlp-json-config","date":"2019-03-31T11:04:31.000Z","updated":"2019-04-01T14:12:35.640Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-json-config/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-json-config/","excerpt":"","text":"第一层配置1234567&#123; \"dataset_reader\": &#123;&#125;, \"train_data_path\": \"\", \"model\": &#123;&#125;, \"iterator\": &#123;&#125;, \"trainer\": &#123;&#125;&#125; 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[{"name":"allennlp","slug":"allennlp","permalink":"http://yoursite.com/tags/allennlp/"},{"name":"配置文件","slug":"配置文件","permalink":"http://yoursite.com/tags/配置文件/"}]},{"title":"allennlp_models","slug":"人工智能/深度学习/allennlp/allennlp-models","date":"2019-03-29T09:29:52.000Z","updated":"2019-05-01T11:43:43.276Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-models/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-models/","excerpt":"","text":"crf_taggerallennlp/models/crf_tagger.py class CrfTagger 12345678910111213141516171819202122232425262728293031323334`CrfTagger`使用`Seq2SeqEncoder`编码一系列文本，然后使用条件随机场模型来预测序列中每个标记的标记。参数----------vocab：`Vocabulary'，必需 用于计算输入/输出尺寸大小所需的词汇表。text_field_embedder：`TextFieldEmbedder`，必需 用于嵌入标记`TextField`，我们将其作为模型的输入。encoder：`Seq2SeqEncoder` 我们将在嵌入令牌和预测输出标签之间使用的编码器。label_namespace：`str`，optional（默认 =`labels`） 这是计算SpanBasedF1Measure指标所必需的。 除非你做了一些特殊处理，否则默认值即可。feedforward：`FeedForward`，可选，（默认=None）。 在编码器之后应用的可选前馈层。label_encoding：`str`，optional（默认=None） 在计算跨度f1时使用的标签编码，并在解码时限制CRF。有效选项是“BIO”，“BIOUL”，“IOB1”，“BMES”。 如果`calculate_span_f1`或`constrain_crf_decoding`为真，则为必需。include_start_end_transitions：`bool`，可选（默认=True） 是否在CRF中包含开始和结束转换参数。constrain_crf_decoding：`bool`，optional（默认=None） 如果为“True”，则CRF在解码时被约束以产生有效的标签序列。如果这是'True`，则需要`label_encoding`。如果指定了“None”和label_encoding，则将其设置为“True”。 如果未指定`None`和label_encoding，则默认为'False`。calculate_span_f1：`bool`，可选（默认=None） 在培训期间计算跨度级F1指标。如果这是'True`，则需要`label_encoding`。如果指定了“None”和label_encoding，则将其设置为“True”。 如果未指定`None`和label_encoding，则默认为'False`。dropout：`float`，optional（默认=None）verbose_metrics：`bool`，可选（默认= False） 如果为true，则除了整体统计信息之外，还将为每个标签类返回指标。初始化程序：`InitializerApplicator`，可选（默认=`InitializerApplicator（）`） 用于初始化模型参数。正规化器：`RegularizerApplicator`，可选（默认=None） 如果提供，将用于计算训练期间的正则化惩罚。 Coreference Resolution 指代消解该模型在CoNLL测试集的F1达到63.0% 123456# 引用模型from allennlp.predictors.predictor import Predictorpredictor = Predictor.from_path(\"https://s3-us-west-2.amazonaws.com/allennlp/models/coref-model-2018.02.05.tar.gz\")predictor.predict( document=\"The woman reading a newspaper sat on the bench with her dog.\") Named Entity Recognition 命名实体识别模型使用ELMo嵌入的biLSTM 参考资料 https://allennlp.org/models","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[{"name":"allennlp","slug":"allennlp","permalink":"http://yoursite.com/tags/allennlp/"},{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"}]},{"title":"python代码加密","slug":"python/python代码加密","date":"2019-03-29T07:45:48.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/python代码加密/","link":"","permalink":"http://yoursite.com/wiki/python/python代码加密/","excerpt":"","text":"目前的加密手段： 源代码混淆：只降低源码可读性，对破解有一定的干扰作用 只发行 pyc: 可以用现成工具复原 打包 exe: 可以用现成工具复原 cython打包so文件: 要加密单一的模块 /特制算法很有效，不过对很多复杂模块无法兼容，比如 django 写的 app 修改python解释器: 未丢失信息，容易复原 总结：python语言在设计理念上倾向于开源，没有很完美的加密方案，只能有限程度上增加破解者的难度（对于有经验的破解者形同虚设） 其他方案： 核心代码逻辑替换成 C++ 或 go语言 终极方案： 只提供api服务，不提供本地运行的程序","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"命令行参数和环境变量","slug":"python/命令行参数和环境变量","date":"2019-03-29T01:04:15.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/命令行参数和环境变量/","link":"","permalink":"http://yoursite.com/wiki/python/命令行参数和环境变量/","excerpt":"","text":"命令行参数argv12345import sysnum = len(sys.argv) # 参数个数script_name = sys.argv[0] # 脚本命令名称arg1 = sys.argv[1] # 参数1arg2 = sys.argv[2] # 参数2 argparse命令行参数模块基础用法：必须参数12345678# 导入命令行解析的库文件import argparse # pkg是一个必须的位置参数(因为前面没有横杠，所以是位置参数。因为没有默认值，所以是必须参数)parse.add_argument('pkg',help='help')# 命令行执行 --help时，会查看的说明parse = argparse.ArgumentParser(description=\"test!!\") 可选参数1234567# nargs是默认值，有默认值的参数是可选参数parse.add_argument('keyoukewu',help='xx'，nargs='?') # 前缀是‘-’的参数名是缩写，前缀是‘--’的参数名是全称parse.add_argument('-a','--abc',help='xx',nargs='?')print(args.abc)print(args.a) # 是错误的：因为解析的时候必须用全称 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"thread多线程模块","slug":"python/多线程、多进程、协程","date":"2019-03-27T08:30:26.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/多线程、多进程、协程/","link":"","permalink":"http://yoursite.com/wiki/python/多线程、多进程、协程/","excerpt":"","text":"概述threading用于提供线程相关的操作，线程是应用程序中工作的最小单元。 python当前版本的多线程库没有实现优先级、线程组，线程也不能被停止、暂停、恢复、中断。 threading模块提供的类： Thread, Lock, Rlock, Condition, [Bounded]Semaphore, Event, Timer, local。 threading 模块提供的常用方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 ​ threading.currentThread().getName()获取当前程序的线程名称 threading 模块提供的常量： threading.TIMEOUT_MAX 设置threading全局超时时间。 Thread类构造方法： Thread(group=None, target=None, name=None, args=(), kwargs={}) group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 线程名； args/kwargs: 要传入方法的参数。 实例方法： isAlive(): 返回线程是否在运行。正在运行指启动后、终止前。 get/setName(name): 获取/设置线程名。 start(): 线程准备就绪，等待CPU调度 is/setDaemon(bool): 获取/设置是后台线程（默认前台线程（False））。（在start之前设置） 如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主线程和后台线程均停止 如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止 start(): 启动线程。 join([timeout]): 阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout（可选参数）。 123456789101112131415161718192021222324import threadingimport timedef action(arg): time.sleep(1) print('the arg is:%s\\r' %arg) #运行方法一：将要执行的方法作为参数传给Thread的构造方法for i in range(4): t =threading.Thread(target=action,args=(i,)) t.start()#运行方法二：从Thread继承，并重写run()class MyThread(threading.Thread): def __init__(self,arg): super().__init__()#注意：一定要显式的调用父类的初始化函数。 self.arg=arg def run(self):#定义每个线程要运行的函数===action() time.sleep(1) print('the arg is:%s\\r' % self.arg)for i in xrange(4): t = MyThread(i) t.start() 123456789101112thread_list = [] #线程存放列表for i in xrange(4): t =threading.Thread(target=action,args=(i,)) t.setDaemon(True) thread_list.append(t)for t in thread_list: t.start()for t in thread_list: t.join()# join()阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout，即使设置了setDeamon（True）主线程依然要等待子线程结束。 参考资料 [python–threading多线程总结]","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"Queue 队列模块相关","slug":"python/queue队列","date":"2019-03-25T00:13:50.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/queue队列/","link":"","permalink":"http://yoursite.com/wiki/python/queue队列/","excerpt":"","text":"heap 堆 stack 栈 queue 队列 堆的逻辑结构就是完全二叉树，并且二叉树中父节点的值小于等于该节点的所有子节点的值。 特征：heap[k] &lt;= heap[2k+1] 并且 heap[k] &lt;= heap[2k+2] （其中 k 为索引，从 0 开始计数） heapq 堆队列基本操作12345678910111213141516171819202122import heapq heap = []#向堆中插入元素，heapq会维护列表heap中的元素保持堆的性质 heapq.heappush(heap, item) #heapq把列表x转换成堆 O(n)复杂度heapq.heapify(x) # 最小堆heapq._heapify_max(x) # 最大堆#从可迭代的迭代器中返回最大的n个数，可以指定比较的key heapq.nlargest(n, iterable[, key]) #从可迭代的迭代器中返回最小的n个数，可以指定比较的key heapq.nsmallest(n, iterable[, key]) #从堆中删除元素，返回值是堆中最小或者最大的元素 heapq.heappop(heap)heapq.heappushpop(heap, item)：向 heap 中加入 item 元素，并返回 heap 中最小元素。heapq.heapreplace(heap,item): python3中heappushpop的更高效版。 原理使用的比较函数：lt, gt, cmp 内置数据类型和自定义类型，默认使用 lt （小于比较函数）进行比较 元组类型默认使用 cmp 比较 （先比较第1列，相同再比较第2列，以此类推……） 代码示范12345678import heapqh = []# 默认是最小堆heapq.heappush(h, (5, 'write code'))heapq.heappush(h, (7, 'release product'))heapq.heappush(h, (1, 'write spec'))heapq.heappush(h, (3, 'create tests'))min_item = heapq.heappop(h) # (1, 'write spec') PriorityQueue 优先队列 queue库是线程安全的 1234567891011121314151617181920#向队列中添加元素Queue.put(item[, block[, timeout]])#从队列中获取元素Queue.get([block[, timeout]])#队列判空Queue.empty()#队列大小Queue.qsize()try: import Queue as Q #python version &lt; 3.0except ImportError: import queue as Q #python3.*q = Q.PriorityQueue()q.put(19)q.put(1)q.put(5)while not q.empty(): print(q.get()) 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"python基本数据类型","slug":"python/python基本数据类型","date":"2019-03-21T06:35:53.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/python基本数据类型/","link":"","permalink":"http://yoursite.com/wiki/python/python基本数据类型/","excerpt":"","text":"时间复杂度注释n代表容器中元素的数量，k代表参数的值，或者参数的数量。 [注1] =这些业务依赖于“摊销最坏情况”的“Amortized摊销”部分。 根据容器的历史，个别动作可能需要很长时间。 [注2] =对于这些操作，最坏情况n是容器达到的最大尺寸，而不仅仅是当前尺寸。 例如，如果将N个对象添加到字典中，则删除N-1，仍然会为N个对象（至少）调整字典的大小，直到进行另一次插入为止。 list 列表是以数组（Array）实现的。最大的开销发生在超过当前分配大小的增长，这种情况下所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动。如果你需要在一个队列的两端进行增删的操作，应当使用collections.deque（双向队列） 操作 平均情况 最坏情况 复制 O(n) O(n) append[注1] O(1) O(1) 插入 insert O(n) O(n) 取元素 O(1) O(1) 更改元素 O(1) O(1) 删除元素 O(n) O(n) 遍历 O(n) O(n) 取切片 O(k) O(k) 删除切片 O(n) O(n) 更改切片 O(k+n) O(k+n) extend[注1] O(k) O(k) 排序 O(n log n) O(n log n) 列表乘法 O(nk) O(nk) x in s O(n) min(s), max(s) O(n) 获取长度 O(1) O(1) 双向队列（collections.deque） deque （double-ended queue，双向队列）是以双向链表的形式实现的 (Well, a list of arrays rather than objects, for greater efficiency)。双向队列的两端都是可达的，但从查找队列中间的元素较为缓慢，增删元素就更慢了。 操作 平均情况 最坏情况 复制 O(n) O(n) append O(1) O(1) appendleft O(1) O(1) pop O(1) O(1) popleft O(1) O(1) extend O(k) O(k) extendleft O(k) O(k) rotate O(k) O(k) remove O(n) O(n) 字典（dict） 下列字典的平均情况基于以下假设: 1 对象的散列函数足够撸棒（robust），不会发生冲突。2 字典的键是从所有可能的键的集合中随机选择的。 小窍门：只使用字符串作为字典的键。这么做虽然不会影响算法的时间复杂度，但会对常数项产生显著的影响，这决定了你的一段程序能多快跑完。 操作 平均情况 最坏情况 复制[注2] O(n) O(n) 取元素 O(1) O(n) 更改元素[注1] O(1) O(n) 删除元素 O(1) O(n) 遍历[注2] O(n) O(n) dict.setdefault(key, default=None)返回dict[key] 。如果没有key，则设置dict[key]=default并返回dict[key] 集合（set） 未列出的操作可参考 dict —— 二者的实现非常相似。 操作 平均情况 最坏情况 x in s O(1) O(n) 并集 s\\ t O(len(s)+len(t)) 交集 s&amp;t O(min(len(s), len(t)) O(len(s) * len(t)) 差集 s-t O(len(s)) s.difference_update(t) O(len(t)) 对称差集 s^t O(len(s)) O(len(s) * len(t)) s.symmetric_difference_update(t) O(len(t)) O(len(t) * len(s)) 由源码得知，求差集（s-t，或s.difference(t)）运算与更新为差集（s.difference_uptate(t)）运算的时间复杂度并不相同！前者是将在s中，但不在t中的元素添加到新的集合中，因此时间复杂度为O(len(s))；后者是将在t中的元素从s中移除，因此时间复杂度为O(len(t))。因此，使用时请留心，根据两个集合的大小以及是否需要新集合来选择合适的方法。 集合的s-t运算中，并不要求t也一定是集合。只要t是可遍历的对象即可。 参考资料Python内置方法的时间复杂度","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"配置vscode","slug":"编程基础/安装与配置/set-vscode","date":"2019-03-20T05:59:18.000Z","updated":"2019-04-12T07:16:51.728Z","comments":true,"path":"wiki/编程基础/安装与配置/set-vscode/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/set-vscode/","excerpt":"","text":"配置快捷键12向下复制一行---改成Ctrl+Deditor.action.copyLinesDownAction 插件 插件名 说明 Project Manager 项目管理 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"双指针找环","slug":"编程基础/leetcode/141. Linked_List_Cycle","date":"2019-03-19T14:08:18.000Z","updated":"2019-03-25T00:13:36.116Z","comments":true,"path":"wiki/编程基础/leetcode/141. Linked_List_Cycle/","link":"","permalink":"http://yoursite.com/wiki/编程基础/leetcode/141. Linked_List_Cycle/","excerpt":"","text":"题目https://leetcode.com/problems/linked-list-cycle/ 141.给一个链表的头节点,判断链表是否有环 解法1: 用set判断重复优点: 逻辑直观, 容易理解 比双指针更快 缺点: 空间占用比双指针更多 解法2: 双指针 用两个指针指向head 进行循环: 每次慢指针下移一次,快指针下移两次 如果快指针指向结尾则无循环,如果两个指针指向同一个节点则有循环","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"leetcode","slug":"编程基础/leetcode","permalink":"http://yoursite.com/categories/编程基础/leetcode/"}],"tags":[]},{"title":"使用docker","slug":"编程基础/软件使用备忘/use-docker","date":"2019-03-19T06:49:42.000Z","updated":"2019-06-14T08:15:48.128Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-docker/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-docker/","excerpt":"","text":"配置### debug: 直接运行命令会报错, 进入bash再执行可用现象: docker的command=apachectl -D FOREGROUND执行失败 docker的command=bash, 在bash手工执行命令可成功 原因: 电脑性能差, apachectl依赖程序未全部启动, 此时执行命令所以报错. 解决方法: 把command命令放在command.sh 中, 在最开始执行sleep 5 等待5秒. 然后把command.sh映射到容器内, command=bash command.sh 服务设置刚安装完成后，需要重启机器，才能启动服务 1234567# Ubuntusudo service docker start # 启动服务# manjarosudo systemctl start docker # 启动服务sudo systemctl status docker # 查看服务状态systemctl enable docker # 开机启动 设置信任本地仓库12345678910### 方法1 (如果不行可以尝试方法2)# 1. 在/etc/default/docker添加：-- insecure-registry 127.0.0.1:5000-- insecure-registry 192.168.31.103:5000# 2. 再重启docker 服务### 方法2# 1. 创建文件/etc/docker/daemon.json&#123; \"insecure-registries\":[\"192.168.163.131:5000\"]&#125;# 2. 再重启docker 服务 容器-常用命令123456789101112# 查看容器列表 ## -a 查看全部，否则查看运行中的docker ps# 删除容器 -f强制删除docker rm -f xxx# 实时查看容器占用的CPU和内存资源docker stats# 从容器生成镜像docker commit -m \"change somth\" -a \"somebody info\" container_id(docker ps -a获取id) 新镜像名字 容器自启动设置12docker run --restart=on-failure:10 xxxdocker run --restart=always xxx no 容器退出时不要自动重启。这个是默认值。 on-failure[:max-retries] 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数。在每次重启容器之前，重启延迟比上次增加一倍，从100毫秒开始，来防止影响服务器。这意味着daemon将等待100ms,然后200ms，直到超过on-failure限制，或执行docker stop或docker rm -f 。如果容器重启成功[容器启动后并运行至少10秒]，然后delay重置为默认的100ms。ms, 400, 800, 1600等等，直到超过on-failure限制，或执行docker stop或docker rm -f always 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启，不管容器当时的状态如何。(和unless-stopped 参数值效果一样) 镜像-常用命令123456789101112# 查看镜像列表docker images# 导出镜像的压缩文件（可以压缩多个镜像，例如xxx和yyy）docker save xxx:tag yyy:tag2 | gzip &gt; img.tar.gz # 镜像重命名docker tag xxx:tag xxx2:tag2# 删除镜像 ## -f强制删除docker rmi -f xxx:tag DockerFile123# 使用dockerfile生成镜像 -t添加标签名称(可以多个) docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest . 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"es-搜索操作","slug":"人工智能/搜索引擎/es-search","date":"2019-03-17T01:25:03.000Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/搜索引擎/es-search/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/es-search/","excerpt":"","text":"搜索备忘一原生的url接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# 搜索位置(url)/_search # 在所有的索引中搜索所有的类型/gb/_search # 在 gb 索引中搜索所有的类型/gb,us/_search # 在 gb 和 us 索引中搜索所有的文档/g*,u*/_search # 在任何以 g 或者 u 开头的索引中搜索所有的类型/gb/user/_search # 在 gb 索引中搜索 user 类型/gb,us/user,tweet/_search # 在 gb 和 us 索引中搜索 user 和 tweet 类型/_all/user,tweet/_search # 在所有的索引中搜索 user 和 tweet 类型# 分页(url)POST /_search # 默认size=10, from=0 从0返回POST /_search?size=5 # 第二页POST /_search?size=5&amp;from=5POST /_search?size=5&amp;from=10# term 精确查找,不计算相关度.&#123; \"term\" : &#123; \"price\" : 20 &#125;&#125;# 用constant_score 把term包装成filterPOST /my_store/products/_search&#123; \"query\" : &#123; \"constant_score\" : &#123; \"filter\" : &#123; \"term\" : &#123; \"productID\" : \"XHDK-A-1293-#fJ3\" &#125; &#125; &#125; &#125;&#125;# range 过滤器(filter): age &gt; 30# 过滤器执行速度非常快，不会计算相关度. 精确的筛选.POST /megacorp/employee/_search&#123; \"query\" : &#123; \"bool\": &#123; \"must\": &#123; \"match\" : &#123;\"last_name\" : \"smith\" &#125; &#125;, \"filter\": &#123; \"range\" : &#123; \"age\" : &#123; \"gt\" : 30 &#125; &#125; &#125; &#125; &#125;&#125;# 全文搜索: 返回相关性排序的结果． 如果有rock没有climbing也可能会返回结果.POST /megacorp/employee/_search&#123; \"query\" : &#123; \"match\" : &#123; \"about\" : \"rock climbing\" &#125; &#125;&#125;&#123; \"query\": &#123; \"match_phrase\": &#123; \"content\" : &#123; \"query\" : \"我的宝马多少马力\", \"slop\" : 1 &#125; &#125; &#125;&#125;# 实际上下面的query才能正确返回结果，搜索的是content这个字段里包含对应文本的文档# 精确匹配一系列单词或者短语POST /megacorp/employee/_search&#123; \"query\" : &#123; \"match_phrase\" : &#123; \"about\" : \"rock climbing\" &#125; &#125;&#125;# 高亮搜索POST /megacorp/employee/_search&#123; \"query\" : &#123; \"match_phrase\" : &#123; \"about\" : \"rock climbing\" &#125; &#125;, \"highlight\": &#123; \"fields\" : &#123; \"about\" : &#123;&#125; &#125; &#125;&#125;# 返回:&#123; ... \"hits\": &#123; \"total\": 1, \"max_score\": 0.23013961, \"hits\": [ &#123; ... \"_score\": 0.23013961, \"_source\": &#123; \"first_name\": \"John\", \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] &#125;, \"highlight\": &#123; \"about\": [ \"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;\" ] &#125; &#125; ] &#125;&#125;# 聚合（aggregations）: 统计某些标签的数量(是在搜索结果中进行统计,可以结合其他query)POST /megacorp/employee/_search&#123; \"aggs\": &#123; \"all_interests\": &#123; \"terms\": &#123; \"field\": \"interests\" &#125; &#125; &#125;&#125; 搜索备忘二http://www.cnblogs.com/yjf512/p/4897294.html 12345678910111213组合式搜索&#123; \"query\": &#123; &#123; \"bool\": &#123; \"must\": &#123; \"match\": &#123; \"tweet\": \"elasticsearch\" &#125;&#125;, \"must_not\": &#123; \"match\": &#123; \"name\": \"mary\" &#125;&#125;, \"should\": &#123; \"match\": &#123; \"tweet\": \"full text\" &#125;&#125;, # 这些match可以是数组 \"filter\": &#123; \"range\": &#123; \"age\" : &#123; \"gt\" : 30 &#125;&#125; &#125; &#125; &#125; &#125; &#125; elasticsearch 查询（match和term）es中的查询请求有两种方式，一种是简易版的查询，另外一种是使用JSON完整的请求体，叫做结构化查询（DSL）。由于DSL查询更为直观也更为简易，所以大都使用这种方式。DSL查询是POST过去一个json，由于post的请求是json格式的，所以存在很多灵活性，也有很多形式。这里有一个地方注意的是官方文档里面给的例子的json结构只是一部分，并不是可以直接黏贴复制进去使用的。一般要在外面加个query为key的机构。 match最简单的一个match例子： 查询和”我的宝马多少马力”这个查询语句匹配的文档。 123456789&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot; : &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot; &#125; &#125; &#125;&#125; 上面的查询匹配就会进行分词，比如”宝马多少马力”会被分词为”宝马 多少 马力”, 所有有关”宝马 多少 马力”, 那么所有包含这三个词中的一个或多个的文档就会被搜索出来。并且根据lucene的评分机制(TF/IDF)来进行评分。 match_phrase比如上面一个例子，一个文档”我的保时捷马力不错”也会被搜索出来，那么想要精确匹配所有同时包含”宝马 多少 马力”的文档怎么做？就要使用 match_phrase 了 123456789&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;content&quot; : &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot; &#125; &#125; &#125;&#125; 完全匹配可能比较严，我们会希望有个可调节因子，少匹配一个也满足，那就需要使用到slop。 12345678910&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;content&quot; : &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot;, &quot;slop&quot; : 1 &#125; &#125; &#125;&#125; multi_match如果我们希望两个字段进行匹配，其中一个字段有这个文档就满足的话，使用multi_match 12345678&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot;, &quot;fields&quot; : [&quot;title&quot;, &quot;content&quot;] &#125; &#125;&#125; 但是multi_match就涉及到匹配评分的问题了。 我们希望完全匹配的文档占的评分比较高，则需要使用best_fields12345678910111213&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;我的宝马发动机多少&quot;, &quot;type&quot;: &quot;best_fields&quot;, &quot;fields&quot;: [ &quot;tag&quot;, &quot;content&quot; ], &quot;tie_breaker&quot;: 0.3 &#125; &#125;&#125; 意思就是完全匹配”宝马 发动机”的文档评分会比较靠前，如果只匹配宝马的文档评分乘以0.3的系数 我们希望越多字段匹配的文档评分越高，就要使用most_fields123456789101112&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;我的宝马发动机多少&quot;, &quot;type&quot;: &quot;most_fields&quot;, &quot;fields&quot;: [ &quot;tag&quot;, &quot;content&quot; ] &#125; &#125;&#125; 我们会希望这个词条的分词词汇是分配到不同字段中的，那么就使用cross_fields123456789101112&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;我的宝马发动机多少&quot;, &quot;type&quot;: &quot;cross_fields&quot;, &quot;fields&quot;: [ &quot;tag&quot;, &quot;content&quot; ] &#125; &#125;&#125; termterm是代表完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇 1234567&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;content&quot;: &quot;汽车保养&quot; &#125; &#125;&#125; 查出的所有文档都包含”汽车保养”这个词组的词汇。 使用term要确定的是这个字段是否“被分析”(analyzed)，默认的字符串是被分析的。 拿官网上的例子举例： mapping是这样的： 12345678910111213141516171819202122PUT my_index&#123; &quot;mappings&quot;: &#123; &quot;my_type&quot;: &#123; &quot;properties&quot;: &#123; &quot;full_text&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;exact_value&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;index&quot;: &quot;not_analyzed&quot; &#125; &#125; &#125; &#125;&#125;PUT my_index/my_type/1&#123; &quot;full_text&quot;: &quot;Quick Foxes!&quot;, &quot;exact_value&quot;: &quot;Quick Foxes!&quot; &#125; 其中的full_text是被分析过的，所以full_text的索引中存的就是[quick, foxes]，而extra_value中存的是[Quick Foxes!]。 那下面的几个请求： 12345678GET my_index/my_type/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;exact_value&quot;: &quot;Quick Foxes!&quot; &#125; &#125;&#125; 请求的出数据，因为完全匹配 12345678GET my_index/my_type/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;full_text&quot;: &quot;Quick Foxes!&quot; &#125; &#125;&#125; 请求不出数据的，因为full_text分词后的结果中没有[Quick Foxes!]这个分词。 bool联合查询: must,should,must_not如果我们想要请求”content中带宝马，但是tag中不带宝马”这样类似的需求，就需要用到bool联合查询。联合查询就会使用到must,should,must_not三种关键词。 这三个可以这么理解 must: 文档必须完全匹配条件 should: should下面会带一个以上的条件，至少满足一个条件，这个文档就符合should must_not: 文档必须不匹配条件 比如上面那个需求： 12345678910111213141516&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;term&quot;: &#123; &quot;content&quot;: &quot;宝马&quot; &#125; &#125;, &quot;must_not&quot;: &#123; &quot;term&quot;: &#123; &quot;tags&quot;: &quot;宝马&quot; &#125; &#125; &#125; &#125;&#125; 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"},{"name":"elastic_search","slug":"elastic-search","permalink":"http://yoursite.com/tags/elastic-search/"},{"name":"search","slug":"search","permalink":"http://yoursite.com/tags/search/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"安装ES","slug":"人工智能/搜索引擎/install-es","date":"2019-03-17T01:21:17.000Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/搜索引擎/install-es/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/install-es/","excerpt":"","text":"安装ES-E Configure a setting-V, –version-d, –daemonize 守护进程，后台启动-p, –pidfile Creates a pid file in the specified path on start-q, –quiet Turns off standard output/error streams logging in console-s, –silent show minimal output-v, –verbose show verbose output 1234567891011121314151617181920# 启动(先-s 启动成功, 再用-d后台启动)elasticsearch/bin/elasticsearch -s # 配置文件elasticsearch/config/elasticsearch.yml# 检查状态curl -XGET '192.168.31.185:9200/_cat/health?v'# 测试是否启动成功curl 'http://192.168.31.185:9200/?pretty'# 查看所有索引！！curl -XGET '192.168.31.185:9200/_cat/indices?v'# 创建一个名字=ip_focus 的索引 pretty参数让返回结果更易读curl -XPUT '192.168.31.185:9200/ip_focus?pretty'# 删除一个索引curl -XDELETE '192.168.31.185:9200/customer?pretty'# 新建/修改一个文档（一行数据） _id=1 如果索引不存在，会自动新建索引=customer# 当我们没有明确指定ID的时候，我们需要使用POST方法代替PUT来发送请求PUT /customer/doc/1 &#123; \"name\": \"John Doe\" &#125; 启动时报错：elasticsearch max virtual memory areas vm.max_map_count [65530] is too low 12345sudo vim /etc/sysctl.conf # 在文件末尾加入vm.max_map_count=655360# 然后执行sudo sysctl -p 安装Kibana1234567891011121314151617去官网下载https://www.elastic.co/cn/downloads/kibana# 解压文件tar –zxvf kibana-5.5.2-linux-x86_64.tar.gz–C ./kibana/# 去config文件夹编辑kibana.yml#配置本机ip server.host: \"192.168.252.129\" #配置es集群url elasticsearch.url: \"http://192.168.252.129:9200\" # 启动程序 使用&amp;命令启动后，退出当前窗口时需要使用exit退出cd /bin./kibana &amp;访问：http://ip:port ip为kibana安装节点ip，端口默认为5061 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"},{"name":"elastic_search","slug":"elastic-search","permalink":"http://yoursite.com/tags/elastic-search/"},{"name":"Kibana","slug":"Kibana","permalink":"http://yoursite.com/tags/Kibana/"}]},{"title":"使用linux","slug":"编程基础/软件使用备忘/use-linux","date":"2019-03-17T01:05:41.000Z","updated":"2019-05-27T07:49:50.829Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-linux/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-linux/","excerpt":"","text":"tty终端1234# 进入tty终端Ctrl+Alt+F1 到F6 进入tty1～～tty6# 从tty回到桌面环境Ctrl+Alt+F7 Shell脚本Shell特殊变量 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 注意:$10 不能获取第十个参数，获取第十个参数需要${10} 常用shell脚本12345678910111213变量默认值#当变量a为null或为空字符串时则var=b var=$&#123;a:-b&#125; 脚本所在目录script_dir=$(cd \"`dirname $0`/.\"; pwd)关机命令sudo shutdownsudo shutdown -h 10 # 10分钟后关机sudo shutdown -h 14:15 # 希望在14:15关闭计算机sudo shutdown -c # 取消自动关机reboot # 重启电脑 常用shell函数 函数定义前可选加”function “ 函数末尾可以加：return 返回 如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值范围 0-255 123456789101112131415161718192021222324252627282930313233# 第一个echo函数demoFun()&#123; echo \"这是我的第一个 shell 函数!\"&#125;# 需要键盘输入的函数funWithReturn()&#123; echo \"这个函数会对输入的两个数字进行相加运算...\" echo \"输入第一个数字: \" read aNum echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum 和 $anotherNum !\" return $(($aNum+$anotherNum))&#125;funWithReturn# 函数返回值在调用该函数后通过 $? 来获得。echo \"输入的两个数字之和为 $? !\"# 分支if condition1then command1elif condition2 then command2else commandNfi if [ $a == $b ] # \"a 等于 b\"if [ $a -gt $b ] # \"a 大于 b\"if [ $a -lt $b ] #\"a 小于 b\" 免密码SSH登录远程服务器 创建自己的私钥和公钥对 1ssh-keygen -C “备注信息” -f ~/.ssh/私钥名称 #【密码输入空】 设置私钥对应的网站,在~/.ssh/config 文件中写入： 12345Host 远程服务器 空格链接多个地址 HostName： 目标主机地址 User：指定的登陆用户名 Port：指定的端口号(可选) IdentifyFile：指定的私钥地址(可选) 免密码SSH远程登录服务器 1ssh-copy-id -i ~/.ssh/私钥名称 远程帐号@远程服务器 把公钥文件复制到远程服务器，并输入密码后，下次就可以自动验证私钥文件 开机启动设置软件：Stacer 常用命令进程相关12345678# 查看占用内存CPUtop -p **进程ID# 查看所有进程 a=allps -ax# 查看占用socket端口的程序netstat -ap\\|grep **端口号** 文件相关1234567891011# 查看硬盘使用情况df -h# 删除大于100M的文件 或者100k -type=f表示文件类型find ./ -type f -size +100M | xargs rm -rf# 删除文件名末尾是mp3的文件find / -name \"*.mp3\" |xargs rm -rf# 也可以先去掉后面的删除命令看一遍结果，再删除（安全一些）# 查看当前文件夹递归1层大小/末尾可加文件夹du -h --max-depth=1 压缩文件 tar123456789101112查看压缩文件内容tar tvf xxx.tar# 切分并压缩文件 pre_xxx是切分文件的前缀tar cjf - file_or_dir |split -b 2000m - pre_xxx.##### 排除的目录（写file_or_dir后面的相对路径即可）tar cjf --exclude=排除的目录 file_or_dir |split -b 2000m - pre_xxx.# 合并然后解压文件 -C 输出到相对位置cat pre_xxx.* |tar xj -C ./../aim_dir/xxx_dir/ 权限相关12345# 给xxx账号设置root权限（sudo）sudo *user*mod-aG sudo xxx# 修改文件的所有者 -R表示递归目录下所有文件chown 用户名:用户组 文件名或目录名 -R 发送网络请求 curl1234567## post 方法# curl -i -X POST -H head文本 -d body_json_data# 示范如下:curl -i -X POST -H 'Content-type':'application/x-www-form-urlencoded; charset=UTF-8' -d &#123;\"json-body\":\"\"&#125; http://192.168.31.189:5858/handle/## get方法curl http://192.168.31.189:5858/ 远程挂载 说明 命令 参数 安装工具：sshfs sudo apt install sshfs 开始挂载 sshfs 用户名@host:远程目录 本地挂载点 -o -p端口 取消挂载 sudo umount -l 挂载点 取消挂载 fusermount -u 挂载点 rename perl版本程序 2个参数 参数一：’s/aaa/bbb/‘ 把aaa替换为bbb 参数二：用* 匹配1个或多个字符 rename ‘s/aaa/bbb/‘ *.json 一条命令kill某个进程1234567891011ps -aux|grep 50050|grep -v grep|cut -c 9-15|xargs kill -9# 截取输入行的第9个字符到第15个字符，而这正好是进程号PID。# xargs命令是用来把前面命令的输出结果（PID）作为“kill -9”命令的参数，并执行该命令# 用正则表达式来kill进程。而不用PIDpkill nginx# 用进程名字kill多个进程。killall nginx 1234# 新建用户sudo adduser 用户名# 增加root权限sudo usermod -aG sudo 用户名 sed-正则表达式 awk,sed都可以做字符串各种操作。 ^行的开头 $行的结尾 . 任意单个字符 * 匹配0-多次 + 匹配1次以上 ? 匹配0/1次 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"使用git","slug":"编程基础/软件使用备忘/use-git","date":"2019-03-17T01:05:30.000Z","updated":"2019-05-15T10:44:32.466Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-git/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-git/","excerpt":"","text":"gitlab使用设置保护分支(master分支不能推送) 默认的master分支是收保护的，不能直接push 进入setting—&gt;Repository—&gt;Protected Branches 设置保护分支 issue模板配置在代码文件夹中新建2个issue模板文件 12345678910111213141516171819202122.gitlab/issue_templates/bug.md 内容如下：#### 系统信息（代码版本等）#### 重现步骤#### 期望结果#### 报错信息.gitlab/issue_templates/feature.md 内容如下：#### 要解决什么问题#### 要实现什么样的功能#### 用户的应用场景是什么样的#### 注意事项（用户可能有哪些骚操作，等等）#### 对现有功能有什么影响#### 依赖什么模块 labels配置 kind（类型） kind/bug kind/新需求 priority（优先级） priority/紧急 priority/不紧急 size（工作量）：表示 issue 需要大约花费多少时间/精力，可以用来做简单的工作量评估参考。 size/0小 size/1中 size/2大 CRLF/LF/CR三种换行模式： 模式 操作系统 缩写 CRLF windows \\n\\r CR mac OSX \\r LR Linux \\n pycharm可以在状态栏显示换行符使用的模式，如下图： 点击 LF 可以切换文件的换行模式 git–AutoCRLF12345678#提交时转换为LF，检出时转换为CRLFgit config --global core.autocrlf true #windows推荐方式#提交时转换为LF，检出时不转换git config --global core.autocrlf input #提交检出均不转换git config --global core.autocrlf false #Linux/Mac推荐方式 SafeCRLF12345678#拒绝提交包含混合换行符的文件git config --global core.safecrlf true #推荐方式#允许提交包含混合换行符的文件git config --global core.safecrlf false #提交包含混合换行符的文件时给出警告git config --global core.safecrlf warn git命令行标签123456789101112131415161718192021标签分为带附注和不带附注的。我们尽量使用带附注的。# 本地新建一个tag 名称=V1.2git tag -a V1.2 -m 'xxxxx'# 查看本地taggit tag# 查看tag详细信息git tag show V1.2# 推送到远程仓库git push origin --tags# 如果发现有问题，可以删除标签（本地）git tag -d V1.2# 推送空的同名版本到远程仓库，等同于删除远程库里的版本git push origin :refs/tags/V1.2# 获取远程版本，精确拉取某一个版本的代码git fetch origin tag V1.2 在board中添加分栏Issues–&gt;Board–&gt;Add list –&gt;选择要监控的labels 本地分支和远程分支1234567891011121314# 查看当前跟踪关系git branch -vv# 克隆时自动将创建好的`master`分支追踪`origin/master`分支git clone 服务器地址# 建立本地分支 xxx, 追踪远程分支origin/yyygit checkout -b xxx origin/yyy# 将 xxx 分支追踪远程分支 origin/yyygit branch --set-upstream xxx origin/yyy# 设置当前分支跟踪远程分支 origin/yyyygit branch -u origin/yyyy 设置git默认使用的编辑器12提交是出现nano界面，可以退出后设置默认编辑器成VIMgit config --global core.editor \"vim\" 配置远程仓库的密钥 创建自己的私钥和公钥对 -C “备注信息” -f ~/.ssh/私钥名称 ``` 【密码输入空】12. 设置私钥对应的网站,在~/.ssh/config 文件中写入： Host deeplycurious.ai 多个远程仓库地址用空格分隔IdentityFile ~/.ssh/私钥名称 12345678910113. 上传公钥4. 在phabricator里个人--setting--SSH Public Keys-- SSH Key Actions -- Upload Public Key5. Name 随便取， Public Key 是你的公钥的文本内容### 强制修改分支位置```bash可以直接使用 -f 选项让分支指向另一个提交# 例如下面。将 master 分支强制指向 HEAD 的第 3 级父提交。（代码恢复到老版本）git branch -f master HEAD~3 删除git子模组/子模块123456789101112131415161718菜鸟流程:1. 把子模组文件夹剪切到项目外2. add/commit/push(删除对应文件夹)3. 然后把文件夹剪切回来4. add/commit/push(增加对应文件夹)官方流程:# 删除子模块目录及源码rm -rf 子模块目录 # 删除项目目录下.gitmodules文件中子模块相关条目vi .gitmodules # 删除配置项中子模块相关条目vi .git/config # 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可rm .git/module/* # 如果仍然报错，执行如下：git rm --cached 子模块名称 TODO: 学习 git hooks自动更新提交空文件夹 空的.gitignore文件可以作为占位符，使git只创建一个文件夹，里面是空的（一个空.ignore文件） 删除文件的git控制 如果已经加到版本控制中（push或add过）：用该命令去除控制（不删除本地文件） git rm -r –cached 文件路径 如果刚删除caehed，或未add或push过：直接设置 .gitignore 忽略即可。 .git/info/exclude 该文件和.ignore格式相同，但是不会被提交，不会影响他人的忽略名单。 忽略已加入控制的文件改动 git update-index –assume-unchanged 文件名 用户名和密码123456# 设置用户名和密码(--global全局配置,否则为本地配置)git config --global user.email \"you@example.com\"git config --global user.name \"Your Name\"# 查看用户名和密码设置命令,不写最后的文本值,即为查看 给本地代码添加远程git仓库1234567891011# 添加远程仓库 origin是git默认仓库名称git remote add origin 远程仓库地址# 重设远程仓库git remote set-url origin URL# 查看远程仓库的地址 git remote -v# 第一次推送到远程仓库（并把默认远程仓库设置为origin）git push -u origin master 修改commit注释12# 如果commit内容还未push:git commit --amend 可视化交互git学习，知识点如下 创建和切换分支1234567# 创建分支（当前分支不变）git branch newxxx# 切换当前分支到xxxgit checkout xxx# 创建并切换到newxxx分支git checkout -b newxxx rebase1234567# 当前在bugFix分支，命令会把bugFix节点的父节点指向master# C1--&gt;C2（master） 命令结果：C1--&gt;C2(master)--&gt;C3‘(bugFix*)# --&gt;C3（bugFix*） --&gt;C3git rebase master# 当前C2(master)--&gt;C3‘(bugFix*) 则指向同一个git rebase bugFix HEAD 123456789101112131415161718HEAD 是指git当前正在操作的节点指针HEAD 可以指向某个分支名，也可以指向某个节点名# 查看当前HEAD cat .git/HEAD# 查看HEAD指向的引用git symbolic-ref HEAD# 查看提交树的节点的哈希值git log# 切换HEAD指针（绝对值切换）git checkout 节点-哈希值/分支名# 切换HEAD指针（相对切换） # 使用 ^ 向上移动 1 个提交记录 git checkout master^ git checkout HEAD^ # 使用 ~&lt;num&gt; 向上移动多个提交记录，（不加数字则向上1个） git checkout master~3 修改分支位置123# -f 选项让分支指向另一个提交# 下面命令将 master 分支强制指向 HEAD 的第 3 级父提交。git branch -f master HEAD~3 恢复到merge之前123# ORIG_HEAD 是git在做危险操作时候给HEAD做的备份git reset --hard ORIG_HEAD# ORIG_HEAD 等价于 HEAD@&#123;1&#125; 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"操作系统重装记录","slug":"编程基础/安装与配置/system-record","date":"2019-03-17T00:56:59.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/安装与配置/system-record/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/system-record/","excerpt":"","text":"警告 应该备份.ssh文件夹, 重装后将消失 Ubuntu 重装记录 chrome插件 SwitchyOmega 有道词典Chrome划词插件 LingoCloud （彩云小译） smartUp Gesture （手势） Tampermonkey （油猴） 有道云笔记网页剪报 360浏览器 插件360屏幕截图 Adblock Super Proxy SwitchyOmega Tampermonkey 彩云小译 截图助手 有道云笔记网页剪报 有道划词翻译 油猴脚本导出文件（tampermonkey-backup-chrome-2019-03-13T01-41-21.545Z.zip） Omega备份文件 adblock备份文件 3、把ubuntu的设置记录下来 安装Tweaks(Ubuntu软件商店–GNOME Tweaks) https://extensions.gnome.org/ aifish f1 插件 Activities configurator 1.3 Scale Icon 0 Icon Padding ON Hide Text 6 Text Padding 100 Hot Corner Threhold 100 Panel Transparency 黑色 Panel Shadow Color 100 Transparency 0 Vertical Length 0 Spread Radius OFF Move Activities to the Right ON Enable Conflict Detection Clipboard indicator Places status indicator Drop down terminal（没怎么用过） 3、常用软件记录 typora pycharm vscode 插件 Beautify Better TOML TOML Language Support Docker Encode Decode Gitlens Image preview JavaScript (ES6) code snippets Mithril Emmet Prettier - Code formatter Project Manager Python Terminal Vetur wps 搜狗输入法 百度云（deepin） postman meld（文本对比） systemMonitor（系统监控器，进程、文件夹监控） virtuaBox（虚拟机） 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"配置vim","slug":"编程基础/安装与配置/set-vim","date":"2019-03-17T00:56:04.000Z","updated":"2019-04-08T01:15:48.071Z","comments":true,"path":"wiki/编程基础/安装与配置/set-vim/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/set-vim/","excerpt":"","text":"vim配置（linux/manjaro/ubuntu/deepin通用）1234567891011121314151617181920212223242526272829303132333435363738sudo pacman -S vim\":关闭与vi的兼容模式set nocompatible \":显示行号set number \":显示匹配的括号set showmatch \":距离顶部和底部3行set scrolloff=3 \":编码set encoding=utf-8 set fenc=utf-8 \"编码设定Encodingset fileencoding=utf-8set fileencodings=utf-8,gbk,utf-16,big5 set langmenu=zh_CN.UTF-8source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.UTF-8\"忽略大小写检索set ignorecase\":搜索高亮set hlsearch \"输入检索时动态变化set incsearch\":语法高亮syntax on \":命令显示历史set history=500\"开启插件和缩进filetype plugin indent on\":鼠标set autoreadset mouse=set mousehide bug: backspace退格键不能使用把 deleteleft 快捷键设置会 backspace 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"配置和使用 pycharm","slug":"python/pycharm","date":"2019-03-17T00:55:57.000Z","updated":"2019-07-18T02:09:32.920Z","comments":true,"path":"wiki/python/pycharm/","link":"","permalink":"http://yoursite.com/wiki/python/pycharm/","excerpt":"","text":"配置常用代码片段配置 配置路径 Setting—&gt;Editor—&gt;Live Templates—&gt;加号按钮 12345678910111213141516171819~nos # noinspection PyMethodMayBeStatic# ~errerror = '\\n'.join(traceback.format_exception(*sys.exc_info()))# ~pathpath = os.path.join(os.path.dirname(__file__), '')# ~rootdef root(*f, relative_root='../../../'): # relative_root 当前代码目录相对root的相对路径 for t in f: if t[:1] == '/': print('Warning: root()包含绝对路径 参数=&#123;&#125;'.format(f)) break code_dir = os.path.dirname(os.path.realpath(__file__)) long_path = os.path.join(code_dir, relative_root, *f) return long_path 快捷键配置Keymap—方案设置成NetBeans 名称 快捷键 说明 Reformat Ctrl+Alt+L 需设置 Code格式化代码 Move Line Up Alt+Up 需设置 当前行往上挪一行 Move Line Down Alt+Down 需设置 当前行往上挪一行 Optimize Imports Ctrl+Shift+I 优化导入代码 Ctrl+F12 跳转到方法（列表） Ctrl + F11 设置书签 SHIFT F11 显示所有书签 Go to Bookmark 1 Ctrl+Alt+1 需设置 跳转到 该书签 Next Bookmark Ctrl+Shift+. 跳转到下个书签 Previous Bookmark Ctrl+Shift+逗号 跳转到上个书签 Decrease Font Size Ctrl+Alt+减号 减小字体大小 Increase Font Size Ctrl+Alt+= 增加字体大小 常用快捷键 把展开代码块，设置成递归的： 设置》Keymap》Main menu 》Code》Folding 》Expand 删除快捷键 设置》Keymap》Main menu 》Code》Folding 》Expand Recursively 增加快捷键 Ctrl+= 快捷键 作用 Ctrl+Q 查看当前函数有什么参数 Ctrl+Alt+L 格式化代码 Ctrl+Shift+加号/减号 展开/折叠所有代码块 Ctrl + 加号/减号 展开/折叠代码块（当前位置的：函数，注释等） Ctrl + Alt + E Show Useage 跳转到上个光标所在位置​ 打开 View—toolbar 有左右箭头按钮。悬停可以查看快捷键 插件File—Setting—Plugins 数据库插件： ​ 搜索datebase ​ 安装 Database Navigator ​ 安装Mongo Plugin ​ Grep Console 控制台文本颜色 默认logger的stream是输出到sys.stderr, 这是pycharm会把文字设置成红色. 如果设置stream到sys.stdout, 字体颜色就正常了 ​ 显示界面和字体配置12345678界面的字体大小：Setting--&gt;Appearance&amp;Behavior--&gt;Appearance--&gt;Use custom font代码的字体大小：Setting--&gt;Editor--&gt;Font控制台的字体大小:Setting--&gt;Editor--&gt;Color Scheme--&gt;Console Font 常见BUGpycharm中所有代码无法自动提示处理方法解决方案：1）打开pycharm后必须等待indexing全部结束；2）检查file菜单里，确保节能模式“power save mode”不被勾选。 某个文件不能代码高亮原因: 自动识别成了text文件(误操作添加了文件类型) 解决方案: 设置—&gt;Editor—&gt;File Types—&gt;找到文件名删除(一般在Text里面) 关闭PEP8某些错误提醒点击有错误提示的代码, 前面的下拉菜单, 选择忽略该错误, 会自动添加到 PEP8的忽略错误列表中 关闭错误检测提醒PEP的错误提示，鼠标到错误提示行开头位置，出现灯泡，选择ignore like this setting—&gt;Editor—&gt;inspections 说明 英文 捕捉异常范围太广 Too broad exception clauses 方法可能是静态的 Method may be static 拼写检测 Typo 关闭某些错误提醒让PyCharm 在代码检查时人为跳过某些特定部分的代码检查，便于强迫症和优化代码提示 使用方法：在需要跳过代码校验的部分加上注释即可， 如图： 注释 对应检查说明 # noinspection PyMethodMayBeStatic This inspection detects any methods which may safely be made static. # noinspection PyAbstractClass This inspection detects when not all abstract properties/methods are defined in a subclass # noinspection PyArgumentList This inspection reports discrepancies between declared parameters and actual arguments, as well as incorrect arguments (e.g. duplicate named arguments) and incorrect argument order. Decorators are analyzed, too. # noinspection PyArgumentEqualDefault This inspection highlights situations, where argument passed to function is equal to default parameter value # noinspection PyAssignmentToLoopOrWithParameter Checks for cases when you rewrite loop variable with inner loop for i in xrange(5): for i in xrange(20, 25): print(“Inner”, i) print(“Outer”, i)It also warns you if variable declared in with statement is redeclared inside of statement body: with open(“file”) as f: f.read() with open(“file”) as f: # noinspection PyAsyncCall This inspection highlights coroutines which were called without await # noinspection PyAugmentAssignment This inspection highlights assignment that can be replaced with augmented assignment. # noinspection PyAttributeOutsideInit This inspection detects instance attribute definition outside init method # noinspection PyBroadException This inspection highlights too broad exception clauses such as no exception class specified, or specified as ‘Exception’. # noinspection PyByteLiteral This inspection detects characters &gt; 255 in byte literals. # noinspection PyCallByClass This inspection checks for calls of a method by class while passing an instance of a different class as self parameter: foo = Foo() Bar.baz(foo, *more)Sometimes this may be intentional and correct. But when unintentional, this leads to subtle bugs. # noinspection PyCallingNonCallable This inspection highlights attempts to call objects which are not callable, like, for example, tuples. # noinspection PyChainedComparisons This inspection highlights chained comparisons that can be simplified. # noinspection PyClassHasNoInit This inspection used when a class has no init method, neither its parent classes. # noinspection PyClassicStyleClass This inspection detects classic style classes usage. # noinspection PyComparisonWithNone This inspection highlights comparisons with None. That type of comparisons should always be done with ‘is’ or ‘is not’, never the equality operators. # noinspection PyCompatibility Enable this inspection if you need your code to be compatible with a range of Python versions (for example, if you’re building a library). The range of Python versions with which the code needs to be compatible can be specified in the inspection settings. # noinspection PyDataclass This inspection detects invalid definitions and usages of classes created with dataclasses or attr modules. # noinspection PyDecorator This inspection reports usages of @classmethod or @staticmethod decorators on functions outside of a class. # noinspection PyDefaultArgument This inspection detects when a mutable value as list or dictionary is detected in a default value for an argument. Default argument values are evaluated only once at function definition time, which means that modifying the default value of the argument will affect all subsequent calls of the function. # noinspection PyDeprecation This inspection highlights usages of Python functions, classes or methods which are marked as deprecated (which raise a DeprecationWarning or a PendingDeprecationWarning). # noinspection PyDictCreation This inspection detects situations when dictionary creation could be rewritten with dictionary literal. # noinspection PyDictDuplicateKeys This inspection highlights using the same value as dictionary key twice. # noinspection PyDocstringTypes This inspection highlights types in docstring which don’t match dynamically inferred types. # noinspection PyDunderSlots This inspection detects invalid definition of slots in a class. # noinspection PyExceptClausesOrder This inspection highlights situations when except clauses are not in the correct order (from the more specific to the more generic) or one exception class is caught twice. If you don’t fix the order, some exceptions may not be catched by the most specific handler. # noinspection PyExceptionInherit This inspection detects when a custom exception class is raised but doesn’t inherit from the builtin “Exception” class. # noinspection PyFromFutureImport This inspection detects ‘from future import’ statements which are used not in the beginning of a file. # noinspection PyGlobalUndefined This inspection is used when a variable is defined through the “global” statement but the variable is not defined in the module scope. # noinspection PyInconsistentIndentation This inspection reports inconsistent indentation in Python source files (for example, use of a mixture of tabs and spaces). # noinspection PyIncorrectDocstring This inspection detects mismatched parameters in a docstring. Please note that it doesn’t warn you of missing parameters, if none of them is mentioned in a docstring. # noinspection PyInitNewSignature This inspection checks mutual compatibility of new and init signatures. # noinspection PyInterpreter This inspection notifies you if the current project has no Python interpreter configured or an invalid Python interpreter. # noinspection PyListCreation This inspection detects situations when list creation could be rewritten with list literal. # noinspection PyMandatoryEncoding This inspection detects lack of encoding magic comment for file. # noinspection PyMethodFirstArgAssignment This inspection detects cases when first parameter, such as ‘self’ or ‘cls’, is reassigned in a method. In most cases imaginable, there’s no point in such reassignment, and it indicates an error. # noinspection PyMethodOverriding This inspection detects inconsistencies in overriding method signatures. # noinspection PyMethodParameters This inspection looks for methods that lack a first parameter (which is usually named self ). # noinspection PyMissingConstructor This inspection warns if call to super constructor in class is missed # noinspection PyMissingOrEmptyDocstring This inspection detects lack of docstring and an empty docstring. # noinspection PyMissingTypeHints This inspection detects lack of type hints for function declaration in one of the two formats: parameter annotations or a type comment # noinspection PyNamedTuple This inspection detects invalid definition of namedtuple. # noinspection PyNestedDecorators This inspection looks for certain decorators that don’t nest well. # noinspection PyNonAsciiChar This inspection detects file contains non-ASCII characters and doesn’t have an encoding declaration at the top. # noinspection PyNoneFunctionAssignment This inspection is similar to pylint inspection E1111. It highlights situations when an assignment is done on a function call but the inferred function doesn’t return anything. # noinspection PyOldStyleClasses This inspection highlights occurrences of new-style class features in old-style classes. # noinspection PyOverloads This inspection validates overloads in regular Python files. # noinspection PyPackageRequirements This inspection warns about imported or required, but not installed packages. # noinspection PyPep8 This inspection runs the pep8.py tool to check for violations of the PEP 8 coding style guide. # noinspection PyPep8Naming This inspection checks the PEP8 naming conventions. # noinspection PyPropertyAccess This inspection checks that properties are accessed correctly: read-only not set, write-only not read, non-deletable not deleted. # noinspection PyPropertyDefinition This inspection checks that arguments to property() and functions annotated with @property and friends look reasonably. # noinspection PyProtectedMember This inspection warns if a protected member is accessed outside the class, a descendant of the class where it’s defined or a module. # noinspection PyProtocol This inspection detects invalid definitions and usages of protocols introduced in PEP-544. # noinspection PyRedeclaration This inspection detects unconditional redeclarations of names without being used in between, like this: def x(): passx = 2It applies to function and class declarations, and top-level assignments. # noinspection PyRedundantParentheses This inspection highlights redundant parentheses in statements. # noinspection PyReturnFromInit This inspection reports occurrences of return statements with a return value inside init methods of classes. A constructor should not return any value. # noinspection PySetFunctionToLiteral This inspection detects call for function “set” which can be replaced with set literal. # noinspection PyShadowingBuiltins This inspection detects shadowing built-in names, such as ‘len’ or ‘list’. # noinspection PyShadowingNames This inspection detects shadowing names defined in outer scopes # noinspection PySimplifyBooleanCheck This inspection detects equality comparison with a boolean literal. # noinspection PySingleQuotedDocstring This inspection highlights docstrings not using triple double-quoted string format. # noinspection PyStatementEffect This inspection detects statements without any effect. # noinspection PyStringException This inspection detects when a string exception is raised. # noinspection PyStringFormat This inspection detects errors in string formatting operations. # noinspection PySuperArguments This inspection check that in any call to super(A, B), B either is an instance of A or a subclass of A. # noinspection PyTestParametrized Test function, decorated with @pytest.mark.parametrize, must have arguments to accept parameters from decorator # noinspection PyTrailingSemicolon This inspection detects trailing semicolons in statements. # noinspection PyTupleAssignmentBalance This inspection check that the number of expressions on right-hand side and targets on left-hand side are the same. # noinspection PyTupleItemAssignment This inspection detects assignments to tuple item. # noinspection PyTypeChecker This inspection detects type errors in function call expressions. Due to dynamic dispatch and duck typing, this is possible in a limited but useful number of cases. Types of function parameters can be specified in docstrings or in Python 3 function annotations. # noinspection PyTypeHints This inspection detects invalid usages of type hints. # noinspection PyUnboundLocalVariable This inspection warns about local variables referenced before assignment. # noinspection PyUnnecessaryBackslash This inspection highlights backslashes in places where line continuation is implicit (inside (), [], {}). # noinspection PyUnreachableCode This inspection detects code which can not be normally reached. # noinspection PyUnresolvedReferences This inspection detects names that should resolve but don’t. Due to dynamic dispatch and duck typing, this is possible in a limited but useful number of cases. Top-level and class-level items are supported better than instance items. # noinspection PyUnusedLocal This inspection highlights local variables,parameters or local functions unused in scope. 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"安装ubuntu","slug":"编程基础/安装与配置/install-ubuntu","date":"2019-03-17T00:55:46.000Z","updated":"2019-07-18T07:29:33.682Z","comments":true,"path":"wiki/编程基础/安装与配置/install-ubuntu/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/install-ubuntu/","excerpt":"","text":"零 安装kernel（修复界面卡顿问题）问题：4.18版本kernel的CPU核心显卡存在bug，会导致界面卡顿 解决：安装5.1版本kernel（不要安装最新的rc版本，稳定一些） 查看当前内核版本1234567891011# 查看当前内核版本uname -r&gt;&gt;&gt;4.18.0-20-generic# 搜索可用的内核apt-cache showpkg linux-headersapt-cache showpkg linux-image找到这两个命令里，版本号相同的最新版本# 示例：选择5.1.0版本sudo apt install linux-headers-5.1.0-050100-generic linux-image-unsigned-5.1.0-050100-generic --fix-missing 查看硬件12345# 查看内存 槽位sudo lshw -c Memory# 查看主板sudo dmidecode -t 2 一 安装系统安装thefuck1234sudo apt install thefuckthefuck -a f # 获取alias文本， 别名=f（可以自己设定）把alias文本设置到.bashrc内 安装tldr （太长不看，查看linux命令行帮助信息的工具）123sudo pip install tldr# 查看tar的帮助信息tldr tar 安装docker123456789sudo apt install docker.io# 创建文件 /etc/docker/daemon.json 增加私有镜像仓库&#123; \"insecure-registries\" : [\"192.168.31.103:5000\"]&#125;sudo systemctl restart docker 支持exfat文件格式12# 因为版权问题, 不能默认支持, 需要安装如下软件: sudo apt-get install exfat-utils 制作启动盘12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 查看硬盘列表sudo fdisk -l# 结果依次显示每个硬盘的信息，可知 /dev/sdb就是优盘Disk /dev/nvme0n1：232.9 GiB，250059350016 字节，488397168 个扇区Disk model: Samsung SSD 970 EVO 250GB 单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：gpt磁盘标识符：C56964F0-A438-4609-8521-BB80B61A498F设备 起点 末尾 扇区 大小 类型/dev/nvme0n1p1 109258752 488392031 379133280 180.8G Linux 文件系统/dev/nvme0n1p2 4196352 4401151 204800 100M Linux 文件系统/dev/nvme0n1p3 4401152 109258751 104857600 50G Linux 文件系统/dev/nvme0n1p4 2048 616447 614400 300M EFI 系统/dev/nvme0n1p5 616448 4196351 3579904 1.7G Linux swap分区表记录没有按磁盘顺序。Disk /dev/sda：1.8 TiB，2000398934016 字节，3907029168 个扇区Disk model: WDC WD20EZAZ-00G单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 4096 字节I/O 大小(最小/最佳)：4096 字节 / 4096 字节磁盘标签类型：gpt磁盘标识符：B6164008-B283-4767-831C-8784AB8854F7设备 起点 末尾 扇区 大小 类型/dev/sda1 2048 835022847 835020800 398.2G Linux 文件系统/dev/sda2 835022848 3907024031 3072001184 1.4T Linux 文件系统Disk /dev/sdb：14.4 GiB，15483273216 字节，30240768 个扇区Disk model: DataTraveler 2.0单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0x3fbeba85设备 启动 起点 末尾 扇区 大小 Id 类型/dev/sdb1 * 0 4774783 4774784 2.3G 0 空/dev/sdb2 4774784 4929791 155008 75.7M 1 FAT12# 创建启动盘： if=镜像文件 of=优盘盘符路径sudo dd if=/home/fish/下载/deepinamd64.iso of=/dev/sdb 二 安装软件12345678910111213141516171819202122232425262728293031323334353637383940414243卸载软件命令： apt-get remove softname1 softname2 softname3……卸载并清除配置命令： apt-get remove --purge softname1更新软件信息数据库命令： apt-get update进行系统升级命令： apt-get upgrade搜索软件包命令： apt-cache search softname1 softname2 softname3……安装deb软件包命令： dpkg -i xxx.deb删除软件包命令： dpkg -r xxx.deb连同配置文件一起删除命令： dpkg -P xxx.deb (purge)查看软件包信息命令： dpkg -info xxx.deb查看文件拷贝详情命令： dpkg -L xxx.deb查看系统中已安装软件包信息命令： dpkg -l重新配置软件包命令： dpkg-reconfigure xxx 科学上网1234567# 安裝ss的命令行工具sudo apt install -y shadowsockssslocal -c xxx.json# 浏览器安装科学插件# 找到chrome执行程序目录，加代理启动，安装 SwitchyOmega插件./chrome --proxy-server='socks5://127.0.0.1:1080' 开机启动：打开“启动应用程序”添加命令-clink1234567891011121314151617181920212223242526272829303132333435363738394041424344其中命令和配置文件需要全局路径### 设置开机自启动的内容```bash# 建立 /etc/systemd/system/rc-local.service 文件内容如下：_________________________________________________[Unit]Description=/etc/rc.local CompatibilityConditionPathExists=/etc/rc.local [Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0StandardOutput=ttyRemainAfterExit=yesSysVStartPriority=99 [Install]WantedBy=multi-user.target_________________________________________________# 创建启动命令脚步文件 /etc/rc.local——————————————————————————————————————————————————#!/bin/sh -eecho &quot;看到这行字，说明添加自启动脚本成功。&quot; &gt; /usr/local/test.logexit 0——————————————————————————————————————————————————# 添加权限sudo chmod +x /etc/rc.local# 开机启动服务sudo systemctl enable rc-local# 启动服务并检查状态sudo systemctl start rc-local.servicesudo systemctl status rc-local.service# 修改service配置文件后，重载sudo systemctl daemon-reload# 查看日志cat /usr/local/test.log 开启ssh服务 12345678sudo apt install openssh-serversudo systemctl restart sshd# 设置不允许root帐号登录 修改文件 /etc/ssh/sshd_config PermitRootLogin no# 重启sshd服务sudo systemctl restart sshdsudo systemctl enable sshd 安装git git-lfs12345678910# 安装gitsudo apt install git# 安装git-lfs ########### ubuntu## 1. 设置url源curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash## 2. 安装lfssudo apt-get install git-lfs## 3. 初始化git lfs install 安装google输入法(不好用)12sudo apt-get install fcitx-googlepinyin然后注销再登陆操作系统 安装搜狗输入法KDE界面很难配置输入法， 可以进入gnome界面安装好输入法，再重新进入KDE 1234567891011121314# 搜狗拼音依赖fcitxsudo apt-get install fcitx-bin fcitx-table1. 去搜狗拼音官网,下载linux版本安装文件(.deb)2. 双击打开界面安装3. 登出后登录操作系统！ 4. 右键点击顶栏的键盘图标，选择配置5. 添加搜狗输入法如果候选栏显示乱码、无法显示中文，可按如下方式处理：1. 如果是刚装完搜狗输入法,则输入命令:sudo apt-get install -f,进行依懒性检查,判断是否却是依赖项.2. 如果是之前一直可以输入中文的,突然无法输入,则不是依赖项的问题,此时输入命令:killall fcitx3.如果2仍不能解决问题,则删除配置文件,Ubuntu下搜狗的配置文件在~/.config下的3个文件夹里：SogouPY、SogouPY.users、sogou-qimpanel 删除这3个文件夹,然后重启搜狗即可. 选择需要的输入法： 点击Ubuntu右上角顶栏的小键盘图标中打开，配置，如下图 安装zsh 和 autojump12345678910111213141516# 如果是Ubuntu需要先安装（manjaro自带zsh）sudo apt install zshsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"重启操作系统后终端变成zsh如果要切换回去bashchsh -s /bin/bash# 安裝autojumpgit clone git://github.com/wting/autojump.gitcd autojump./install.py or ./uninstall.py手工把提示腳本添加到 ~/.zshrc# 登出操作系统，再登录，打开shell即会进入zsh 安装WPS去wps官网下载deb文件，双击后安装。 然后下载font文件：链接如下 国内地址 国外地址 1234567#a. 将得到文件复制到/usr/share/fontssudo cp * /usr/share/fonts#b. 执行以下命令,生成字体的索引信息sudo mkfontscalesudo mkfontdir#c. 更新字体缓存sudo fc-cache 安装node/npm1234567# 1. 安装默认版本sudo apt-get install npm# 2. 安装版本管理工具sudo npm install -g n# 3. 安装对应版本sudo n latest #最新版本sudo n stable #最新的稳定版本 安装ssh服务123456789101112131415161718192021222324sudo apt install openssh-serversudo systemctl start sshdsudo vim /etc/ssh/sshd_config # 关闭root用户登录PermitRootLogin nosudo systemctl restart sshdwangxiaoyu@dc5:~$ ssh xxxxx@192.168.31.68@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:yHxBrXIZ6upZaOPDf3PcaOO+aaEthNQiw4O4CCt7gSM.Please contact your system administrator.Add correct host key in /home/wangxiaoyu/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /home/wangxiaoyu/.ssh/known_hosts:14 remove with: ssh-keygen -f \"/home/usr1/.ssh/known_hosts\" -R 192.168.31.68 目标ssh服务器重装系统后，远程登录时会报错。使用报错信息里的remove with 后面的命令即可清除报错ssh-keygen -f \"/home/usr1/.ssh/known_hosts\" -R 192.168.31.68 安装postman123456789101112# 创建软链接sudo ln -s /home/fish3/soft/Postman/Postman /usr/bin/postman# 创建 /usr/share/applications/postman.desktop 内容如下:[Desktop Entry]Encoding=UTF-8Name=postmanExec=postmanIcon=/home/fish3/soft/Postman/app/resources/app/assets/icon.pngTerminal=falseType=ApplicationCategories=Development; 安装chrome12345678910111213sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -sudo apt updatesudo apt install google-chrome-stable# 离线安装包下载## 1. 点击链接 (手工添加的standalone是离线下载参数)https://www.google.cn/chrome/?standalone=1https://www.google.cn/chrome/?standalone=1&amp;platform=win64## 2. 点击接受并安装, 下载deb文件 安装deepin的百度云、截图和终端123456# 百度云 安装失败！https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu# 截图、深度终端在ubuntu软件上级搜索 dee 安装和挑选终端123sudo apt install xfce4-terminalterminator #gnomekonsole 配置Gnome界面123456sudo apt install chrome-gnome-shellsudo apt install gnome-tweak-tool打开Ubuntu软件商店安装：GNOME Tweakshttps://extensions.gnome.org/ 账号aifish f1使用火狐浏览器安装插件 使用chrome打开： 使用火狐打开： 点击安装插件 Click here to install browser extension 安装gnome插件User Themes Clipboard Indicator topbar剪贴板列表 Recent Items topbar最近文件夹 Places Status Indicator topbar文件夹收藏 Datetime Format topbar显示日期 配置格式：%b-%d %A %R 快捷键设置 快捷键 配置路径 说明 Super+E 启动器—主目录 文件管理器 Super+D 导航—隐藏所有正常窗口 回到桌面 Super+W 启动网页浏览器 设置开机时自动登录设置—详细信息—用户—自动登录 alias配置123alias get1='pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ 'alias get2='pip install -i http://mirrors.aliyun.com/pypi/simple/ 'alias get3='pip install -i https://pypi.douban.com/simple/ ' KDE界面安装1sudo apt install plasma-desktop 任务栏设置删除“程序启动器”， 添加“应用程序菜单”（有搜索框） 快捷键显示桌面默认是Ctrl+F12 改成Win+D 系统设置—&gt;快捷键—&gt;全局快捷键—&gt;Plasma—&gt;显示桌面 锁屏默认是Ctrl+Alt+L 改为Win+L 系统设置—&gt;快捷键—&gt;全局快捷键—&gt;ksmserver—&gt;锁定会话 开机自启动系统设置－－－＞工作空间－－－＞开机和关机－－－＞自动启动 （勾选：在终端中运行） 界面设置12345678# 关闭: 自动锁屏时间系统设置---&gt;工作空间---&gt;桌面行为---&gt;锁屏(快捷键)# 快捷键系统设置---&gt;工作空间---&gt;快捷键# 鼠标双击打开文件系统设置---&gt;硬件---&gt;输入设备---&gt;鼠标---&gt;双击打开# 锁屏壁纸系统设置---&gt;桌面行为---&gt;锁屏---&gt;外观---&gt;添加图片 bug: 没有无线网络选择图标12开机自启动增加:nm-applet 程序图标： bug: 无法打开wps表格文件12345# 写入文件: ~/.xprofileexport LC_ALL=zh_CN.UTF-8export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=\"@im=fcitx\" bug: 文件管理器里文件不能剪贴和复制nautilus –new-window 管理器可以剪贴 PCManFMC 管理器不能剪贴 所有设置—&gt;应用程序—&gt;默认程序—&gt;文件管理器—&gt;其他 xfce界面安装123sudo apt-get install xfce4 注销当前账号在输入密码界面，选择不同的界面系统 Xfce 触摸板启用“点击”|apt安装软件失败的处理方法12345678910111213141516171819# 触摸板启用\"点击\"# 1.首先，保证安装了synaptics驱动：sudo apt install xserver-xorg-input-synaptics-hwe-18.04 # 因为是ubuntu18.04所以添加后缀\"-hwe-18.04\"编辑 /usr/share/x11/xorg.conf.d/*synaptics-quirks.conf 增加# Disable generic Synaptics device, as we're using# \"DLL0704:01 06CB:76AE Touchpad\"# Having multiple touchpad devices running confuses syndaemonSection \"InputClass\"Identifier \"SynPS/2 Synaptics TouchPad\"MatchProduct \"SynPS/2 Synaptics TouchPad\"MatchIsTouchpad \"on\"MatchOS \"Linux\"MatchDevicePath \"/dev/input/event*\"Option \"Ignore\" \"on\"EndSection# 然后重启机器 https://www.dell.com/support/article/us/en/04/sln308258/precision-xps-ubuntu-general-touchpad-mouse-issue-fix?lang=en LXDE界面致命缺陷: 不能设置屏幕缩放, 对于高分辨率屏幕太不方便 安装 12345678LXDE有很多定制版，可任选# Lubuntu定制LXDE和vanilla LXDE（实际安装不成功，缺少依赖）# sudo apt-get install lubuntu-desktop# 香草LXDEsudo apt-get install lxde# 选择使用lightdm（见图） （gdm3 快捷键报错cannot configure keys remotely）如果设置错了也可以切换lightdmsudo dpkg-reconfigure lightdm # sudo dpkg-reconfigure gdm3 设置数字时钟格式：%b-%d %A %R设置快捷键：菜单—首选项—set hot key 功能 快捷键 说明 文件管理器 Win+E 默认有 nautilus –new-window 显示桌面 Win+D 默认有 锁屏 Win+L lxlock 打开浏览器 Win+W browser360 或 /usr/bin/google-chrome-stable 打开终端 Win+T lxterminal 或 deepin-terminal 或 gnome-terminal vscode Win+V code pycharm Win+P 打开pycharm–Tools–Create CMD line typora Win+M typora 截图 Ctrl+Shift+Print deepin-screenshot 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"安装manjaro","slug":"编程基础/安装与配置/install-manjaro","date":"2019-03-17T00:55:36.000Z","updated":"2019-07-12T00:40:32.255Z","comments":true,"path":"wiki/编程基础/安装与配置/install-manjaro/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/install-manjaro/","excerpt":"","text":"零. 个人使用体验只使用了一周，还不太熟悉。再尝试一周，如果没有什么特别的优点就换成deepin试试。 优点 硬件支持好 软件版本非常新（滚动更新） 缺点 缺少软件360浏览器 对中文支持较差，需要自己配置的内容较多 很多软件都是deepin的，例如微信和naivicat（那我为什么不直接用deepin呢） 一. 安装manjaro系统二. 中文相关配置注意事项如果代码更新一直等待状态可以尝试删除/var/lib/pacman/db.lck 配置镜像源 测试国内的镜像源1sudo pacman-mirrors -i -c China -m rank 设置 archlinuxcn 源1234567891011# 修改 /etc/pacman.conf 添加以下内容[archlinuxcn]SigLevel = Optional TrustedOnlyServer = http://repo.archlinuxcn.org/$arch## 添加cn源签名key(这步不做，会报签名错误）sudo pacman -S archlinuxcn-keyring# 完成后执行下面的命令使配置生效## 更新源列表sudo pacman-mirrors -g## 更新pacman数据库并全面更新系统sudo pacman -Syyu #（必须先更新系统，不然无法安装输入法） 使界面可以输入中文123456在~/.xprofile中添加export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx如果还是无法使用，可能需要安装fcitx-gtk2sudo pacman -S fcitx-gtk2 把系统界面设置为中文1234点击设置--Manjaro Settings Manager--本地化设置：添加 中国-中文，然后在语言包中点击安装软件包在~/.xprofile中添加export LC_ALL=\"zh_CN.UTF-8\"export LANG=zh_CN.UTF-8 三. 安装软件和系统配置安装yay1234# 1. 下载代码git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si 安装git12sudo pacman -S gitsudo pacman -S git-lfs 安装 wps12sudo pacman -S wps-officesudo pacman -S ttf-wps-fonts 安装 typora1234567891011121314## 下载二进制文件（x64） 解压https://www.typora.io/#linux## 创建程序的软链接sudo ln -s /home/fish/soft/Typora-linux-x64/Typora /usr/bin/typora## 编辑/usr/share/applications/typora.desktop 文件[Desktop Entry]Version=1.0Terminal=falseIcon=/home/aifish2/soft/typora/Typora-linux-x64/resources/app/asserts/icon/icon_256x256.pngType=ApplicationCategories=Office;Exec=/usr/bin/typora %UName=TyporaComment=MarkDown Editor 安装node/npm1234sudo pacman -S nvm nvm install --latest-npm然后把/home/fish/.nvm/versions/node/v11.12.0/bin添加到系统路径 安装jdk123456sudo pacman -S jdk8# 配置环境export JAVA_HOME=/usr/lib/jvm/defaultexport JRE_HOME=$&#123;JAVA_HOEM&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib 命令简单安装： vscode/ vim/ 微信/ shadownsocks/ 网易云音乐/ qq/ chrome/docker12345678sudo pacman -S codesudo pacman -S electronic-wechat （网页版不能复制粘帖图片）sudo pacman -S shadownsocks-qt5sudo pacman -S vimsudo pacman -S netease-cloud-music # 网易云音乐sudo pacman -S deepin.com.qq.office # 可以先搜索qq 看看版本sudo pacman -S google-chromesudo pacman -S docker 安装下载工具Gwget12打开系统工具：添加/删除软件搜索工具后下载 百度云下载1234567打开系统工具：添加/删除软件：安装baidupcs-go-git说明：https://github.com/iikira/BaiduPCS-Go# 进入命令交互工具baidupcs# 帮助help 安装截图工具123sudo pacman -S deepin-screenshot添加快捷键： deepin-screenshot 安装zsh autojump1234567# zshsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"# autojump（zsh设置ubuntu通用）sudo pacman -S autojump再在~/.zshrc中添加: plugins=(git autojump) 安装googlepinyin谷歌拼音123456sudo pacman -S fcitx-im fcitx-configtool fcitx-googlepinyinsudo vim ~/.xprofile 输入下面命令：exportGTK_IM_MODULE=fcitxexportQT_IM_MODULE=fcitxexportXMODIFIERS=\"@im=fcitx\" 安装搜狗拼音12345678910# 前置：设置中国软件源sudo pacman -S fcitx-im #默认全部安装sudo pacman -S fcitx-configtoolsudo pacman -S fcitx-sogoupinyin在~/.xprofile添加如下内容：export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 关闭ssh远程root登录1234# 设置不允许root帐号登录 修改文件 /etc/ssh/sshd_config PermitRootLogin no# 重启sshd服务sudo systemctl restart sshd 安装pycharm（ubuntu通用）12341.下载并解压pycharm.tar文件2.进入bin文件夹3.执行./pycharm.sh4.打开pycharm，在菜单栏选择tool---&gt;添加桌面快捷方式 时间显示设置操作：右键点击任务栏右下角的时间，选择属性：tips配置：%m-%d %j/365 第%V周时钟配置：周%u %H:%M ### 切换deepin桌面12# 安装桌面，然后重启电脑，选择桌面sudo pacman -S deepin deepin-extra lightdm 参考arch-wiki chrome安装插件 去官网下载插件文件 xxx.crx 去http://crxextractor.com/ 网站上传crx文件，获得zip文件 解压zip文件获得一个文件夹 打开chrome，打开开发者模式，加载已解压的扩展程序，选中解压文件夹，安装即可 四. 常用快捷键Ctrl+Alt+D 回到桌面（在设置界面里看不见这个快捷键，但是超级方便） Ctrl+Alt+F exo-open –launch FileManager 打开文件管理器 我改成了 Super ECtrl+Alt+M xfce4-taskmanager 资源监控器Ctrl+Alt+Delete xflock4 锁屏并黑屏Ctrl+Alt+X xkill 通过鼠标关闭某个程序新增： Ctrl+Alt+Q xfce4-terminal 终端Ctrl+H 文件管理器，显示隐藏文件 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"py2_and_py3","slug":"python/py2和py3","date":"2019-03-17T00:39:15.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/py2和py3/","link":"","permalink":"http://yoursite.com/wiki/python/py2和py3/","excerpt":"","text":"感受: 实际上还是不好用～～～能用3就用3～～～_future__python3出来的时候，python的设计者们当然也考虑过代码之间的兼容问题。许多为为兼容性设计的功能可以通过future这个包来导入。例如： 123456789101112# 使用python3的print函数，禁用python2的print语句。from __future__ import print_function# 导入该特征，代码中的文本变量默认是Unicode（如果不导入python2的文本变量默认是str）# python2 str.decode('utf8') --&gt; Unicodefrom __future__ import unicode_literals# 参见PEP 328 -- Imports: Multi-Line and Absolute/Relativefrom __future__ import absolute_import# 像python3一样，int除以int得float，而不像Python2那样是整除from __future__ import division six 字符串类型 文本 字节 python2 unicode str python3 str bytes six six.text_type six.binary_type 1234567891011# python2if isinstance(xxx, unicode): pass # 兼容python2和python3import sixif isinstance(xxx, six.text_type): pass## 使用input代替raw_inputfrom six.moves import input 判断版本写不同的内容if sys.version&gt;’3’: pass 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"兼容性","slug":"兼容性","permalink":"http://yoursite.com/tags/兼容性/"},{"name":"python版本","slug":"python版本","permalink":"http://yoursite.com/tags/python版本/"}]},{"title":"decorator装饰器","slug":"python/decorator装饰器","date":"2019-03-17T00:38:37.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/decorator装饰器/","link":"","permalink":"http://yoursite.com/wiki/python/decorator装饰器/","excerpt":"","text":"最简单的模板是这样的1234567891011def outer(func): def inner(): print 'before' func() print 'after' # return r return inner@outerdef F1(): print 'test' 函数带多个参数，装饰器对应修改以适合多种情况12345678910def ftfunc(func): def timef(*s,**gs): print \"[%s] %s() called\" % (ctime(),func.__name__) return func(*s,**gs) return timef@ftfuncdef foo(*s,**gs): print(s) print(gs) 函数带多个参数，装饰器也带多个参数123456789101112def decrator(*dargs, **dkargs): def wrapper(func): def _wrapper(*args, **kargs): print \"decrator param:\", dargs, dkargs print \"function param:\", args, kargs return func(*args, **kargs) return _wrapper return wrapper@decrator(1, a=2)def foo(x, y=0): print \"foo\", x, y 函数带多个参数，装饰器能转换参数类型1234567891011121314def validate(**vkargs): def decorator(func): def wrapper(**kargs): for key in vkargs: # 根据vkargs中的参数的类型对kargs的参数进行类型转换 kargs[key] = vkargs[key](kargs[key]) return func(**kargs) return wrapper return decorator@validate(x=int, y=float, z=float)def move(x, y, z): print \"move %d (%0.2f, %0.2f)\"%(x, y, z) 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"decorator","slug":"decorator","permalink":"http://yoursite.com/tags/decorator/"},{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]},{"title":"elastic_search基础","slug":"人工智能/搜索引擎/elastic-search基础","date":"2019-03-05T02:39:39.000Z","updated":"2019-06-06T03:40:10.055Z","comments":true,"path":"wiki/人工智能/搜索引擎/elastic-search基础/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/elastic-search基础/","excerpt":"","text":"Document元数据（MetaData）元数据用于标注文档的相关信息： _index：文档所在的索引名_type：文档所在的类型名_id：文档的唯一id_uid：组合uid，由_type和_id组成（6.x中_type不再起作用，同_id一样）_source：文档的原始json数据，可以从这里获取每个字段的内容_all：整合所有字段内容到该字段，默认禁用 搜索结果超出1万条的报错如果数据量小于20万，那么简单方法是修改max_result_window 1234# PUT方法，$开头的是变量PUT $ip:$port/$index/_settingsbody = &#123; \"index\" : &#123; \"max_result_window\" : 200000&#125;&#125;' Mappings创建索引时，设定mappings1234567891011121314151617181920PUT $host:$port/$indexbody = &#123; \"settings\": &#123; \"number_of_shards\": 1, //分片节点数量 \"number_of_replicas\": 0, //复制节点数量 &#125;, \"mappings\": &#123; \"_doc\": &#123; \"properties\": &#123; \"txt\": &#123; \"type\": \"text\", \"analyzer\": \"ik_smart\" // ik-分词器 &#125; &#125; &#125; &#125;&#125;analyzer可选: \"standard\", \"ik_smart\", \"english\"如果body=&#123;&#125; 那么就使用ES的自动mappings 字段的数据类型： 简单类型：text, keyword, date, long, double, boolean or ip. json层级类型：object or nested. 专有类型：geo_point, geo_shape, or completion. ## 查看全局的信息查看ES版本1GET $host:$port/ 查看ES安装的插件列表1GET $host:$port/_cat/plugins # 返回的文本（不是json） 搜索操作搜索所有文档12345678# 某索引的某个类型的所有文档GET $host:$port/$index/$type/_search# 某索引的所有文档GET $host:$port/$index/_search# ES所有文档GET $host:$port/_search 搜索符合条件的文档 (并排序)12345678910111213# 某索引的某个类型的所有文档POST $host:$port/$index/$type/_searchbody = &#123; \"query\": query \"from\": 0, // 从0开始 \"size\": 20, // 取20个 \"sort\": [ // 排序 &#123;\"age\": &#123;\"order\": \"asc\"&#125;&#125; //asc升序 dsc降序 ] \"_source\" : [\"key1\", \"key2\"] // 返回信息包含的键&#125;query = &#123;\"match_all\": &#123;&#125;&#125; // 搜索全部 搜索参数12345GET /_search&#123; \"min_score\": 0.5, // 分数最小值, 查询结果必须有 _score 字段 \"query\" : query,&#125; 基础查询种类数值符合范围12345678910111213141516171819query = &#123; \"range\": &#123; \"字段名\": &#123; # 符合则score=1 否则=0 \"gte\": 20000, // gte是&gt;= gt是&gt; \"lte\": 30000, // lte是&lt;= lt是&lt; \"boost\": 1.5 // 分数权重 &#125; &#125; &#125;query = &#123; \"range\": &#123; \"字段名\": &#123; \"from\": 20000, \"to\": 30000, \"boost\": 1.5 // 分数权重 &#125; &#125;&#125; 词项匹配（不进行分词处理）12345678910111213141516171819202122query = &#123; \"term\": &#123; \"_id\": \"ZUd6zmoBr51spxZUlcFQ\", &#125;&#125;query = &#123; \"term\": &#123; \"_id\": &#123; \"value\": \"ZUd6zmoBr51spxZUlcFQ\", \"boost\": 2 &#125; &#125;&#125;# terms是筛选，输出分数=1，不管匹配了多少个词项# 如果希望有分数，则用 should 拼接 termquery = &#123; \"terms\": &#123; \"featrue\": [\"盗窃\", \"自首\"] //或的关系 &#125;&#125; 短语匹配（先分词，再查询分词结果和位置顺序都对的文档）1234567891011121314query = &#123; \"match\": &#123; \"txt\": \"关键词\" &#125;&#125;query = &#123; \"match\": &#123; \"txt\": &#123; \"query\":\"我是中国人\", \"boost\": 2.0 &#125; &#125;&#125; 前缀匹配1234567query = &#123; \"match_phase_prefix\": &#123; \"name\": &#123; \"query\": \"赵\" &#125; &#125;&#125; 复合查询nested查询（数组元素是对象，查询符合条件的对象）1234567891011121314151617query = &#123; \"nested\":&#123; \"path\": \"字段1\", \"query\": &#123; // 可以是任意query \"match\": &#123; \"字段1.字段2\": \"关键词\" //注意key需要有前置路径 &#125; &#125; &#125;&#125;# 文档结构是：&#123;\"字段1\": // nested对象 [ &#123;\"字段2\"： \"文本内容\"&#125; ] &#125; bool查询12345678910111213141516query = &#123; \"bool\" : &#123; \"must\" : [ # 与 各个查询的分数相加 &#123;\"term\": &#123;\"price\": 25&#125; &#125; // query ], \"should\" : [ # 或 各个查询的分数相加 &#123;\"term\": &#123;\"price\": 25&#125; &#125; // query ], \"must_not\" : [ # 非 &#123;\"term\": &#123;\"price\": 25&#125; &#125; // query ], \"filter\" : filter, \"minimum_should_match\" : 1, \"boost\" : 1.0, &#125;&#125; filter12345filter = &#123; \"exists\": &#123; # 存在字段 \"filed\": \"price\" &#125;&#125; boosting 查询（soft not)123456789# 不复合negative查询的文档的得分不变# 复合negative查询的文档的得分会乘以negative_boost&#123; \"boosting\":&#123; \"positive\": p_query, \"negative\": n_query, \"negative_boost\": 0.2 &#125;&#125; 排序功能说明 123456789101112131415161718192021222324252627# score_mode 对数组的数值进行融合后排序: # min最小值, max最大值, sum求和, avg平均值, median中位数# multiply相乘, firstPOST /_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"boost\": \"5\", \"functions\": [ &#123; \"filter\": &#123; \"match\": &#123; \"test\": \"bar\" &#125; &#125;, \"random_score\": &#123;&#125;, \"weight\": 23 &#125;, &#123; \"filter\": &#123; \"match\": &#123; \"test\": \"cat\" &#125; &#125;, \"weight\": 42 &#125; ], \"max_boost\": 42, //计算出分数的上限 \"score_mode\": \"max\", \"boost_mode\": \"multiply\", \"min_score\" : 42 //最小分数, 用于排除得分过低的文档 &#125; &#125;&#125; function_score衰减函数 越近越好 linear线性 、 exp指数 和 gauss高斯函数 它们可以操作数值、时间以及经纬度地理坐标点这样的字段。 12345678910origin原点* 或字段可能的最佳值，落在原点 `origin` 上的文档评分 `_score` 为满分 `1.0` scale衰减率，从原点origin下落时，评分 _score 改变的速度。（例如，每 £10 欧元或每 100 米）decay从原点 origin 衰减到 scale 所得的评分 _score ，默认值为 0.5 。offset以原点 origin 为中心点，为其设置一个非零的偏移量 offset 覆盖一个范围，而不只是单个原点。在范围 -offset &lt;= origin &lt;= +offset 内的所有评分 _score 都是 1.0 。 12345678910111213141516171819202122232425&#123; \"query\": &#123; \"function_score\": &#123; \"gauss\": &#123; \"date\": &#123; \"origin\": \"2013-09-17\", // 如果不定义原点，则使用当前时间。 \"scale\": \"10d\", \"offset\": \"5d\", \"decay\" : 0.5 &#125; &#125;, 'min_score': 0.1 // 筛选条件: 分数最小值 'boost': 3.0 &#125; &#125;&#125;\"gauss\": &#123; \"字段名\": &#123; // 字段必须是数字/日期/地理位置 \"origin\": \"11, 12\", \"scale\": \"2km\", \"offset\": \"0km\", \"decay\": 0.33, &#125;&#125; function-score-参考文档 数据查询数据删除数据123456789101112131415161718192021222324252627282930# es参考版本：elasticsearch：5.5# _delete_by_query会删除所有query语句匹配上的文档，用法如下：curl -X POST \"localhost:9200/twitter/_delete_by_query\" -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"match\": &#123; \"name\": \"测试删除\" &#125; &#125;&#125;# 其中twitter是索引名称# 因为internal版本控制不支持0为有效数字，所以版本号为0的文档不能删除，并且请求将会失败。# 删除多个索引(twitter,blog)的多个type(_docs,post)curl -X POST \"localhost:9200/twitter,blog/_docs,post/_delete_by_query\" -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125;# 出自上向下删除1000条数据curl -X POST \"localhost:9200/twitter/_delete_by_query?scroll_size=1000\" -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"term\": &#123; \"user\": \"kimchy\" &#125; &#125;&#125; 参考资料 Elasticsearch删除数据之_delete_by_query","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"},{"name":"elastic_search","slug":"elastic-search","permalink":"http://yoursite.com/tags/elastic-search/"},{"name":"elastic","slug":"elastic","permalink":"http://yoursite.com/tags/elastic/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yoursite.com/tags/elasticsearch/"}]},{"title":"hexo","slug":"编程基础/博客工具/hexo","date":"2019-02-28T08:49:08.000Z","updated":"2019-03-25T00:13:36.116Z","comments":true,"path":"wiki/编程基础/博客工具/hexo/","link":"","permalink":"http://yoursite.com/wiki/编程基础/博客工具/hexo/","excerpt":"","text":"安装hexo1sudo npm install hexo-cli -g 图片显示123456789101112# 配置资源文件夹# hexo n xxx 会生成同名文件夹,# hexo g 会把同名文件夹内图片打包生成静态文件_config.yml里的post_asset_folder，改成true# 安装插件npm install hexo-asset-image --save# 设置typora编辑器# 图片插入路径= ./$&#123;filename&#125;# 优先使用相对路径在typora编辑器内粘贴图片时会自动把图片存储到同名文件夹 主题配置hexo-theme-Wikitten Github地址 部署hexo123456789# 进入blog目录hexo init# 启动服务器hexo serverhexo server -p 8080 # -p 端口# 生成静态文件hexo generate | hexo g` 插件自动生存目录树 categorieshexo-auto-category 1234567891011# 安装npm install hexo-auto-category --save# 在站点根目录下的_config.yml添加：# 自动生成目录树categories (depth层级上限)auto_category: enable: true depth: # 使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 绑定域名1234A (Address) 记录是域名到ip的映射，即为ip起别名CNAME是域名别名到域名的映射，即为域名起别名。政策导致国内无法绑定到github~~ 参考资料 Hexo 的个人 Wiki 主题 - Wikitten hexo-theme-Wikitten github地址 hexo中文官方文档","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"博客工具","slug":"编程基础/博客工具","permalink":"http://yoursite.com/categories/编程基础/博客工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"wiki","slug":"wiki","permalink":"http://yoursite.com/tags/wiki/"}]},{"title":"mongo","slug":"人工智能/搜索引擎/mongo","date":"2019-02-28T08:41:56.000Z","updated":"2019-06-11T02:10:53.989Z","comments":true,"path":"wiki/人工智能/搜索引擎/mongo/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/mongo/","excerpt":"","text":"### 服务器服务器启用mongo集群1234567891011121314151617181920212223242526# 进入mongo客户端mongo# 以下操作是在mongo客户端命令行内：# 创建集群，集群名字=“rs0”rs.initiate( &#123; _id: \"rs0\", members: [ &#123; _id: 0, host: \"mongo-r0:27017\" &#125;, &#123; _id: 1, host: \"mongo-r1:27017\" &#125;, &#123; _id: 2, host: \"mongo-r2:27017\" &#125; ] &#125;)# 查看集群状态rs.conf()rs.status() mongo客户端使用登录/验证/切换数据库12# 进入mongo客户端mongo 客户端模块调用pymongo/motor调用mongo集群当 mongo 是集群时，客户端连接时需要设置好要连接的所有 mongo 节点。 12345import pymongo# uri里的“rs0”是集群名称，前面是每个节点的IP和端口uri = 'mongodb://mongo-r0:27017,mongo-r1:27017,mongo-r2:27017/?replicaSet=rs0'conn = pymongo.MongoClient()[i for i in conn.list_databases()] 注释：pymongo和motor连接时使用的uri字符串可以是相同的，因为motor实际是调用pymongo实现的。 集群–官方文档 参考资料 官方文档","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"mongo","slug":"mongo","permalink":"http://yoursite.com/tags/mongo/"}]},{"title":"markdown说明","slug":"编程基础/博客工具/markdown说明","date":"2019-02-27T07:03:45.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/博客工具/markdown说明/","link":"","permalink":"http://yoursite.com/wiki/编程基础/博客工具/markdown说明/","excerpt":"","text":"$x^p_ {ij}$ 其中i表示第i个标签 $x^p_ {ij}$ 上标$^2$ 下标$_ 2$","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"博客工具","slug":"编程基础/博客工具","permalink":"http://yoursite.com/categories/编程基础/博客工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"基础库：os/sys/dis","slug":"python/基础库","date":"2019-02-26T07:00:45.000Z","updated":"2019-07-12T01:31:58.004Z","comments":true,"path":"wiki/python/基础库/","link":"","permalink":"http://yoursite.com/wiki/python/基础库/","excerpt":"","text":"常用功能 功能 代码 参数 判断文件是否存在 os.path.isfile(path) 判断文件或文件夹是否存在 os.path.exists(path) 判断文件权限 os.access(path, mode) os.F_OK存在 os.R_OK可读 os.W_OK:可写os.X_OK可执行 判断文件夹存在 os.path.isdir(dir) 得到当前工作目录 os.getcwd() 删除文件 os.remove() 列出目录里的文件夹和文件 os.listdir(dir) 改变工作目录到dirname os.chdir(dirname) https://www.cnblogs.com/wq242424/p/5803721.html dis – 查看解释器得出的执行码123import dis# fn 是想查看执行码的函数名print(dis.dis(fn))","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"os","slug":"os","permalink":"http://yoursite.com/tags/os/"},{"name":"sys","slug":"sys","permalink":"http://yoursite.com/tags/sys/"},{"name":"dis","slug":"dis","permalink":"http://yoursite.com/tags/dis/"},{"name":"python基础库","slug":"python基础库","permalink":"http://yoursite.com/tags/python基础库/"}]}]}