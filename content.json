{"meta":{"title":"AIfish","subtitle":"think how to think","description":"NLP AI","author":"aifish","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About Me","date":"2019-03-27T06:54:06.363Z","updated":"2019-03-27T06:54:06.363Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"王晓宇研究方向：自然语言处理 微信二维码： github: https://github.com/ofooo 博客: https://ofooo.github.io 邮箱: ofyu@163.com"},{"title":"Categories","date":"2019-03-18T02:07:20.002Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-03-18T02:07:20.002Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用虚拟机","slug":"编程基础/软件使用备忘/使用虚拟机","date":"2019-05-09T02:55:35.000Z","updated":"2019-05-13T09:09:11.570Z","comments":true,"path":"wiki/编程基础/软件使用备忘/使用虚拟机/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/使用虚拟机/","excerpt":"","text":"安装虚拟机VirtualBox123456789101112131415161718192021# 首先添加VirtualBox的源sudo sh -c 'echo \"deb http://download.virtualbox.org/virtualbox/debian xenial contrib\" &gt;&gt; /etc/apt/sources.list.d/virtualbox.list'# 添加秘钥wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -# 执行更新sudo apt update# 安装virtualboxsudo apt install virtualbox# 下载增强插件（注意插件版本要和虚拟机程序版本一致）https://www.virtualbox.org/wiki/DownloadsVirtualBox 6.0.6 Oracle VM VirtualBox Extension Pack All supported platforms # 老版本下载：Extension Pack https://www.virtualbox.org/wiki/Download_Old_Builds_5_2 # 安装宿主机上的插件 管理--全局设定--扩展--加号---选择下载插件-安装 使用方法简介 设置一个虚拟机 载入一个系统iso，安装系统 把系统导出，方便以后导入使用 ubtuntu虚拟机–设置共享文件夹宿主机上操作 选中虚拟机项目，右键—设置—共享文件夹—点击最右侧的加号按钮 在共享文件夹路径里设置宿主机里的某个路径，再设置一个共享文件夹名称 虚拟机内操作 安装增强插件 创建虚拟机内路径，然后挂载到该路径 123456# 创建路径mkdir /home/user/data# 挂载# 其中“share”就是共享文件夹的名称sudo mount -t vboxsf share /home/user/data 参考资料","categories":[],"tags":[]},{"title":"use_tmux","slug":"编程基础/软件使用备忘/use-tmux","date":"2019-05-01T08:19:49.000Z","updated":"2019-05-13T08:59:49.096Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-tmux/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-tmux/","excerpt":"","text":"安装1sudo apt install tmux 概念 会话（session）：建立一个tmux工作区会话 窗口（window）：容纳多个窗格 窗格（pane）： 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"use-vscode","slug":"编程基础/软件使用备忘/use-vscode","date":"2019-04-27T09:49:58.000Z","updated":"2019-05-14T08:23:51.640Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-vscode/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-vscode/","excerpt":"","text":"使用正则表达式替换搜索文本：static/(.*).css 替换文本中用 $1来表示括号里匹配的内容 安装插件Setting Sync 在不同电脑同步你的配置和插件。上传配置： 安装插件 用默认浏览器登录github网站 shift+alt+U 上传配置：vscode会打开github网站的tokens页面 在网页选择 Generate new token 输入token key 勾选gist 点击Generate token 创建token 复制网页返回的token文本 在vscode的命令可输入token文本，回车 上传成功 下载备份： 在另一个电脑的vscode安装插件 shift+alt+D 下载配置：vscode会打开github网站的tokens页面 先输入token key 再输入token id 回车即可 如果在下载备份过程中出错，需要执行 Sync:Reset Extension Settings 重置选项才可以再次执行 shift+alt+d SFTP查看远程代码 ctrl+shift+P 输入 SFTP: config 如果提示要打开文件夹，则在某个位置打开一个存储SFTP配置的文件夹 然后进行配置json，示范如下： 12345678910&#123; \"name\": \"远程项目名称\", \"host\": \"192.168.1.10\", \"protocol\": \"sftp\", \"syncMode\": \"update\", \"username\": \"demo\", \"remotePath\": \"/home/demo/demo1\", \"privateKeyPath\": \"/home/user/.ssh/id_rsa\", \"uploadOnSave\": true&#125; Path Intellisense自动提示文件路径，支持各种快速引入文件。 Paste Json As Code把粘贴内容格式化。打开命令板，输入Paste Json As Code的命令即可 Gitlens查看代码的最后一行git日志。点击右上角图标即可对比展示你的代码与原repo的区别 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"尼康D5600相机","slug":"摄影/nikon-d5600","date":"2019-04-23T03:49:54.000Z","updated":"2019-04-24T01:05:20.850Z","comments":true,"path":"wiki/摄影/nikon-d5600/","link":"","permalink":"http://yoursite.com/wiki/摄影/nikon-d5600/","excerpt":"","text":"操作设置查看照片信息菜单–播放菜单–播放显示选项 对焦点 无（仅图像） 查看照片播放按钮，左右是切换，上下是查看信息 闪光灯按钮： 镜头前左侧，最上方闪电图标的按钮 按下闪光按钮，波动拨盘，可以调整闪光幅度 拍摄P档：自动曝光拨盘：修改曝光参数组合（曝光时间、光圈） A档：光圈优先拨盘：修改光圈 F3.5大光圈（拍人物，背景会虚化） F22小光圈（大场景的风景照） S档：快门优先拨盘：修改快门时间 当改变快门到光圈的极限，光圈值会闪烁。这时候可以修改ISO （ISO增大，相同快门时间匹配更小的光圈） M档：手动曝光光圈、快门分别手工控制，不会关联变动。 曝光补偿使照片更亮，或更暗。 在AS档，曝光补偿会联动改变光圈或快门。 测光模式测光模式影响整个效果 ×××××××××××× i按钮info按钮BKT按钮 包围曝光的张数3F： 曝光补偿 0 1 2档 分别拍摄1张 -3F： 曝光补偿 0 -1 -2档 分别拍摄1张 QUAR–放大镜 按钮QUAR设置照片大小和格式 色温值 白平衡 固定参数：拍人像，用光圈优先模式和手动模式 室内灯光（曝光补偿会白）快门=1/50 光圈=F4.5 ISO=3200 曝光补偿=+0.7 白平衡4日光灯 快门=1/30 光圈=F4.5 ISO=3200 曝光补偿=+1.3 白平衡4日光灯 曝光锁定|对焦锁定 AE-L AF-L AF 自动对焦 d5600没有？ 模式AF-C AF-A AF-S 对焦区域 参考资料","categories":[{"name":"摄影","slug":"摄影","permalink":"http://yoursite.com/categories/摄影/"}],"tags":[]},{"title":"安装python","slug":"编程基础/python/install-python","date":"2019-04-17T00:55:46.000Z","updated":"2019-04-10T10:05:06.611Z","comments":true,"path":"wiki/编程基础/python/install-python/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/install-python/","excerpt":"","text":"用conda制作模块有时安装不上某个模块，可以尝试用conda安装。conda安装不上时，可以尝试去anaconda.org查询是否有这个模块是否在某个源 12conda install -c 某个源 模块名conda install -c conda-forge jsonnet","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"python_error_book","slug":"编程基础/python/python-error-book","date":"2019-04-15T00:46:54.000Z","updated":"2019-04-15T00:54:35.273Z","comments":true,"path":"wiki/编程基础/python/python-error-book/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/python-error-book/","excerpt":"","text":"用系统内置函数作为变量名比如下面的一些语句，会使你失去系统内置的功能： 123# 把内置类型或函数作为变量复制，导致原有功能失效set = &#123;1, 2, 3&#125;print = 'Hello' 将.py文件命名为内置模块的名称常常被覆盖的模块名有：abc、match、turtle等。比如，为了计算一个公式的值，把源代码文件命名为math.py，内容如下： 123456789import mathprint(math.sqrt(2)*2)# 报错Traceback (most recent call last):File \"/Users/chenbin/Documents/homework/math.py\", line 1, in &lt;module&gt;import mathFile \"/Users/chenbin/Documents/homework/math.py\", line 2, in &lt;module&gt;print(math.sqrt(2)*2)AttributeError: module 'math' has no attribute 'sqrt' 以为input函数是万能的初学者经常会以为input函数可以随心所欲得到想要的那种类型数值，特别是整数，比如： 12n = input(\"请输入年龄：\")print(\"明年你就\", n + 1, \"岁了！\") 结果出错，因为python3中的input函数返回的是字符串，必须要套一层int()才能得到整数。 可变类型的连续赋初值初学者觉得a=b=c=1这样赋初值特别cool，然后： 123456# 初始化了3个空列表，但这其实是幻觉# 因为它们仨指向了同一个可变类型的列表容器对象a=b=c=[] # 给a添加了一个元素a.append(123) # 其实a,b,c指向的是同一个列表，结果a,b,c都是[123] 记住，只有不可变类型的对象可以这么赋初值，或者你确实需要几个指向同一个可变对象的变量（这几乎不会出现）。 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"npm","slug":"编程基础/js前端/npm","date":"2019-04-12T08:38:37.000Z","updated":"2019-04-12T08:04:22.276Z","comments":true,"path":"wiki/编程基础/js前端/npm/","link":"","permalink":"http://yoursite.com/wiki/编程基础/js前端/npm/","excerpt":"","text":"npm run dev 热更新代码123./config/index.jsmodule.exports = &#123;poll: true&#125; # 确定改成true即可热更新 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"js前端","slug":"编程基础/js前端","permalink":"http://yoursite.com/categories/编程基础/js前端/"}],"tags":[]},{"title":"python常用代码","slug":"编程基础/python/python-codes","date":"2019-04-10T14:46:50.000Z","updated":"2019-04-15T00:12:11.611Z","comments":true,"path":"wiki/编程基础/python/python-codes/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/python-codes/","excerpt":"","text":"tqdm进度条12345from tqdm import tqdmgen_tqdm = tqdm(gener, total=len(gener))for i in gen_tqdm: # 实时修改进度条上的描述文本 gen_tqdm.set_description(description, refresh=False) 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"jupyter_notebook","slug":"编程基础/python/jupyter-notebook","date":"2019-04-07T09:58:44.000Z","updated":"2019-04-23T12:09:21.258Z","comments":true,"path":"wiki/编程基础/python/jupyter-notebook/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/jupyter-notebook/","excerpt":"","text":"配置远程密码12345678910111213141516171819202122232425# 生产配置文件jupyter notebook --generate-config# 生成密码# 1. 打开ipython 执行下面2行代码from notebook.auth import passwdpasswd()# 输入2两次密码，生成sha值# 编辑配置文件 ~/.jupyter/jupyter_notebook_config.pyc.NotebookApp.ip='127.0.0.1'c.NotebookApp.allow_remote_access=Truec.NotebookApp.password=u'sha:xxxxxx生成内容'c.NotebookApp.open_browser=Falsec.NotebookApp.port=8888# 配置代码根目录c.ContentsManager.root_dir = '/home/aifish/FishCode'# 启动服务jupyter notebook# 设置开机启动# 加入 rc.localnohup /home/aifish/anaconda3/bin/jupyter notebook&gt;/home/aifish/.jupyter/notebook.log 2&gt;&amp;1 &amp; 把虚拟环境添加到jupyter的kernel1234567进入虚拟环境# 安装 ipykernelpip install ipykernel# 找到python位置（因为加入kernel时需要sudo权限，要制定python路径which python# 使用python绝对路径, 把虚拟环境XXXX加入kernelsudo /anaconda/env/python -m ipykernel install --name XXXX 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"jupyter","slug":"jupyter","permalink":"http://yoursite.com/tags/jupyter/"},{"name":"notebook","slug":"notebook","permalink":"http://yoursite.com/tags/notebook/"}]},{"title":"argparse命令行参数模块","slug":"编程基础/python/argparse","date":"2019-04-05T14:54:57.000Z","updated":"2019-04-08T01:15:48.071Z","comments":true,"path":"wiki/编程基础/python/argparse/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/argparse/","excerpt":"","text":"基础用法：必须参数12345678# 导入命令行解析的库文件import argparse # pkg是一个必须的位置参数(因为前面没有横杠，所以是位置参数。因为没有默认值，所以是必须参数)parse.add_argument('pkg',help='help')# 命令行执行 --help时，会查看的说明parse = argparse.ArgumentParser(description=\"test!!\") 可选参数1234567# nargs是默认值，有默认值的参数是可选参数parse.add_argument('keyoukewu',help='xx'，nargs='?') # 前缀是‘-’的参数名是缩写，前缀是‘--’的参数名是全称parse.add_argument('-a','--abc',help='xx',nargs='?')print(args.abc)print(args.a) # 是错误的：因为解析的时候必须用全称 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"argparse","slug":"argparse","permalink":"http://yoursite.com/tags/argparse/"},{"name":"命令行参数","slug":"命令行参数","permalink":"http://yoursite.com/tags/命令行参数/"}]},{"title":"linux刻录光盘","slug":"编程基础/软件使用备忘/linux_write_DVD","date":"2019-04-02T07:26:08.000Z","updated":"2019-04-28T12:51:00.005Z","comments":true,"path":"wiki/编程基础/软件使用备忘/linux_write_DVD/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/linux_write_DVD/","excerpt":"","text":"ubuntu–Brasero 在Ubuntu软件商店安装brasero 光驱插入光盘 打开brasero 选择：数据项目(A)：创建一个视频DVD或SVCD 点击添加按钮，加入文件夹或文件 给光盘命名（默认是日期文本） 显示进度条，等待刻录完成 大小：4000M比较靠谱（存储空间比真实文件更大）sudo tar cjf - police_model |split -b 4000m - police.v9. 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"allennlp 类","slug":"人工智能/深度学习/allennlp/allennlp-classes","date":"2019-03-31T12:14:52.000Z","updated":"2019-04-01T14:12:35.640Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-classes/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-classes/","excerpt":"","text":"allennlp.data.token_indexers.TokenIndexerallennlp.data.token_indexers.single_id_token_indexerallennlp.common.util.get_frozen_and_tunable_parameter_namesallennlp.common.params.Paramsallennlp.training.trainer.Trainerallennlp.models.archival.archive_modelallennlp.data.iterators.data_iteratorallennlp.models.modelallennlp.data.vocabularyallennlp.data.dataset_reader 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[]},{"title":"allennlp 命令执行流程","slug":"人工智能/深度学习/allennlp/allennlp-command","date":"2019-03-31T11:09:04.000Z","updated":"2019-04-23T12:09:21.258Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-command/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-command/","excerpt":"","text":"安装tensorboard12345# 先要安装tensorboard和tensorflowpip install tensorflow tensorboard# 再安装tensorboardxpip install tensorboardX 命令执行流程1234567891011121314# 程序入口： allennlp.commands.main()# subparser 子命令:\"configure\": allennlp.commands.configure.Configure()\"train\": allennlp.commands.train.Train()\"evaluate\": allennlp.commands.evaluate.Evaluate()\"predict\": allennlp.commands.predict.Predict()\"make-vocab\": allennlp.commands.make_vocab.MakeVocab()\"elmo\": allennlp.commands.elmo.Elmo()\"fine-tune\": allennlp.commands.fine_tune.FineTune()\"dry-run\": allennlp.commands.dry_run.DryRun()\"test-install\": allennlp.commands.test_install.TestInstall()\"find-lr\": allennlp.commands.find_learning_rate.FindLearningRate() 训练流程调用的类和方法123456789&gt;&gt;&gt; allennlp train XXXallennlp/commands/__init__.py main()allennlp/commands/train.py Train()allennlp/commands/train.py Train.train_model_from_args()allennlp/commands/train.py Train.train_model_from_file()allennlp/commands/train.py Train.train_model()allennlp/training/trainer.py Trainer()allennlp/training/trainer.py Trainer.train()allennlp/training/trainer.py Trainer._train_epoch() 12345678# 训练# -r就会使用之前已经创建好的词典allennlp train XXX -s XXX# 启动配置助手(网页)allennlp configure --port 8123 词汇对照表 英文 中文 tag 序列标记（NER输出等） label 类别标签（分类任务输出等） index 索引 padding 填充 Trainer初始化参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Trainer初始化参数----------model：``Model``，必需。要优化的AllenNLP模型，或者是Pytorch模块（它的forward方法必须返回字典，并包含key=“loss”，value=scalar tensor）optimizer：``torch.nn.Optimizer``，必需。 Pytorch Optimizer的一个实例，使用要优化的模型的参数进行实例化。 iterator：``DataIterator``，必需。 迭代“Dataset”的方法，产生填充并转成索引的批次数据。 train_dataset：``Dataset``，必需。 要训练的“Dataset”。数据集应该已经转成索引。 validation_dataset：``Dataset``，可选，（默认=None）。 要评估的“Dataset”。数据集应该已经转成索引。 patience：可选[int]&gt; 0，可选（默认=None） 在early stopping之前要观察的epoch数量：在“patience”个epoch都没有改善则提早停止。如果给出，它必须是“&gt; 0”。 如果为None，则禁用early stopping。 validation_metric：str，optional（default =“loss”） 用来衡量是否使用提早停止以及是否在每个epoch存储is_best模型。度量标准名称必须以“+”或“ - ”为前缀，指定度量标准是增加还是减少。 validation_iterator：``DataIterator``，可选（默认=None） 用于验证集的迭代器。如果是None，那么使用训练集的iterator。 shuffle：``bool``，可选（默认= True） 是否在迭代器中对实例进行随机洗牌。 num_epochs：int，optional（默认值= 20） 培训epoch数量。 serialization_dir：str，optional（默认=None） 用于保存和加载模型文件的目录路径。如果未传递此参数，则不会保存模型。 num_serialized_models_to_keep：``int``，可选（默认= 20） 要保留的先前模型检查点的数量。默认是保留20个检查点。 值为None或-1表示将保留所有检查点。 keep_serialized_model_every_num_seconds：``int``，可选（默认=None） 如果num_serialized_models_to_keep不是None，那么除了最后一个num_serialized_models_to_keep之外，偶尔以给定间隔保存模型也很有用。 为此，请将keep_serialized_model_every_num_seconds指定为永久保存的检查点之间的秒数。请注意，此选项仅在以下情况下使用 num_serialized_models_to_keep不是None，否则保留所有检查点。 model_save_interval：``float``，可选（默认=None） 如果提供，则在单个epoch中每隔N秒存储一次模型。如果提供serialization_dir在每个epoch结束时也会保存模型。 cuda_device：``int``，可选（默认= -1） 一个整数，指定要使用的CUDA设备。如果为-1，则使用CPU。 grad_norm：``float``，可选，（默认=None）。 如果提供，则会按最大值调整梯度。 grad_clipping：``float``，可选（默认=``无``）。 如果提供，渐变将在“向后传递”期间被剪切以具有该值的（绝对）最大值。如果你在训练期间在渐变中得到“NaNs” 使用``grad_norm``无法解决，你可能需要这个。 learning_rate_scheduler：``PytorchLRScheduler``，可选，（默认=None） Pytorch学习速率调度程序。在每个epoch结束时，学习率将相对于该时间表衰减。如果你使用`torch.optim.lr_scheduler.ReduceLROnPlateau类`，这将使用提供的`validation_metric`来确定学习是否已达到稳定状态。支持每个batch更新学习率，这可以选择实现step_batch（batch_num_total），它更新给定batch的学习率。 summary_interval：``int``，可选，（默认= 100） 记录标量到tensorboard之间的批次数 histogram_interval：``int``，optional，（default =``None``） 如果不是None，则每N个batch的柱状图记录到tensorboard。 指定此参数后，将启用以下附加日志记录： *模型参数的柱状图 *参数更新率 *层激活的柱状图 我们记录model.get_parameters_for_histogram_tensorboard_logging 返回的参数的柱状图。 对于``Model``中具有属性``should_log_activations``设置为``True``的任何模块，都会记录图层激活。记录柱状图在训练期间需要许多GPU-CPU副本，并且通常很慢，因此我们建议相对不频繁地记录柱状图。 注意：只有返回张量的模块，张量的元组或dict支持activations日志。 should_log_parameter_statistics：``bool``，可选，（默认= True）是否发送参数统计（平均值和标准差）参数和梯度）到张量板。should_log_learning_rate：``bool``，可选，（默认= False）是否将参数特定学习率发送到tensorboard。log_batch_size_period：``int``，optional，（default =``None``）如果已定义，则记录平均批量大小的频率。“” Vocabulary12345678910111213141516171819202122232425262728293031词汇表将字符串映射到整数，允许将字符串映射到OOV标记（out-of-vocabulary OOV）。词汇表适合特定的数据集，我们用它来决定哪些tokens是词汇表内的。词汇表还允许使用多个不同的命名空间，因此你可以有不同的index对应单词“a”和字符“a”。例如我们可以使用此对象将tags和labels文本映射到index，用一个统一的类：xxx_Field。此类中的大多数方法都允许你传入命名空间; 默认情况下，我们使用'tokens'命名空间，你可以在任何地方省略命名空间参数，只使用默认值。参数----------counter：`Dict [str，Dict [str，int]]`，可选（默认=`None`） 用于初始化此词汇表的计数集合。我们将检查计数，并与该类的其他参数一起使用它们来决定哪些单词是词汇表。如果这是None，我们就不会用任何东西初始化词汇表。min_count：`Dict [str，int]`，可选（默认=None） 从计数器初始化词汇表时，你可以指定最小计数，并且计数小于此值的每个标记都不会添加到词典中。这些最小计数是“特定于命名空间的”，因此你可以为标签与单词指定不同的最小值。如果命名空间在给定的字典中没有key，我们将所有看到的标记添加到该命名空间。max_vocab_size：`Union [int，Dict [str，int]]`，可选（默认=None） 如果要限制词汇表中的令牌数量，可以使用此参数执行此操作。如果指定单个整数，则每个命名空间的词汇表都将固定为不大于此值。如果指定一个字典，那么`counter`中的每个命名空间都可以有一个单独的最大词汇量。任何缺失的键都将具有值“None”，这意味着词汇量大小没有上限。non_padded_namespaces：`Iterable [str]`，可选 默认情况下，我们假设你将单词/字符标记映射为整数，因此你希望为padding和OOV保留单词索引。但是，如果要将NER或SRL的tag或类别标签映射到整数，则可能不希望保留padding和OOV索引。使用此字段指定哪些名称空间不应添加padding和OOV标记。 这个元素的格式是一个字符串，它必须与字段名称完全匹配，或者`*`后跟一个字符串，我们将它们作为字段名称的后缀。 我们尝试使默认值合理，这样你就不必考虑这一点。 默认为（tags，labels），因此只要您的命名空间以“tags”或“labels”结尾（默认情况下，此代码中的所有tag和labels字段均为true）， 不必在这里指定任何东西。pretrained_files：`Dict [str，str]`，可选 如果提供，此映射指定每个命名空间的可选预训练嵌入文件的路径。这可以用于将词汇表限制为仅出现在此文件中的单词，或者确保此文件中的任何单词都包含在词汇表中，而不管其计数如何，具体取决于“only_include_pretrained_words”的值。 出现在预训练嵌入文件中但未出现在数据中的单词不包含在词汇表中。min_pretrained_embeddings：`Dict [str，int]`，可选 如果提供，则为每个命名空间指定与预训练嵌入文件保持一致的最小行数（通常是最常用的单词），即使对于未出现在数据中的单词也是如此。only_include_pretrained_words：`bool`，可选（默认= False） 这定义了使用可能在`pretrained_files`中指定的任何预训练嵌入文件的策略。如果为False，则使用包含策略：并且将“计数器”和预训练文件中的单词添加到“词汇表”中，而不管它们的计数是否超过“min_count”。如果为True，我们使用独占策略：如果单词位于预训练嵌入文件中，则单词仅包含在词汇表中（它们的计数必须至少为'min_count`）。tokens_to_add：`Dict [str，List [str]]`，可选（默认=None） 如果给定，这是一个要添加到词汇表的标记列表，由命名空间键入以添加标记。这是一种确保某些项目出现在词汇表中的方法，无论其他任何词汇计算如何。 tensorboard12345678910111213141516171819class TensorboardWriter(get_batch_num_total: Callable[int], serialization_dir: Optional[str] = None, summary_interval: int = 100, histogram_interval: int = None, should_log_parameter_statistics: bool = True, should_log_learning_rate: bool = False)get_batch_num_total：Callable [[]，int]到目前为止返回批次数的thunk。 很可能这将是一个围绕Trainer类中的实例变量的闭包。serialization_dir：str，optional（默认=None）如果提供，则这是Tensorboard日志的写入位置。summary_interval：int，optional（默认值= 100）大多数统计数据只会在这么多批次中写出来。histogram_interval：int，optional（default = None）如果提供，则每隔这些批次就会记录激活柱状图。 如果为None，则不会写。should_log_parameter_statistics：bool，optional（default = True）是否记录参数统计信息。should_log_learning_rate：bool，optional（默认= False）是否记录学习率。 indexer索引器12345678910111213141516171819202122232425262728TokenIndexer“TokenIndexer”确定字符串标记如何表示为模型中的索引数组。这个类在a的帮助下将字符串转换为数值：class：`~allennlp.data.vocabulary.Vocabulary`，它产生实际的数组。标记可以表示为单个ID（例如，单词“cat”由数字表示34），或作为字符ID列表（例如，“cat”由数字[23,10,18]表示），或以某种其他方式，你可以提出（例如，如果你有一些结构化的输入你想要在数据数组中以特殊方式表示，你可以在这里做到这一点）。default_implementation ='single_id'def count_vocab_items（self，token：Token，counter：Dict [str，dict [str，int]]）： ：class：`Vocabulary`需要为我们在训练数据中看到的任何字符串分配索引（可能进行一些频率过滤和使用OOV，或者使用词汇表，令牌）。对于令牌中存在的任何词汇项，此方法采用令牌和计数字典和增量计数。如果这是单个令牌ID表示，则词汇表项可能是令牌本身。如果这是令牌字符表示，则词汇表项是令牌中的所有字符。def tokens_to_indices（self，tokens：List [Token]，词汇：Vocabulary，index_name：str） - &gt; Dict [str，List [TokenType]]： 获取令牌列表并将其转换为一组或多组索引。这可能只是词​​汇表中每个标记的ID。或者它可以将每个标记分成字符并返回每个字符一个ID。或者（例如，在字节对编码的情况下）可能没有从单个令牌到索引的干净映射。def get_padding_token（self） - &gt; TokenType： 当我们需要添加填充令牌时，它们应该是什么样的？此方法返回由以下函数返回的任何类型的“空白”标记：func：`tokens_to_indices`。def get_padding_lengths（self，token：TokenType） - &gt; Dict [str，int]： 此方法返回给定标记的填充字典，该字典指定需要填充的所有数组的长度。例如，对于单个ID令牌，返回的字典将为空，但对于令牌字符表示，这将返回令牌中的字符数。def pad_token_sequence（self，tokens：Dict [str，List [TokenType]]，desired_num_tokens：Dict [str，int]，padding_lengths：Dict [str，int]） - &gt; Dict [str，List [TokenType]]： 此方法将令牌列表填充到“desired_num_tokens”并返回输入令牌的填充副本。如果输入标记列表长于“desired_num_tokens”，那么它将被截断。 `padding_lengths`用于提供在某些情况下需要的补充填充参数。例如，它包含在执行字符级填充时填充字符的宽度。def get_keys（self，index_name：str） - &gt; List [str]： 返回此索引器从`tokens_to_indices`返回的键列表。 Field 字段Field 字段基类1234567891011121314151617181920212223242526272829Field“字段”是instance数据实例的一部分，最终作为模型中的张量（作为输入或输出）。 数据实例只是字段的集合。 字段最多经历两个处理步骤：（1）将标记化字段转换为标记ID，（2）填充包含标记id（或任何其他数字数据）的字段（如果需要）并转换为张量。 `Field`API有这两个步骤的方法，虽然它们可能不需要一些具体的`Field`类 - 如果你的字段没有任何需要索引的字符串，你不需要实现`count_vocab_items` 或`索引`。 这些方法默认为`pass`。 一旦计算出词汇表并对所有字段编制索引，我们将确定填充长度，然后智能地将实例批处理并将它们填充到实际张量中。def count_vocab_items（self，counter：Dict [str，dict [str，int]]）：“”“如果这个字段中的字符串需要通过：class：`Vocabulary`转换成整数，这里就是我们统计它们的位置，以确定哪些令牌在词汇表之内或之外。 如果你的`Field`没有任何需要转换为索引的字符串，你不需要实现这个方法。 关于这个`counter`的注释：因为`Fields`可以代表概念上不同的东西，我们用`namespaces`分隔词汇项。这样，我们可以使用单个共享机制来处理从字符串到所有字段中的整数的所有映射，同时保持`TextField`中的单词与`LabelField`中的标签共享相同的id（例如，\"entailment\" or \"contradiction\"是蕴涵任务中的标签” 另外，单个`Field`可能想要使用多个名称空间 - “TextFields”可以表示为单词ID和字符id的组合，并且您不希望单词和字符共享相同的vocabulary - “a”作为单词应该从“a”作为一个字符获得不同的id，并且单词和字符的词汇量大小非常不同。 因此，`counter`对象中的第一个键是`namespace'，如“tokens”，“token_characters”，“tags”或“labels”，第二个键是实际的词汇表项item。 def index（self，vocab：Vocabulary）： 给定一个：class：`Vocabulary`，将该字段中的所有字符串转换为（通常）整数。这个`修改``Field`对象，它不返回任何东西。 如果你的`Field`没有任何需要转换为索引的字符串，你不需要实现这个方法。def get_padding_lengths（self） - &gt; Dict [str，int]： 如果此字段中有需要填充的内容，请在此处记下。为了填充一批实例，我们从批处理中获取所有长度，取最大值，并将所有内容填充到该长度（或使用预先指定的最大长度）。返回值是将键映射到长度的字典，例如&#123;'num_tokens'：13&#125;。 这总是在：func：`index`之后调用。 msgstr“”“引发NotImplementedErrordef as_tensor（self，padding_lengths：Dict [str，int]） - &gt; DataArray： 给定一组指定的填充长度，实际填充此字段中的数据并返回正确形状的割炬张量（或更复杂的数据结构）。我们还采用了一些在构建火炬传感器时很重要的参数。 参数---------- padding_lengths：`Dict [str，int]`这个字典将具有与func：`get_padding_lengths`相同的键。这些值指定填充每个相关维度时使用的长度，这些维度在批处理中的所有实例之间聚合。 msgstr“”“引发NotImplementedErrordef empty_field（self） - &gt;'Field'： 因此`ListField`可以填充列表中的字段数（例如，答案选项`TextFields`的数量），我们需要表示每种类型的空字段。这会返回。这只会在我们调用时调用：func：`as_tensor`，所以你不必担心在这个空字段上调用`get_padding_lengths`，`count_vocab_items`等等。 我们使这个实例方法而不是静态方法，这样如果Field中有任何状态，我们可以复制它（例如，`TextField`中的标记索引器）。 msgstr“”“引发NotImplementedErrordef batch_tensors（self，tensor_list：List [DataArray]） - &gt; DataArray：#type：ignore从`Instances`列表中获取`Field.as_tensor（）`的输出，并将其合并为一个批量张量为此`Field` 。这里基类的默认实现处理`as_tensor`为每个实例返回一个火炬张量的情况。如果您的子类返回除此之外的其他内容，则需要覆盖此方法。 这个操作不会修改`self`，但在某些情况下我们需要`self`中包含的信息来执行批处理，所以这是一个实例方法，而不是类方法。 “”#pylint：disable = no-self-use return torch.stack（tensor_list） SequenceField 序列字段12SequenceField`SequenceField`代表一系列事物。 这个类只是在`Field` :: func：`sequence_length`上添加了一个方法。 它的存在使得`SequenceLabelField`，`IndexField`和其他类似的`Fields`可以有一个类型要求，具有一致的API，它们是指向`TextField`中的单词，`ListField`中的项目，还是 别的。 TextField 文本字段123456TextField这个`Field`代表一个字符串标记列表。 在构造此对象之前，需要使用：class：`~allennlp.data.tokenizers.tokenizer.Tokenizer`来标记原始字符串。因为字符串标记可以通过多种方式表示为索引数组，所以我们还会使用以下字典：class：`~allennlp.data.token_indexers.token_indexer.TokenIndexer`对象，用于将标记转换为索引。 每个“TokenIndexer”可以将每个标记表示为单个ID，或者字符ID列表或其他内容。该字段将被转换为数组字典，每个`TokenIndexer`一个。 `SingleIdTokenIndexer`生成一个形状数组（num_tokens，），而`TokenCharactersIndexer`生成一个形状数组（num_tokens，num_characters）。 SequenceLabelField1234567891011121314151617181920212223SequenceLabelField`SequenceLabelField`为a中的每个元素分配一个分类标签产品类别：`〜allennlp.data.fields.sequence_field.SequenceField`。因为它是某个其他字段的标签，我们在此处将该字段作为输入，我们将其用于确定我们的填充和其他东西。此字段将转换为整数类ID列表，表示正确的类对于序列中的每个元素。参数----------标签：`Union [List [str]，List [int]]` 一系列分类标签，编码为字符串或整数。这些可能是POS标签，如[NN，JJ，...]，BIO标签，如[B-PERS，I-PERS，O，O，...]，或任何其他分类标签序列。如果标签被编码为整数，则不会使用词汇对其进行索引。sequence_field：`SequenceField` 包含此SequenceLabelField`标记序列的字段。大多数情况下，这是一个“TextField”，用于标记句子中的单个标记。label_namespace：`str`，optional（default ='labels'） 用于将标记字符串转换为整数的命名空间。我们将标记字符串转换为整数，并且此参数告诉`Vocabulary`对象从字符串到整数的映射使用（因此“O”作为标记不会获得与“O”作为单词相同的id） 。“””＃用户可能希望将此字段与使用OOV / PAD令牌的命名空间一起使用。＃对于此类的每个实例化（即每个数据），将重复此警告#instance），喷出很多警告，所以这个类变量只用于记录单个变量每个命名空间＃警告。 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[{"name":"allennlp","slug":"allennlp","permalink":"http://yoursite.com/tags/allennlp/"},{"name":"command","slug":"command","permalink":"http://yoursite.com/tags/command/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"allennlp_json_config","slug":"人工智能/深度学习/allennlp/allennlp-json-config","date":"2019-03-31T11:04:31.000Z","updated":"2019-04-01T14:12:35.640Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-json-config/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-json-config/","excerpt":"","text":"第一层配置1234567&#123; \"dataset_reader\": &#123;&#125;, \"train_data_path\": \"\", \"model\": &#123;&#125;, \"iterator\": &#123;&#125;, \"trainer\": &#123;&#125;&#125; 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[{"name":"allennlp","slug":"allennlp","permalink":"http://yoursite.com/tags/allennlp/"},{"name":"配置文件","slug":"配置文件","permalink":"http://yoursite.com/tags/配置文件/"}]},{"title":"allennlp_models","slug":"人工智能/深度学习/allennlp/allennlp-models","date":"2019-03-29T09:29:52.000Z","updated":"2019-05-01T11:43:43.276Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-models/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-models/","excerpt":"","text":"crf_taggerallennlp/models/crf_tagger.py class CrfTagger 12345678910111213141516171819202122232425262728293031323334`CrfTagger`使用`Seq2SeqEncoder`编码一系列文本，然后使用条件随机场模型来预测序列中每个标记的标记。参数----------vocab：`Vocabulary'，必需 用于计算输入/输出尺寸大小所需的词汇表。text_field_embedder：`TextFieldEmbedder`，必需 用于嵌入标记`TextField`，我们将其作为模型的输入。encoder：`Seq2SeqEncoder` 我们将在嵌入令牌和预测输出标签之间使用的编码器。label_namespace：`str`，optional（默认 =`labels`） 这是计算SpanBasedF1Measure指标所必需的。 除非你做了一些特殊处理，否则默认值即可。feedforward：`FeedForward`，可选，（默认=None）。 在编码器之后应用的可选前馈层。label_encoding：`str`，optional（默认=None） 在计算跨度f1时使用的标签编码，并在解码时限制CRF。有效选项是“BIO”，“BIOUL”，“IOB1”，“BMES”。 如果`calculate_span_f1`或`constrain_crf_decoding`为真，则为必需。include_start_end_transitions：`bool`，可选（默认=True） 是否在CRF中包含开始和结束转换参数。constrain_crf_decoding：`bool`，optional（默认=None） 如果为“True”，则CRF在解码时被约束以产生有效的标签序列。如果这是'True`，则需要`label_encoding`。如果指定了“None”和label_encoding，则将其设置为“True”。 如果未指定`None`和label_encoding，则默认为'False`。calculate_span_f1：`bool`，可选（默认=None） 在培训期间计算跨度级F1指标。如果这是'True`，则需要`label_encoding`。如果指定了“None”和label_encoding，则将其设置为“True”。 如果未指定`None`和label_encoding，则默认为'False`。dropout：`float`，optional（默认=None）verbose_metrics：`bool`，可选（默认= False） 如果为true，则除了整体统计信息之外，还将为每个标签类返回指标。初始化程序：`InitializerApplicator`，可选（默认=`InitializerApplicator（）`） 用于初始化模型参数。正规化器：`RegularizerApplicator`，可选（默认=None） 如果提供，将用于计算训练期间的正则化惩罚。 Coreference Resolution 指代消解该模型在CoNLL测试集的F1达到63.0% 123456# 引用模型from allennlp.predictors.predictor import Predictorpredictor = Predictor.from_path(\"https://s3-us-west-2.amazonaws.com/allennlp/models/coref-model-2018.02.05.tar.gz\")predictor.predict( document=\"The woman reading a newspaper sat on the bench with her dog.\") Named Entity Recognition 命名实体识别模型使用ELMo嵌入的biLSTM 参考资料 https://allennlp.org/models","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[{"name":"allennlp","slug":"allennlp","permalink":"http://yoursite.com/tags/allennlp/"},{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"}]},{"title":"python代码加密","slug":"编程基础/python/python代码加密","date":"2019-03-29T07:45:48.000Z","updated":"2019-03-29T12:25:47.306Z","comments":true,"path":"wiki/编程基础/python/python代码加密/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/python代码加密/","excerpt":"","text":"目前的加密手段： 源代码混淆：只降低源码可读性，对破解有一定的干扰作用 只发行 pyc: 可以用现成工具复原 打包 exe: 可以用现成工具复原 cython打包so文件: 要加密单一的模块 /特制算法很有效，不过对很多复杂模块无法兼容，比如 django 写的 app 修改python解释器: 未丢失信息，容易复原 总结：python语言在设计理念上倾向于开源，没有很完美的加密方案，只能有限程度上增加破解者的难度（对于有经验的破解者形同虚设） 其他方案： 核心代码逻辑替换成 C++ 或 go语言 终极方案： 只提供api服务，不提供本地运行的程序","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"命令行参数和环境变量","slug":"编程基础/python/命令行参数和环境变量","date":"2019-03-29T01:04:15.000Z","updated":"2019-03-29T12:25:47.306Z","comments":true,"path":"wiki/编程基础/python/命令行参数和环境变量/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/命令行参数和环境变量/","excerpt":"","text":"命令行参数12345import sysnum = len(sys.argv) # 参数个数script_name = sys.argv[0] # 脚本命令名称arg1 = sys.argv[1] # 参数1arg2 = sys.argv[2] # 参数2 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"thread多线程模块","slug":"编程基础/python/thread多线程","date":"2019-03-27T08:30:26.000Z","updated":"2019-03-28T13:19:23.503Z","comments":true,"path":"wiki/编程基础/python/thread多线程/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/thread多线程/","excerpt":"","text":"概述threading用于提供线程相关的操作，线程是应用程序中工作的最小单元。 python当前版本的多线程库没有实现优先级、线程组，线程也不能被停止、暂停、恢复、中断。 threading模块提供的类： Thread, Lock, Rlock, Condition, [Bounded]Semaphore, Event, Timer, local。 threading 模块提供的常用方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 ​ threading.currentThread().getName()获取当前程序的线程名称 threading 模块提供的常量： threading.TIMEOUT_MAX 设置threading全局超时时间。 Thread类构造方法： Thread(group=None, target=None, name=None, args=(), kwargs={}) group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 线程名； args/kwargs: 要传入方法的参数。 实例方法： isAlive(): 返回线程是否在运行。正在运行指启动后、终止前。 get/setName(name): 获取/设置线程名。 start(): 线程准备就绪，等待CPU调度 is/setDaemon(bool): 获取/设置是后台线程（默认前台线程（False））。（在start之前设置） 如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主线程和后台线程均停止 如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止 start(): 启动线程。 join([timeout]): 阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout（可选参数）。 123456789101112131415161718192021222324import threadingimport timedef action(arg): time.sleep(1) print('the arg is:%s\\r' %arg) #运行方法一：将要执行的方法作为参数传给Thread的构造方法for i in range(4): t =threading.Thread(target=action,args=(i,)) t.start()#运行方法二：从Thread继承，并重写run()class MyThread(threading.Thread): def __init__(self,arg): super().__init__()#注意：一定要显式的调用父类的初始化函数。 self.arg=arg def run(self):#定义每个线程要运行的函数===action() time.sleep(1) print('the arg is:%s\\r' % self.arg)for i in xrange(4): t = MyThread(i) t.start() 123456789101112thread_list = [] #线程存放列表for i in xrange(4): t =threading.Thread(target=action,args=(i,)) t.setDaemon(True) thread_list.append(t)for t in thread_list: t.start()for t in thread_list: t.join()# join()阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout，即使设置了setDeamon（True）主线程依然要等待子线程结束。 参考资料 [python–threading多线程总结]","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"Queue 队列模块相关","slug":"编程基础/python/queue","date":"2019-03-25T00:13:50.000Z","updated":"2019-03-27T06:57:59.326Z","comments":true,"path":"wiki/编程基础/python/queue/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/queue/","excerpt":"","text":"heap 堆 stack 栈 queue 队列 堆的逻辑结构就是完全二叉树，并且二叉树中父节点的值小于等于该节点的所有子节点的值。 特征：heap[k] &lt;= heap[2k+1] 并且 heap[k] &lt;= heap[2k+2] （其中 k 为索引，从 0 开始计数） heapq 堆队列基本操作12345678910111213141516171819202122import heapq heap = []#向堆中插入元素，heapq会维护列表heap中的元素保持堆的性质 heapq.heappush(heap, item) #heapq把列表x转换成堆 O(n)复杂度heapq.heapify(x) # 最小堆heapq._heapify_max(x) # 最大堆#从可迭代的迭代器中返回最大的n个数，可以指定比较的key heapq.nlargest(n, iterable[, key]) #从可迭代的迭代器中返回最小的n个数，可以指定比较的key heapq.nsmallest(n, iterable[, key]) #从堆中删除元素，返回值是堆中最小或者最大的元素 heapq.heappop(heap)heapq.heappushpop(heap, item)：向 heap 中加入 item 元素，并返回 heap 中最小元素。heapq.heapreplace(heap,item): python3中heappushpop的更高效版。 原理使用的比较函数：lt, gt, cmp 内置数据类型和自定义类型，默认使用 lt （小于比较函数）进行比较 元组类型默认使用 cmp 比较 （先比较第1列，相同再比较第2列，以此类推……） 代码示范12345678import heapqh = []# 默认是最小堆heapq.heappush(h, (5, 'write code'))heapq.heappush(h, (7, 'release product'))heapq.heappush(h, (1, 'write spec'))heapq.heappush(h, (3, 'create tests'))min_item = heapq.heappop(h) # (1, 'write spec') PriorityQueue 优先队列 queue库是线程安全的 1234567891011121314151617181920#向队列中添加元素Queue.put(item[, block[, timeout]])#从队列中获取元素Queue.get([block[, timeout]])#队列判空Queue.empty()#队列大小Queue.qsize()try: import Queue as Q #python version &lt; 3.0except ImportError: import queue as Q #python3.*q = Q.PriorityQueue()q.put(19)q.put(1)q.put(5)while not q.empty(): print(q.get()) 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"python基本数据类型","slug":"编程基础/python/python_datatype","date":"2019-03-21T06:35:53.000Z","updated":"2019-03-25T00:13:36.116Z","comments":true,"path":"wiki/编程基础/python/python_datatype/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/python_datatype/","excerpt":"","text":"时间复杂度注释n代表容器中元素的数量，k代表参数的值，或者参数的数量。 [注1] =这些业务依赖于“摊销最坏情况”的“Amortized摊销”部分。 根据容器的历史，个别动作可能需要很长时间。 [注2] =对于这些操作，最坏情况n是容器达到的最大尺寸，而不仅仅是当前尺寸。 例如，如果将N个对象添加到字典中，则删除N-1，仍然会为N个对象（至少）调整字典的大小，直到进行另一次插入为止。 list 列表是以数组（Array）实现的。最大的开销发生在超过当前分配大小的增长，这种情况下所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动。如果你需要在一个队列的两端进行增删的操作，应当使用collections.deque（双向队列） 操作 平均情况 最坏情况 复制 O(n) O(n) append[注1] O(1) O(1) 插入 insert O(n) O(n) 取元素 O(1) O(1) 更改元素 O(1) O(1) 删除元素 O(n) O(n) 遍历 O(n) O(n) 取切片 O(k) O(k) 删除切片 O(n) O(n) 更改切片 O(k+n) O(k+n) extend[注1] O(k) O(k) 排序 O(n log n) O(n log n) 列表乘法 O(nk) O(nk) x in s O(n) min(s), max(s) O(n) 获取长度 O(1) O(1) 双向队列（collections.deque） deque （double-ended queue，双向队列）是以双向链表的形式实现的 (Well, a list of arrays rather than objects, for greater efficiency)。双向队列的两端都是可达的，但从查找队列中间的元素较为缓慢，增删元素就更慢了。 操作 平均情况 最坏情况 复制 O(n) O(n) append O(1) O(1) appendleft O(1) O(1) pop O(1) O(1) popleft O(1) O(1) extend O(k) O(k) extendleft O(k) O(k) rotate O(k) O(k) remove O(n) O(n) 字典（dict） 下列字典的平均情况基于以下假设: 1 对象的散列函数足够撸棒（robust），不会发生冲突。2 字典的键是从所有可能的键的集合中随机选择的。 小窍门：只使用字符串作为字典的键。这么做虽然不会影响算法的时间复杂度，但会对常数项产生显著的影响，这决定了你的一段程序能多快跑完。 操作 平均情况 最坏情况 复制[注2] O(n) O(n) 取元素 O(1) O(n) 更改元素[注1] O(1) O(n) 删除元素 O(1) O(n) 遍历[注2] O(n) O(n) dict.setdefault(key, default=None)返回dict[key] 。如果没有key，则设置dict[key]=default并返回dict[key] 集合（set） 未列出的操作可参考 dict —— 二者的实现非常相似。 操作 平均情况 最坏情况 x in s O(1) O(n) 并集 s\\ t O(len(s)+len(t)) 交集 s&amp;t O(min(len(s), len(t)) O(len(s) * len(t)) 差集 s-t O(len(s)) s.difference_update(t) O(len(t)) 对称差集 s^t O(len(s)) O(len(s) * len(t)) s.symmetric_difference_update(t) O(len(t)) O(len(t) * len(s)) 由源码得知，求差集（s-t，或s.difference(t)）运算与更新为差集（s.difference_uptate(t)）运算的时间复杂度并不相同！前者是将在s中，但不在t中的元素添加到新的集合中，因此时间复杂度为O(len(s))；后者是将在t中的元素从s中移除，因此时间复杂度为O(len(t))。因此，使用时请留心，根据两个集合的大小以及是否需要新集合来选择合适的方法。 集合的s-t运算中，并不要求t也一定是集合。只要t是可遍历的对象即可。 参考资料Python内置方法的时间复杂度","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"配置vscode","slug":"编程基础/安装与配置/set-vscode","date":"2019-03-20T05:59:18.000Z","updated":"2019-04-12T07:16:51.728Z","comments":true,"path":"wiki/编程基础/安装与配置/set-vscode/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/set-vscode/","excerpt":"","text":"配置快捷键12向下复制一行---改成Ctrl+Deditor.action.copyLinesDownAction 插件 插件名 说明 Project Manager 项目管理 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"双指针找环","slug":"编程基础/leetcode/141. Linked_List_Cycle","date":"2019-03-19T14:08:18.000Z","updated":"2019-03-25T00:13:36.116Z","comments":true,"path":"wiki/编程基础/leetcode/141. Linked_List_Cycle/","link":"","permalink":"http://yoursite.com/wiki/编程基础/leetcode/141. Linked_List_Cycle/","excerpt":"","text":"题目https://leetcode.com/problems/linked-list-cycle/ 141.给一个链表的头节点,判断链表是否有环 解法1: 用set判断重复优点: 逻辑直观, 容易理解 比双指针更快 缺点: 空间占用比双指针更多 解法2: 双指针 用两个指针指向head 进行循环: 每次慢指针下移一次,快指针下移两次 如果快指针指向结尾则无循环,如果两个指针指向同一个节点则有循环","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"leetcode","slug":"编程基础/leetcode","permalink":"http://yoursite.com/categories/编程基础/leetcode/"}],"tags":[]},{"title":"使用docker","slug":"编程基础/软件使用备忘/use-docker","date":"2019-03-19T06:49:42.000Z","updated":"2019-04-30T01:19:50.842Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-docker/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-docker/","excerpt":"","text":"配置### 服务设置刚安装完成后，需要重启机器，才能启动服务 1234567# Ubuntusudo service docker start # 启动服务# manjarosudo systemctl start docker # 启动服务sudo systemctl status docker # 查看服务状态systemctl enable docker # 开机启动 设置信任本地仓库123# 1. 在/etc/default/docker添加：-- insecure-registry 127.0.0.1:5000# 2. 再重启docker 服务 容器-常用命令123456789101112# 查看容器列表 ## -a 查看全部，否则查看运行中的docker ps# 删除容器 -f强制删除docker rm -f xxx# 实时查看容器占用的CPU和内存资源docker stats# 从容器生成镜像docker commit -m \"change somth\" -a \"somebody info\" container_id(docker ps -a获取id) 新镜像名字 容器自启动设置12docker run --restart=on-failure:10 xxxdocker run --restart=always xxx no 容器退出时不要自动重启。这个是默认值。 on-failure[:max-retries] 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数。在每次重启容器之前，重启延迟比上次增加一倍，从100毫秒开始，来防止影响服务器。这意味着daemon将等待100ms,然后200ms，直到超过on-failure限制，或执行docker stop或docker rm -f 。如果容器重启成功[容器启动后并运行至少10秒]，然后delay重置为默认的100ms。ms, 400, 800, 1600等等，直到超过on-failure限制，或执行docker stop或docker rm -f always 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启，不管容器当时的状态如何。(和unless-stopped 参数值效果一样) 镜像-常用命令123456789101112# 查看镜像列表docker images# 导出镜像的压缩文件（可以压缩多个镜像，例如xxx和yyy）docker save xxx:tag yyy:tag2 | gzip &gt; img.tar.gz # 镜像重命名docker tag xxx:tag xxx2:tag2# 删除镜像 ## -f强制删除docker rmi -f xxx:tag DockerFile参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"交换变量（快捷写法和注意事项）","slug":"编程基础/python/交换2个变量","date":"2019-03-19T05:55:32.000Z","updated":"2019-03-19T10:25:03.600Z","comments":true,"path":"wiki/编程基础/python/交换2个变量/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/交换2个变量/","excerpt":"","text":"交换变量快捷写法：最多支持4个变量互换123a, b, c = 1,2,3a,b,c = c,a,b# 结果： a=3 b=1 c=2 如果交换内容涉及：对象及其属性，需要考虑先后顺序123456789101112131415161718class ListNode: def __init__(self, x): self.val = x self.next = None # 正确的交换 node = ListNode(1) ; node.next = 2node.next, node = node.val, node.next# 结果： node=2 # 错误的交换 node = ListNode(1) ; node.next = 2node, node.next = node.next, node.val# 结果报错信息：# AttributeError: 'int' object has no attribute 'next'# node = node.next (2)# node.next = node.val int没有next属性 原因 交换的不是变量，而是变量的地址。地址变化是有顺序的，并不是同时完成的。 如果没有涉及到对象及其属性，地址变化不会影响取值过程，所以不会报错。所以看起来像是一句代码同时完成了一样。 python解释得出的执行码中有4个指令：ROT_TWO /ROT_THREE/ROT_FOUR 所以交换赋值语句最多支持4个变量","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"基础语法","slug":"基础语法","permalink":"http://yoursite.com/tags/基础语法/"}]},{"title":"GPU相关","slug":"人工智能/深度学习/GPU相关","date":"2019-03-18T02:07:19.999Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/深度学习/GPU相关/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/GPU相关/","excerpt":"","text":"查看当前GPU使用情况 nvidia-smi 设置使用哪个GPU CUDA_VISIBLE_DEVICES=”1” 查看CUDA版本 nvcc –version 12# 查看显卡版本lspci | grep -i nvidia","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"}],"tags":[{"name":"gpu","slug":"gpu","permalink":"http://yoursite.com/tags/gpu/"}]},{"title":"es-搜索操作","slug":"人工智能/搜索引擎/es-search","date":"2019-03-17T01:25:03.000Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/搜索引擎/es-search/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/es-search/","excerpt":"","text":"搜索备忘一原生的url接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# 搜索位置(url)/_search # 在所有的索引中搜索所有的类型/gb/_search # 在 gb 索引中搜索所有的类型/gb,us/_search # 在 gb 和 us 索引中搜索所有的文档/g*,u*/_search # 在任何以 g 或者 u 开头的索引中搜索所有的类型/gb/user/_search # 在 gb 索引中搜索 user 类型/gb,us/user,tweet/_search # 在 gb 和 us 索引中搜索 user 和 tweet 类型/_all/user,tweet/_search # 在所有的索引中搜索 user 和 tweet 类型# 分页(url)POST /_search # 默认size=10, from=0 从0返回POST /_search?size=5 # 第二页POST /_search?size=5&amp;from=5POST /_search?size=5&amp;from=10# term 精确查找,不计算相关度.&#123; \"term\" : &#123; \"price\" : 20 &#125;&#125;# 用constant_score 把term包装成filterPOST /my_store/products/_search&#123; \"query\" : &#123; \"constant_score\" : &#123; \"filter\" : &#123; \"term\" : &#123; \"productID\" : \"XHDK-A-1293-#fJ3\" &#125; &#125; &#125; &#125;&#125;# range 过滤器(filter): age &gt; 30# 过滤器执行速度非常快，不会计算相关度. 精确的筛选.POST /megacorp/employee/_search&#123; \"query\" : &#123; \"bool\": &#123; \"must\": &#123; \"match\" : &#123;\"last_name\" : \"smith\" &#125; &#125;, \"filter\": &#123; \"range\" : &#123; \"age\" : &#123; \"gt\" : 30 &#125; &#125; &#125; &#125; &#125;&#125;# 全文搜索: 返回相关性排序的结果． 如果有rock没有climbing也可能会返回结果.POST /megacorp/employee/_search&#123; \"query\" : &#123; \"match\" : &#123; \"about\" : \"rock climbing\" &#125; &#125;&#125;&#123; \"query\": &#123; \"match_phrase\": &#123; \"content\" : &#123; \"query\" : \"我的宝马多少马力\", \"slop\" : 1 &#125; &#125; &#125;&#125;# 实际上下面的query才能正确返回结果，搜索的是content这个字段里包含对应文本的文档# 精确匹配一系列单词或者短语POST /megacorp/employee/_search&#123; \"query\" : &#123; \"match_phrase\" : &#123; \"about\" : \"rock climbing\" &#125; &#125;&#125;# 高亮搜索POST /megacorp/employee/_search&#123; \"query\" : &#123; \"match_phrase\" : &#123; \"about\" : \"rock climbing\" &#125; &#125;, \"highlight\": &#123; \"fields\" : &#123; \"about\" : &#123;&#125; &#125; &#125;&#125;# 返回:&#123; ... \"hits\": &#123; \"total\": 1, \"max_score\": 0.23013961, \"hits\": [ &#123; ... \"_score\": 0.23013961, \"_source\": &#123; \"first_name\": \"John\", \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] &#125;, \"highlight\": &#123; \"about\": [ \"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;\" ] &#125; &#125; ] &#125;&#125;# 聚合（aggregations）: 统计某些标签的数量(是在搜索结果中进行统计,可以结合其他query)POST /megacorp/employee/_search&#123; \"aggs\": &#123; \"all_interests\": &#123; \"terms\": &#123; \"field\": \"interests\" &#125; &#125; &#125;&#125; 搜索备忘二http://www.cnblogs.com/yjf512/p/4897294.html 12345678910111213组合式搜索&#123; \"query\": &#123; &#123; \"bool\": &#123; \"must\": &#123; \"match\": &#123; \"tweet\": \"elasticsearch\" &#125;&#125;, \"must_not\": &#123; \"match\": &#123; \"name\": \"mary\" &#125;&#125;, \"should\": &#123; \"match\": &#123; \"tweet\": \"full text\" &#125;&#125;, # 这些match可以是数组 \"filter\": &#123; \"range\": &#123; \"age\" : &#123; \"gt\" : 30 &#125;&#125; &#125; &#125; &#125; &#125; &#125; elasticsearch 查询（match和term）es中的查询请求有两种方式，一种是简易版的查询，另外一种是使用JSON完整的请求体，叫做结构化查询（DSL）。由于DSL查询更为直观也更为简易，所以大都使用这种方式。DSL查询是POST过去一个json，由于post的请求是json格式的，所以存在很多灵活性，也有很多形式。这里有一个地方注意的是官方文档里面给的例子的json结构只是一部分，并不是可以直接黏贴复制进去使用的。一般要在外面加个query为key的机构。 match最简单的一个match例子： 查询和”我的宝马多少马力”这个查询语句匹配的文档。 123456789&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot; : &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot; &#125; &#125; &#125;&#125; 上面的查询匹配就会进行分词，比如”宝马多少马力”会被分词为”宝马 多少 马力”, 所有有关”宝马 多少 马力”, 那么所有包含这三个词中的一个或多个的文档就会被搜索出来。并且根据lucene的评分机制(TF/IDF)来进行评分。 match_phrase比如上面一个例子，一个文档”我的保时捷马力不错”也会被搜索出来，那么想要精确匹配所有同时包含”宝马 多少 马力”的文档怎么做？就要使用 match_phrase 了 123456789&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;content&quot; : &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot; &#125; &#125; &#125;&#125; 完全匹配可能比较严，我们会希望有个可调节因子，少匹配一个也满足，那就需要使用到slop。 12345678910&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;content&quot; : &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot;, &quot;slop&quot; : 1 &#125; &#125; &#125;&#125; multi_match如果我们希望两个字段进行匹配，其中一个字段有这个文档就满足的话，使用multi_match 12345678&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot;, &quot;fields&quot; : [&quot;title&quot;, &quot;content&quot;] &#125; &#125;&#125; 但是multi_match就涉及到匹配评分的问题了。 我们希望完全匹配的文档占的评分比较高，则需要使用best_fields12345678910111213&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;我的宝马发动机多少&quot;, &quot;type&quot;: &quot;best_fields&quot;, &quot;fields&quot;: [ &quot;tag&quot;, &quot;content&quot; ], &quot;tie_breaker&quot;: 0.3 &#125; &#125;&#125; 意思就是完全匹配”宝马 发动机”的文档评分会比较靠前，如果只匹配宝马的文档评分乘以0.3的系数 我们希望越多字段匹配的文档评分越高，就要使用most_fields123456789101112&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;我的宝马发动机多少&quot;, &quot;type&quot;: &quot;most_fields&quot;, &quot;fields&quot;: [ &quot;tag&quot;, &quot;content&quot; ] &#125; &#125;&#125; 我们会希望这个词条的分词词汇是分配到不同字段中的，那么就使用cross_fields123456789101112&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;我的宝马发动机多少&quot;, &quot;type&quot;: &quot;cross_fields&quot;, &quot;fields&quot;: [ &quot;tag&quot;, &quot;content&quot; ] &#125; &#125;&#125; termterm是代表完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇 1234567&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;content&quot;: &quot;汽车保养&quot; &#125; &#125;&#125; 查出的所有文档都包含”汽车保养”这个词组的词汇。 使用term要确定的是这个字段是否“被分析”(analyzed)，默认的字符串是被分析的。 拿官网上的例子举例： mapping是这样的： 12345678910111213141516171819202122PUT my_index&#123; &quot;mappings&quot;: &#123; &quot;my_type&quot;: &#123; &quot;properties&quot;: &#123; &quot;full_text&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;exact_value&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;index&quot;: &quot;not_analyzed&quot; &#125; &#125; &#125; &#125;&#125;PUT my_index/my_type/1&#123; &quot;full_text&quot;: &quot;Quick Foxes!&quot;, &quot;exact_value&quot;: &quot;Quick Foxes!&quot; &#125; 其中的full_text是被分析过的，所以full_text的索引中存的就是[quick, foxes]，而extra_value中存的是[Quick Foxes!]。 那下面的几个请求： 12345678GET my_index/my_type/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;exact_value&quot;: &quot;Quick Foxes!&quot; &#125; &#125;&#125; 请求的出数据，因为完全匹配 12345678GET my_index/my_type/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;full_text&quot;: &quot;Quick Foxes!&quot; &#125; &#125;&#125; 请求不出数据的，因为full_text分词后的结果中没有[Quick Foxes!]这个分词。 bool联合查询: must,should,must_not如果我们想要请求”content中带宝马，但是tag中不带宝马”这样类似的需求，就需要用到bool联合查询。联合查询就会使用到must,should,must_not三种关键词。 这三个可以这么理解 must: 文档必须完全匹配条件 should: should下面会带一个以上的条件，至少满足一个条件，这个文档就符合should must_not: 文档必须不匹配条件 比如上面那个需求： 12345678910111213141516&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;term&quot;: &#123; &quot;content&quot;: &quot;宝马&quot; &#125; &#125;, &quot;must_not&quot;: &#123; &quot;term&quot;: &#123; &quot;tags&quot;: &quot;宝马&quot; &#125; &#125; &#125; &#125;&#125; 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"elastic_search","slug":"elastic-search","permalink":"http://yoursite.com/tags/elastic-search/"},{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"},{"name":"search","slug":"search","permalink":"http://yoursite.com/tags/search/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"安装ES","slug":"人工智能/搜索引擎/install-es","date":"2019-03-17T01:21:17.000Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/搜索引擎/install-es/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/install-es/","excerpt":"","text":"安装ES-E Configure a setting-V, –version-d, –daemonize 守护进程，后台启动-p, –pidfile Creates a pid file in the specified path on start-q, –quiet Turns off standard output/error streams logging in console-s, –silent show minimal output-v, –verbose show verbose output 1234567891011121314151617181920# 启动(先-s 启动成功, 再用-d后台启动)elasticsearch/bin/elasticsearch -s # 配置文件elasticsearch/config/elasticsearch.yml# 检查状态curl -XGET '192.168.31.185:9200/_cat/health?v'# 测试是否启动成功curl 'http://192.168.31.185:9200/?pretty'# 查看所有索引！！curl -XGET '192.168.31.185:9200/_cat/indices?v'# 创建一个名字=ip_focus 的索引 pretty参数让返回结果更易读curl -XPUT '192.168.31.185:9200/ip_focus?pretty'# 删除一个索引curl -XDELETE '192.168.31.185:9200/customer?pretty'# 新建/修改一个文档（一行数据） _id=1 如果索引不存在，会自动新建索引=customer# 当我们没有明确指定ID的时候，我们需要使用POST方法代替PUT来发送请求PUT /customer/doc/1 &#123; \"name\": \"John Doe\" &#125; 启动时报错：elasticsearch max virtual memory areas vm.max_map_count [65530] is too low 12345sudo vim /etc/sysctl.conf # 在文件末尾加入vm.max_map_count=655360# 然后执行sudo sysctl -p 安装Kibana1234567891011121314151617去官网下载https://www.elastic.co/cn/downloads/kibana# 解压文件tar –zxvf kibana-5.5.2-linux-x86_64.tar.gz–C ./kibana/# 去config文件夹编辑kibana.yml#配置本机ip server.host: \"192.168.252.129\" #配置es集群url elasticsearch.url: \"http://192.168.252.129:9200\" # 启动程序 使用&amp;命令启动后，退出当前窗口时需要使用exit退出cd /bin./kibana &amp;访问：http://ip:port ip为kibana安装节点ip，端口默认为5061 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"elastic_search","slug":"elastic-search","permalink":"http://yoursite.com/tags/elastic-search/"},{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"},{"name":"Kibana","slug":"Kibana","permalink":"http://yoursite.com/tags/Kibana/"}]},{"title":"使用linux","slug":"编程基础/软件使用备忘/use-linux","date":"2019-03-17T01:05:41.000Z","updated":"2019-05-01T11:43:43.276Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-linux/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-linux/","excerpt":"","text":"tty终端1234# 进入tty终端Ctrl+Alt+F1 到F6 进入tty1～～tty6# 从tty回到桌面环境Ctrl+Alt+F7 Shell脚本Shell特殊变量 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 注意:$10 不能获取第十个参数，获取第十个参数需要${10} 常用shell脚本12345678910111213变量默认值#当变量a为null或为空字符串时则var=b var=$&#123;a:-b&#125; 脚本所在目录script_dir=$(cd \"`dirname $0`/.\"; pwd)关机命令sudo shutdownsudo shutdown -h 10 # 10分钟后关机sudo shutdown -h 14:15 # 希望在14:15关闭计算机sudo shutdown -c # 取消自动关机reboot # 重启电脑 常用shell函数 函数定义前可选加”function “ 函数末尾可以加：return 返回 如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值范围 0-255 123456789101112131415161718192021222324252627282930313233# 第一个echo函数demoFun()&#123; echo \"这是我的第一个 shell 函数!\"&#125;# 需要键盘输入的函数funWithReturn()&#123; echo \"这个函数会对输入的两个数字进行相加运算...\" echo \"输入第一个数字: \" read aNum echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum 和 $anotherNum !\" return $(($aNum+$anotherNum))&#125;funWithReturn# 函数返回值在调用该函数后通过 $? 来获得。echo \"输入的两个数字之和为 $? !\"# 分支if condition1then command1elif condition2 then command2else commandNfi if [ $a == $b ] # \"a 等于 b\"if [ $a -gt $b ] # \"a 大于 b\"if [ $a -lt $b ] #\"a 小于 b\" 免密码SSH登录远程服务器 创建自己的私钥和公钥对 1ssh-keygen -C “备注信息” -f ~/.ssh/私钥名称 #【密码输入空】 设置私钥对应的网站,在~/.ssh/config 文件中写入： 12345Host 远程服务器 空格链接多个地址 HostName： 目标主机地址 User：指定的登陆用户名 Port：指定的端口号(可选) IdentifyFile：指定的私钥地址(可选) 免密码SSH远程登录服务器 1ssh-copy-id -i ~/.ssh/私钥名称 远程帐号@远程服务器 把公钥文件复制到远程服务器，并输入密码后，下次就可以自动验证私钥文件 开机启动设置软件：Stacer 常用命令进程相关12345678# 查看占用内存CPUtop -p **进程ID# 查看所有进程 a=allps -ax# 查看占用socket端口的程序netstat -ap\\|grep **端口号** 文件相关1234567891011# 查看硬盘使用情况df -h# 查看当前文件夹递归1层大小/末尾可加文件夹du -h --max-depth=1# 切分并压缩文件 pre_xxx是切分文件的前缀tar cjf - file_or_dir |split -b 2000m - pre_xxx.# 合并然后解压文件 -C 输出到相对位置cat pre_xxx.* |tar xj -C ./../aim_dir/xxx_dir/ 权限相关12345# 给xxx账号设置root权限（sudo）sudo *user*mod-aG sudo xxx# 修改文件的所有者 -R表示递归目录下所有文件chown 用户名:用户组 文件名或目录名 -R 发送网络请求 curl1234567## post 方法# curl -i -X POST -H head文本 -d body_json_data# 示范如下:curl -i -X POST -H 'Content-type':'application/x-www-form-urlencoded; charset=UTF-8' -d &#123;\"json-body\":\"\"&#125; http://192.168.31.189:5858/handle/## get方法curl http://192.168.31.189:5858/ 远程挂载 说明 命令 参数 安装工具：sshfs sudo apt install sshfs 开始挂载 sshfs 用户名@host:远程目录 本地挂载点 -o -p端口 取消挂载 sudo umount -l 挂载点 取消挂载 fusermount -u 挂载点 rename perl版本程序 2个参数 参数一：’s/aaa/bbb/‘ 把aaa替换为bbb 参数二：用* 匹配1个或多个字符 rename ‘s/aaa/bbb/‘ *.json 一条命令kill某个进程1234567891011ps -aux|grep 50050|grep -v grep|cut -c 9-15|xargs kill -9# 截取输入行的第9个字符到第15个字符，而这正好是进程号PID。# xargs命令是用来把前面命令的输出结果（PID）作为“kill -9”命令的参数，并执行该命令# 用正则表达式来kill进程。而不用PIDpkill nginx# 用进程名字kill多个进程。killall nginx 1234# 新建用户sudo adduser 用户名# 增加root权限sudo usermod -aG sudo 用户名 sed-正则表达式 awk,sed都可以做字符串各种操作。 ^行的开头 $行的结尾 . 任意单个字符 * 匹配0-多次 + 匹配1次以上 ? 匹配0/1次 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"使用git","slug":"编程基础/软件使用备忘/use-git","date":"2019-03-17T01:05:30.000Z","updated":"2019-05-15T10:44:32.466Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-git/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-git/","excerpt":"","text":"gitlab使用设置保护分支(master分支不能推送) 默认的master分支是收保护的，不能直接push 进入setting—&gt;Repository—&gt;Protected Branches 设置保护分支 issue模板配置在代码文件夹中新建2个issue模板文件 12345678910111213141516171819202122.gitlab/issue_templates/bug.md 内容如下：#### 系统信息（代码版本等）#### 重现步骤#### 期望结果#### 报错信息.gitlab/issue_templates/feature.md 内容如下：#### 要解决什么问题#### 要实现什么样的功能#### 用户的应用场景是什么样的#### 注意事项（用户可能有哪些骚操作，等等）#### 对现有功能有什么影响#### 依赖什么模块 labels配置 kind（类型） kind/bug kind/新需求 priority（优先级） priority/紧急 priority/不紧急 size（工作量）：表示 issue 需要大约花费多少时间/精力，可以用来做简单的工作量评估参考。 size/0小 size/1中 size/2大 CRLF/LF/CR三种换行模式： 模式 操作系统 缩写 CRLF windows \\n\\r CR mac OSX \\r LR Linux \\n pycharm可以在状态栏显示换行符使用的模式，如下图： 点击 LF 可以切换文件的换行模式 git–AutoCRLF12345678#提交时转换为LF，检出时转换为CRLFgit config --global core.autocrlf true #windows推荐方式#提交时转换为LF，检出时不转换git config --global core.autocrlf input #提交检出均不转换git config --global core.autocrlf false #Linux/Mac推荐方式 SafeCRLF12345678#拒绝提交包含混合换行符的文件git config --global core.safecrlf true #推荐方式#允许提交包含混合换行符的文件git config --global core.safecrlf false #提交包含混合换行符的文件时给出警告git config --global core.safecrlf warn git命令行标签123456789101112131415161718192021标签分为带附注和不带附注的。我们尽量使用带附注的。# 本地新建一个tag 名称=V1.2git tag -a V1.2 -m 'xxxxx'# 查看本地taggit tag# 查看tag详细信息git tag show V1.2# 推送到远程仓库git push origin --tags# 如果发现有问题，可以删除标签（本地）git tag -d V1.2# 推送空的同名版本到远程仓库，等同于删除远程库里的版本git push origin :refs/tags/V1.2# 获取远程版本，精确拉取某一个版本的代码git fetch origin tag V1.2 在board中添加分栏Issues–&gt;Board–&gt;Add list –&gt;选择要监控的labels 本地分支和远程分支1234567891011121314# 查看当前跟踪关系git branch -vv# 克隆时自动将创建好的`master`分支追踪`origin/master`分支git clone 服务器地址# 建立本地分支 xxx, 追踪远程分支origin/yyygit checkout -b xxx origin/yyy# 将 xxx 分支追踪远程分支 origin/yyygit branch --set-upstream xxx origin/yyy# 设置当前分支跟踪远程分支 origin/yyyygit branch -u origin/yyyy 设置git默认使用的编辑器12提交是出现nano界面，可以退出后设置默认编辑器成VIMgit config --global core.editor \"vim\" 配置远程仓库的密钥 创建自己的私钥和公钥对 -C “备注信息” -f ~/.ssh/私钥名称 ``` 【密码输入空】12. 设置私钥对应的网站,在~/.ssh/config 文件中写入： Host deeplycurious.ai 多个远程仓库地址用空格分隔IdentityFile ~/.ssh/私钥名称 12345678910113. 上传公钥4. 在phabricator里个人--setting--SSH Public Keys-- SSH Key Actions -- Upload Public Key5. Name 随便取， Public Key 是你的公钥的文本内容### 强制修改分支位置```bash可以直接使用 -f 选项让分支指向另一个提交# 例如下面。将 master 分支强制指向 HEAD 的第 3 级父提交。（代码恢复到老版本）git branch -f master HEAD~3 删除git子模组/子模块123456789101112131415161718菜鸟流程:1. 把子模组文件夹剪切到项目外2. add/commit/push(删除对应文件夹)3. 然后把文件夹剪切回来4. add/commit/push(增加对应文件夹)官方流程:# 删除子模块目录及源码rm -rf 子模块目录 # 删除项目目录下.gitmodules文件中子模块相关条目vi .gitmodules # 删除配置项中子模块相关条目vi .git/config # 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可rm .git/module/* # 如果仍然报错，执行如下：git rm --cached 子模块名称 TODO: 学习 git hooks自动更新提交空文件夹 空的.gitignore文件可以作为占位符，使git只创建一个文件夹，里面是空的（一个空.ignore文件） 删除文件的git控制 如果已经加到版本控制中（push或add过）：用该命令去除控制（不删除本地文件） git rm -r –cached 文件路径 如果刚删除caehed，或未add或push过：直接设置 .gitignore 忽略即可。 .git/info/exclude 该文件和.ignore格式相同，但是不会被提交，不会影响他人的忽略名单。 忽略已加入控制的文件改动 git update-index –assume-unchanged 文件名 用户名和密码123456# 设置用户名和密码(--global全局配置,否则为本地配置)git config --global user.email \"you@example.com\"git config --global user.name \"Your Name\"# 查看用户名和密码设置命令,不写最后的文本值,即为查看 给本地代码添加远程git仓库1234567891011# 添加远程仓库 origin是git默认仓库名称git remote add origin 远程仓库地址# 重设远程仓库git remote set-url origin URL# 查看远程仓库的地址 git remote -v# 第一次推送到远程仓库（并把默认远程仓库设置为origin）git push -u origin master 修改commit注释12# 如果commit内容还未push:git commit --amend 可视化交互git学习，知识点如下 创建和切换分支1234567# 创建分支（当前分支不变）git branch newxxx# 切换当前分支到xxxgit checkout xxx# 创建并切换到newxxx分支git checkout -b newxxx rebase1234567# 当前在bugFix分支，命令会把bugFix节点的父节点指向master# C1--&gt;C2（master） 命令结果：C1--&gt;C2(master)--&gt;C3‘(bugFix*)# --&gt;C3（bugFix*） --&gt;C3git rebase master# 当前C2(master)--&gt;C3‘(bugFix*) 则指向同一个git rebase bugFix HEAD 123456789101112131415161718HEAD 是指git当前正在操作的节点指针HEAD 可以指向某个分支名，也可以指向某个节点名# 查看当前HEAD cat .git/HEAD# 查看HEAD指向的引用git symbolic-ref HEAD# 查看提交树的节点的哈希值git log# 切换HEAD指针（绝对值切换）git checkout 节点-哈希值/分支名# 切换HEAD指针（相对切换） # 使用 ^ 向上移动 1 个提交记录 git checkout master^ git checkout HEAD^ # 使用 ~&lt;num&gt; 向上移动多个提交记录，（不加数字则向上1个） git checkout master~3 修改分支位置123# -f 选项让分支指向另一个提交# 下面命令将 master 分支强制指向 HEAD 的第 3 级父提交。git branch -f master HEAD~3 恢复到merge之前123# ORIG_HEAD 是git在做危险操作时候给HEAD做的备份git reset --hard ORIG_HEAD# ORIG_HEAD 等价于 HEAD@&#123;1&#125; 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"操作系统重装记录","slug":"编程基础/安装与配置/system-record","date":"2019-03-17T00:56:59.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/安装与配置/system-record/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/system-record/","excerpt":"","text":"警告 应该备份.ssh文件夹, 重装后将消失 Ubuntu 重装记录 chrome插件 SwitchyOmega 有道词典Chrome划词插件 LingoCloud （彩云小译） smartUp Gesture （手势） Tampermonkey （油猴） 有道云笔记网页剪报 360浏览器 插件360屏幕截图 Adblock Super Proxy SwitchyOmega Tampermonkey 彩云小译 截图助手 有道云笔记网页剪报 有道划词翻译 油猴脚本导出文件（tampermonkey-backup-chrome-2019-03-13T01-41-21.545Z.zip） Omega备份文件 adblock备份文件 3、把ubuntu的设置记录下来 安装Tweaks(Ubuntu软件商店–GNOME Tweaks) https://extensions.gnome.org/ aifish f1 插件 Activities configurator 1.3 Scale Icon 0 Icon Padding ON Hide Text 6 Text Padding 100 Hot Corner Threhold 100 Panel Transparency 黑色 Panel Shadow Color 100 Transparency 0 Vertical Length 0 Spread Radius OFF Move Activities to the Right ON Enable Conflict Detection Clipboard indicator Places status indicator Drop down terminal（没怎么用过） 3、常用软件记录 typora pycharm vscode 插件 Beautify Better TOML TOML Language Support Docker Encode Decode Gitlens Image preview JavaScript (ES6) code snippets Mithril Emmet Prettier - Code formatter Project Manager Python Terminal Vetur wps 搜狗输入法 百度云（deepin） postman meld（文本对比） systemMonitor（系统监控器，进程、文件夹监控） virtuaBox（虚拟机） 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"配置vim","slug":"编程基础/安装与配置/set-vim","date":"2019-03-17T00:56:04.000Z","updated":"2019-04-08T01:15:48.071Z","comments":true,"path":"wiki/编程基础/安装与配置/set-vim/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/set-vim/","excerpt":"","text":"vim配置（linux/manjaro/ubuntu/deepin通用）1234567891011121314151617181920212223242526272829303132333435363738sudo pacman -S vim\":关闭与vi的兼容模式set nocompatible \":显示行号set number \":显示匹配的括号set showmatch \":距离顶部和底部3行set scrolloff=3 \":编码set encoding=utf-8 set fenc=utf-8 \"编码设定Encodingset fileencoding=utf-8set fileencodings=utf-8,gbk,utf-16,big5 set langmenu=zh_CN.UTF-8source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.UTF-8\"忽略大小写检索set ignorecase\":搜索高亮set hlsearch \"输入检索时动态变化set incsearch\":语法高亮syntax on \":命令显示历史set history=500\"开启插件和缩进filetype plugin indent on\":鼠标set autoreadset mouse=set mousehide bug: backspace退格键不能使用把 deleteleft 快捷键设置会 backspace 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"配置和使用 pycharm","slug":"编程基础/python/pycharm","date":"2019-03-17T00:55:57.000Z","updated":"2019-04-25T11:40:54.468Z","comments":true,"path":"wiki/编程基础/python/pycharm/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/pycharm/","excerpt":"","text":"配置常用代码片段配置 配置路径 Setting—&gt;Editor—&gt;Live Templates—&gt;加号按钮 12345678910111213# ~errerror = '\\n'.join(traceback.format_exception(*sys.exc_info()))# ~rootdef root(*f, relative_root='../../../'): # relative_root 当前代码目录相对root的相对路径 for t in f: if t[:1] == '/': print('Warning: root()包含绝对路径 参数=&#123;&#125;'.format(f)) break code_dir = os.path.dirname(os.path.realpath(__file__)) long_path = os.path.join(code_dir, relative_root, *f) return long_path 快捷键配置Keymap—方案设置成NetBeans 名称 快捷键 说明 Reformat Ctrl+Alt+L 需设置 Code格式化代码 Move Line Up Alt+Up 需设置 当前行往上挪一行 Move Line Down Alt+Down 需设置 当前行往上挪一行 Optimize Imports Ctrl+Shift+I 优化导入代码 Ctrl+F12 跳转到方法（列表） Ctrl + F11 设置书签 SHIFT F11 显示所有书签 Go to Bookmark 1 Ctrl+Alt+1 需设置 跳转到 该书签 Next Bookmark Ctrl+Shift+. 跳转到下个书签 Previous Bookmark Ctrl+Shift+逗号 跳转到上个书签 跳转到上个光标所在位置​ 打开 View—toolbar 有左右箭头按钮。悬停可以查看快捷键 插件File—Setting—Plugins 数据库插件： ​ 搜索datebase ​ 安装 Database Navigator ​ 安装Mongo Plugin ​ 显示界面和字体配置12界面的字体大小：Setting--&gt;Appearance&amp;Behavior--&gt;Appearance--&gt;Use custom font 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"安装ubuntu","slug":"编程基础/安装与配置/install-ubuntu","date":"2019-03-17T00:55:46.000Z","updated":"2019-05-01T11:43:43.276Z","comments":true,"path":"wiki/编程基础/安装与配置/install-ubuntu/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/install-ubuntu/","excerpt":"","text":"一 安装系统安装thefuck1234sudo apt install thefuckthefuck -a f # 获取alias文本， 别名=f（可以自己设定）把alias文本设置到.bashrc内 安装tldr （太长不看，查看linux命令行帮助信息的工具）123sudo pip install tldr# 查看tar的帮助信息tldr tar 安装docker123456789sudo apt install docker.io# 创建文件 /etc/docker/daemon.json 增加私有镜像仓库&#123; \"insecure-registries\" : [\"192.168.31.103:5000\"]&#125;sudo systemctl restart docker 制作启动盘12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 查看硬盘列表sudo fdisk -l# 结果依次显示每个硬盘的信息，可知 /dev/sdb就是优盘Disk /dev/nvme0n1：232.9 GiB，250059350016 字节，488397168 个扇区Disk model: Samsung SSD 970 EVO 250GB 单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：gpt磁盘标识符：C56964F0-A438-4609-8521-BB80B61A498F设备 起点 末尾 扇区 大小 类型/dev/nvme0n1p1 109258752 488392031 379133280 180.8G Linux 文件系统/dev/nvme0n1p2 4196352 4401151 204800 100M Linux 文件系统/dev/nvme0n1p3 4401152 109258751 104857600 50G Linux 文件系统/dev/nvme0n1p4 2048 616447 614400 300M EFI 系统/dev/nvme0n1p5 616448 4196351 3579904 1.7G Linux swap分区表记录没有按磁盘顺序。Disk /dev/sda：1.8 TiB，2000398934016 字节，3907029168 个扇区Disk model: WDC WD20EZAZ-00G单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 4096 字节I/O 大小(最小/最佳)：4096 字节 / 4096 字节磁盘标签类型：gpt磁盘标识符：B6164008-B283-4767-831C-8784AB8854F7设备 起点 末尾 扇区 大小 类型/dev/sda1 2048 835022847 835020800 398.2G Linux 文件系统/dev/sda2 835022848 3907024031 3072001184 1.4T Linux 文件系统Disk /dev/sdb：14.4 GiB，15483273216 字节，30240768 个扇区Disk model: DataTraveler 2.0单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0x3fbeba85设备 启动 起点 末尾 扇区 大小 Id 类型/dev/sdb1 * 0 4774783 4774784 2.3G 0 空/dev/sdb2 4774784 4929791 155008 75.7M 1 FAT12# 创建启动盘： if=镜像文件 of=优盘盘符路径sudo dd if=/home/fish/下载/deepinamd64.iso of=/dev/sdb 二 安装软件12345678910111213141516171819202122232425262728293031323334353637383940414243卸载软件命令： apt-get remove softname1 softname2 softname3……卸载并清除配置命令： apt-get remove --purge softname1更新软件信息数据库命令： apt-get update进行系统升级命令： apt-get upgrade搜索软件包命令： apt-cache search softname1 softname2 softname3……安装deb软件包命令： dpkg -i xxx.deb删除软件包命令： dpkg -r xxx.deb连同配置文件一起删除命令： dpkg -P xxx.deb (purge)查看软件包信息命令： dpkg -info xxx.deb查看文件拷贝详情命令： dpkg -L xxx.deb查看系统中已安装软件包信息命令： dpkg -l重新配置软件包命令： dpkg-reconfigure xxx 科学上网1234567# 安裝ss的命令行工具sudo apt install shadowsockssslocal -c xxx.json# 浏览器安装科学插件# 找到chrome执行程序目录，加代理启动，安装 SwitchyOmega插件./chrome --proxy-server='socks5://127.0.0.1:1080' 开机启动：打开“启动应用程序”添加命令-clink1234567891011121314151617181920212223242526272829303132333435363738394041424344其中命令和配置文件需要全局路径### 设置开机自启动的内容```bash# 建立 /etc/systemd/system/rc-local.service 文件内容如下：_________________________________________________[Unit]Description=/etc/rc.local CompatibilityConditionPathExists=/etc/rc.local [Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0StandardOutput=ttyRemainAfterExit=yesSysVStartPriority=99 [Install]WantedBy=multi-user.target_________________________________________________# 创建启动命令脚步文件 /etc/rc.local——————————————————————————————————————————————————#!/bin/sh -eecho &quot;看到这行字，说明添加自启动脚本成功。&quot; &gt; /usr/local/test.logexit 0——————————————————————————————————————————————————# 添加权限sudo chmod +x /etc/rc.local# 开机启动服务sudo systemctl enable rc-local# 启动服务并检查状态sudo systemctl start rc-local.servicesudo systemctl status rc-local.service# 修改service配置文件后，重载sudo systemctl daemon-reload# 查看日志cat /usr/local/test.log 开启ssh服务 12345678sudo apt install openssh-serversudo systemctl restart sshd# 设置不允许root帐号登录 修改文件 /etc/ssh/sshd_config PermitRootLogin no# 重启sshd服务sudo systemctl restart sshdsudo systemctl enable sshd 安装git git-lfs12345678910# 安装gitsudo apt install git# 安装git-lfs ########### ubuntu## 1. 设置url源curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash## 2. 安装lfssudo apt-get install git-lfs## 3. 初始化git lfs install 安装google输入法(不好用)12sudo apt-get install fcitx-googlepinyin然后注销再登陆操作系统 安装搜狗输入法 123456789101. 去搜狗拼音官网,下载linux版本安装文件(.deb)2. 双击打开界面安装3. 登出后登录操作系统4. 右键点击顶栏的键盘图标，选择配置5. 添加搜狗输入法如果候选栏显示乱码、无法显示中文，可按如下方式处理：cd ~/.configrm -rf SogouPY* sogou*然后重启后登录即可。 安装zsh 和 autojump12345678910111213sudo apt install zshsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"重启操作系统后终端变成zsh如果要切换回去bashchsh -s /bin/bash# 安裝autojumpgit clone git://github.com/wting/autojump.gitcd autojump./install.py or ./uninstall.py手工把提示腳本添加到 ~/.zshrc 安装WPS去wps官网下载deb文件，双击后安装。 然后下载font文件：链接如下 国内地址 国外地址 1234567#a. 将得到文件复制到/usr/share/fontssudo cp * /usr/share/fonts#b. 执行以下命令,生成字体的索引信息sudo mkfontscalesudo mkfontdir#c. 更新字体缓存sudo fc-cache 安装node/npm1234567# 1. 安装默认版本sudo apt-get install npm# 2. 安装版本管理工具sudo npm install -g n# 3. 安装对应版本sudo n latest #最新版本sudo n stable #最新的稳定版本 安装ssh服务123456789101112131415161718192021222324sudo apt install openssh-serversudo systemctl start sshdsudo vim /etc/ssh/sshd_config # 关闭root用户登录PermitRootLogin nosudo systemctl restart sshdwangxiaoyu@dc5:~$ ssh xxxxx@192.168.31.68@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:yHxBrXIZ6upZaOPDf3PcaOO+aaEthNQiw4O4CCt7gSM.Please contact your system administrator.Add correct host key in /home/wangxiaoyu/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /home/wangxiaoyu/.ssh/known_hosts:14 remove with: ssh-keygen -f \"/home/usr1/.ssh/known_hosts\" -R 192.168.31.68 目标ssh服务器重装系统后，远程登录时会报错。使用报错信息里的remove with 后面的命令即可清除报错ssh-keygen -f \"/home/usr1/.ssh/known_hosts\" -R 192.168.31.68 安装chrome1234567sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -sudo apt updatesudo apt install google-chrome-stable 安装deepin的百度云、截图和终端123456# 百度云 安装失败！https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu# 截图、深度终端在ubuntu软件上级搜索 dee 安装和挑选终端123sudo apt install xfce4-terminalterminator #gnomekonsole 配置Gnome界面123456sudo apt install chrome-gnome-shellsudo apt install gnome-tweak-tool打开Ubuntu软件商店安装：GNOME Tweakshttps://extensions.gnome.org/ 账号aifish f1使用火狐浏览器安装插件 使用chrome打开： 使用火狐打开： 点击安装插件 Click here to install browser extension 安装gnome插件User Themes Clipboard Indicator topbar剪贴板列表 Recent Items topbar最近文件夹 Places Status Indicator topbar文件夹收藏 Datetime Format topbar显示日期 配置格式：%b-%d %A %R 快捷键设置 快捷键 配置路径 说明 Super+E 启动器—主目录 文件管理器 Super+D 导航—隐藏所有正常窗口 回到桌面 Super+W 启动网页浏览器 设置开机时自动登录设置—详细信息—用户—自动登录 alias配置123alias get1='pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ 'alias get2='pip install -i http://mirrors.aliyun.com/pypi/simple/ 'alias get3='pip install -i https://pypi.douban.com/simple/ ' 使用xfce界面安装 123sudo apt-get install xfce4 注销当前账号在输入密码界面，选择不同的界面系统 界面设置 安装LXDE安装 12345678LXDE有很多定制版，可任选# Lubuntu定制LXDE和vanilla LXDE（实际安装不成功，缺少依赖）# sudo apt-get install lubuntu-desktop# 香草LXDEsudo apt-get install lxde# 选择使用lightdm（见图） （gdm3 快捷键报错cannot configure keys remotely）如果设置错了也可以切换lightdmsudo dpkg-reconfigure lightdm # sudo dpkg-reconfigure gdm3 设置数字时钟格式：%b-%d %A %R设置快捷键：菜单—首选项—set hot key 功能 快捷键 说明 文件管理器 Win+E 默认有 显示桌面 Win+D 默认有 锁屏 Win+L lxlock 打开浏览器 Win+W browser360 打开终端 Win+T lxterminal 或 deepin-terminal vscode Win+V code pycharm Win+P 打开pycharm–Tools–Create CMD line typora Win+M typora 截图 Ctrl+Shift+Print deepin-screenshot 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"安装manjaro","slug":"编程基础/安装与配置/install-manjaro","date":"2019-03-17T00:55:36.000Z","updated":"2019-04-12T10:56:11.964Z","comments":true,"path":"wiki/编程基础/安装与配置/install-manjaro/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/install-manjaro/","excerpt":"","text":"零. 个人使用体验只使用了一周，还不太熟悉。再尝试一周，如果没有什么特别的优点就换成deepin试试。 优点 硬件支持好 软件版本非常新（滚动更新） 缺点 缺少软件360浏览器 对中文支持较差，需要自己配置的内容较多 很多软件都是deepin的，例如微信和naivicat（那我为什么不直接用deepin呢） 一. 安装manjaro系统二. 中文相关配置注意事项如果代码更新一直等待状态可以尝试删除/var/lib/pacman/db.lck 配置镜像源 测试国内的镜像源1sudo pacman-mirrors -i -c China -m rank 设置 archlinuxcn 源1234567891011# 修改 /etc/pacman.conf 添加以下内容[archlinuxcn]SigLevel = Optional TrustedOnlyServer = http://repo.archlinuxcn.org/$arch## 添加cn源签名key(这步不做，会报签名错误）sudo pacman -S archlinuxcn-keyring# 完成后执行下面的命令使配置生效## 更新源列表sudo pacman-mirrors -g## 更新pacman数据库并全面更新系统sudo pacman -Syyu #（必须先更新系统，不然无法安装输入法） 使界面可以输入中文123456在~/.xprofile中添加export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx如果还是无法使用，可能需要安装fcitx-gtk2sudo pacman -S fcitx-gtk2 把系统界面设置为中文1234点击设置--Manjaro Settings Manager--本地化设置：添加 中国-中文，然后在语言包中点击安装软件包在~/.xprofile中添加export LC_ALL=\"zh_CN.UTF-8\"export LANG=zh_CN.UTF-8 三. 安装软件和系统配置安装yay1234# 1. 下载代码git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si 安装git12sudo pacman -S gitsudo pacman -S git-lfs 安装 wps12sudo pacman -S wps-officesudo pacman -S ttf-wps-fonts 安装 typora1234567891011121314## 下载二进制文件（x64） 解压https://www.typora.io/#linux## 创建程序的软链接sudo ln -s /home/fish/soft/Typora-linux-x64/Typora /usr/bin/typora## 编辑/usr/share/applications/typora.desktop 文件[Desktop Entry]Version=1.0Terminal=falseIcon=/home/fish/soft/Typora-linux-x64/resources/app/asserts/icon/icon_256x256.pngType=ApplicationCategories=Office;Exec=/home/fish/soft/Typora-linux-x64/Typora %UName=TyporaComment=MarkDown Editor 安装node/npm1234sudo pacman -S nvm nvm install --latest-npm然后把/home/fish/.nvm/versions/node/v11.12.0/bin添加到系统路径 安装jdk123456sudo pacman -S jdk8# 配置环境export JAVA_HOME=/usr/lib/jvm/defaultexport JRE_HOME=$&#123;JAVA_HOEM&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib 命令简单安装： vscode/ vim/ 微信/ shadownsocks/ 网易云音乐/ qq/ chrome/docker12345678sudo pacman -S codesudo pacman -S electronic-wechat （网页版不能复制粘帖图片）sudo pacman -S shadownsocks-qt5sudo pacman -S vimsudo pacman -S netease-cloud-music # 网易云音乐sudo pacman -S deepin.com.qq.office # 可以先搜索qq 看看版本sudo pacman -S google-chromesudo pacman -S docker 安装下载工具Gwget12打开系统工具：添加/删除软件搜索工具后下载 百度云下载1234567打开系统工具：添加/删除软件：安装baidupcs-go-git说明：https://github.com/iikira/BaiduPCS-Go# 进入命令交互工具baidupcs# 帮助help 安装截图工具123sudo pacman -S deepin-screenshot添加快捷键： deepin-screenshot 安装zsh autojump1234567# zshsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"# autojump（zsh设置ubuntu通用）sudo pacman -S autojump再在~/.zshrc中添加: plugins=(git autojump) 安装googlepinyin谷歌拼音123456sudo pacman -S fcitx-im fcitx-configtool fcitx-googlepinyinsudo vim ~/.xprofile 输入下面命令：exportGTK_IM_MODULE=fcitxexportQT_IM_MODULE=fcitxexportXMODIFIERS=\"@im=fcitx\" 安装搜狗拼音12345678910# 前置：设置中国软件源sudo pacman -S fcitx-im #默认全部安装sudo pacman -S fcitx-configtoolsudo pacman -S fcitx-sogoupinyin在~/.xprofile添加如下内容：export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 关闭ssh远程root登录1234# 设置不允许root帐号登录 修改文件 /etc/ssh/sshd_config PermitRootLogin no# 重启sshd服务sudo systemctl restart sshd 安装pycharm（ubuntu通用）12341.下载并解压pycharm.tar文件2.进入bin文件夹3.执行./pycharm.sh4.打开pycharm，在菜单栏选择tool---&gt;添加桌面快捷方式 时间显示设置操作：右键点击任务栏右下角的时间，选择属性：tips配置：%m-%d %j/365 第%V周时钟配置：周%u %H:%M ### 切换deepin桌面12# 安装桌面，然后重启电脑，选择桌面sudo pacman -S deepin deepin-extra lightdm 参考arch-wiki chrome安装插件 去官网下载插件文件 xxx.crx 去http://crxextractor.com/ 网站上传crx文件，获得zip文件 解压zip文件获得一个文件夹 打开chrome，打开开发者模式，加载已解压的扩展程序，选中解压文件夹，安装即可 四. 常用快捷键Ctrl+Alt+D 回到桌面（在设置界面里看不见这个快捷键，但是超级方便） Ctrl+Alt+F exo-open –launch FileManager 打开文件管理器 我改成了 Super ECtrl+Alt+M xfce4-taskmanager 资源监控器Ctrl+Alt+Delete xflock4 锁屏并黑屏Ctrl+Alt+X xkill 通过鼠标关闭某个程序新增： Ctrl+Alt+Q xfce4-terminal 终端Ctrl+H 文件管理器，显示隐藏文件 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"py2_and_py3","slug":"编程基础/python/py2-and-py3","date":"2019-03-17T00:39:15.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/python/py2-and-py3/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/py2-and-py3/","excerpt":"","text":"感受: 实际上还是不好用～～～能用3就用3～～～_future__python3出来的时候，python的设计者们当然也考虑过代码之间的兼容问题。许多为为兼容性设计的功能可以通过future这个包来导入。例如： 123456789101112# 使用python3的print函数，禁用python2的print语句。from __future__ import print_function# 导入该特征，代码中的文本变量默认是Unicode（如果不导入python2的文本变量默认是str）# python2 str.decode('utf8') --&gt; Unicodefrom __future__ import unicode_literals# 参见PEP 328 -- Imports: Multi-Line and Absolute/Relativefrom __future__ import absolute_import# 像python3一样，int除以int得float，而不像Python2那样是整除from __future__ import division six 字符串类型 文本 字节 python2 unicode str python3 str bytes six six.text_type six.binary_type 1234567891011# python2if isinstance(xxx, unicode): pass # 兼容python2和python3import sixif isinstance(xxx, six.text_type): pass## 使用input代替raw_inputfrom six.moves import input 判断版本写不同的内容if sys.version&gt;’3’: pass 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"兼容性","slug":"兼容性","permalink":"http://yoursite.com/tags/兼容性/"},{"name":"python版本","slug":"python版本","permalink":"http://yoursite.com/tags/python版本/"}]},{"title":"decorator装饰器","slug":"编程基础/python/decorator装饰器","date":"2019-03-17T00:38:37.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/python/decorator装饰器/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/decorator装饰器/","excerpt":"","text":"最简单的模板是这样的1234567891011def outer(func): def inner(): print 'before' func() print 'after' # return r return inner@outerdef F1(): print 'test' 函数带多个参数，装饰器对应修改以适合多种情况12345678910def ftfunc(func): def timef(*s,**gs): print \"[%s] %s() called\" % (ctime(),func.__name__) return func(*s,**gs) return timef@ftfuncdef foo(*s,**gs): print(s) print(gs) 函数带多个参数，装饰器也带多个参数123456789101112def decrator(*dargs, **dkargs): def wrapper(func): def _wrapper(*args, **kargs): print \"decrator param:\", dargs, dkargs print \"function param:\", args, kargs return func(*args, **kargs) return _wrapper return wrapper@decrator(1, a=2)def foo(x, y=0): print \"foo\", x, y 函数带多个参数，装饰器能转换参数类型1234567891011121314def validate(**vkargs): def decorator(func): def wrapper(**kargs): for key in vkargs: # 根据vkargs中的参数的类型对kargs的参数进行类型转换 kargs[key] = vkargs[key](kargs[key]) return func(**kargs) return wrapper return decorator@validate(x=int, y=float, z=float)def move(x, y, z): print \"move %d (%0.2f, %0.2f)\"%(x, y, z) 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"decorator","slug":"decorator","permalink":"http://yoursite.com/tags/decorator/"},{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]},{"title":"elastic_search基础","slug":"人工智能/搜索引擎/elastic-search基础","date":"2019-03-05T02:39:39.000Z","updated":"2019-05-19T10:17:25.169Z","comments":true,"path":"wiki/人工智能/搜索引擎/elastic-search基础/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/elastic-search基础/","excerpt":"","text":"Document元数据（MetaData）元数据用于标注文档的相关信息： _index：文档所在的索引名_type：文档所在的类型名_id：文档的唯一id_uid：组合uid，由_type和_id组成（6.x中_type不再起作用，同_id一样）_source：文档的原始json数据，可以从这里获取每个字段的内容_all：整合所有字段内容到该字段，默认禁用 Mappings创建索引时，设定mappings1234567891011121314151617181920PUT $host:$port/$indexbody = &#123; \"settings\": &#123; \"number_of_shards\": 1, //分片节点数量 \"number_of_replicas\": 0, //复制节点数量 &#125;, \"mappings\": &#123; \"_doc\": &#123; \"properties\": &#123; \"txt\": &#123; \"type\": \"text\", \"analyzer\": \"ik_smart\" // ik-分词器 &#125; &#125; &#125; &#125;&#125;analyzer可选: \"standard\", \"ik_smart\", \"english\"如果body=&#123;&#125; 那么就使用ES的自动mappings 字段的数据类型： 简单类型：text, keyword, date, long, double, boolean or ip. json层级类型：object or nested. 专有类型：geo_point, geo_shape, or completion. ## 查看全局的信息查看ES版本1GET $host:$port/ 查看ES安装的插件列表1GET $host:$port/_cat/plugins # 返回的文本（不是json） 搜索操作搜索所有文档12345678# 某索引的某个类型的所有文档GET $host:$port/$index/$type/_search# 某索引的所有文档GET $host:$port/$index/_search# ES所有文档GET $host:$port/_search 搜索符合条件的文档12345678910111213# 某索引的某个类型的所有文档POST $host:$port/$index/$type/_searchbody = &#123; \"query\": query \"from\": 0, // 从0开始 \"size\": 20, // 取20个 \"sort\": [ &#123;\"age\": &#123;\"order\": \"asc\"&#125;&#125; //asc升序 dsc降序 ] \"_source\" : [\"key1\", \"key2\"] // 返回信息包含的键&#125;query = &#123;\"match_all\": &#123;&#125;&#125; // 搜索全部 基础查询种类数值符合范围12345678910111213141516171819query = &#123; \"range\": &#123; \"字段名\": &#123; \"gte\": 20000, // gte是&gt;= gt是&gt; \"lte\": 30000, // lte是&lt;= lt是&lt; \"boost\": 1.5 // 分数权重 &#125; &#125; &#125;query = &#123; \"range\": &#123; \"字段名\": &#123; \"from\": 20000, \"to\": 30000, \"boost\": 1.5 // 分数权重 &#125; &#125;&#125; 词项匹配（不进行分词处理）1234567891011query = &#123; \"term\": &#123; \"_id\": \"ZUd6zmoBr51spxZUlcFQ\" &#125;&#125;query = &#123; \"terms\": &#123; \"featrue\": [\"盗窃\", \"自首\"] //或的关系 &#125;&#125; 短语匹配（先分词，再查询分词结果和位置顺序都对的文档）12345query = &#123; \"match\": &#123; \"txt\": \"关键词\" &#125;&#125; 前缀匹配1234567query = &#123; \"match_phase_prefix\": &#123; \"name\": &#123; \"query\": \"赵\" &#125; &#125;&#125; nested查询（数组元素是对象，查询符合条件的对象）1234567891011121314151617query = &#123; \"nested\":&#123; \"path\": \"字段1\", \"query\": &#123; // 可以是任意query \"match\": &#123; \"字段1.字段2\": \"关键词\" //注意key需要有前置路径 &#125; &#125; &#125;&#125;# 文档结构是：&#123;\"字段1\": // nested对象 [ &#123;\"字段2\"： \"文本内容\"&#125; ] &#125; bool查询12345678query = &#123; \"bool\" : &#123; \"must\" : [ # must 且 should 或 &#123;\"term\": &#123;\"price\": 25&#125; &#125; // query ], \"filter\" : filter &#125;&#125; filter12345filter = &#123; \"exists\": &#123; # 存在字段 \"filed\": \"price\" &#125;&#125; 数据查询数据删除数据123456789101112131415161718192021222324252627282930# es参考版本：elasticsearch：5.5# _delete_by_query会删除所有query语句匹配上的文档，用法如下：curl -X POST \"localhost:9200/twitter/_delete_by_query\" -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"match\": &#123; \"name\": \"测试删除\" &#125; &#125;&#125;# 其中twitter是索引名称# 因为internal版本控制不支持0为有效数字，所以版本号为0的文档不能删除，并且请求将会失败。# 删除多个索引(twitter,blog)的多个type(_docs,post)curl -X POST \"localhost:9200/twitter,blog/_docs,post/_delete_by_query\" -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125;# 出自上向下删除1000条数据curl -X POST \"localhost:9200/twitter/_delete_by_query?scroll_size=1000\" -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"term\": &#123; \"user\": \"kimchy\" &#125; &#125;&#125; 参考资料 Elasticsearch删除数据之_delete_by_query","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"elastic","slug":"elastic","permalink":"http://yoursite.com/tags/elastic/"},{"name":"elastic_search","slug":"elastic-search","permalink":"http://yoursite.com/tags/elastic-search/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yoursite.com/tags/elasticsearch/"},{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"}]},{"title":"hexo","slug":"编程基础/博客工具/hexo","date":"2019-02-28T08:49:08.000Z","updated":"2019-03-25T00:13:36.116Z","comments":true,"path":"wiki/编程基础/博客工具/hexo/","link":"","permalink":"http://yoursite.com/wiki/编程基础/博客工具/hexo/","excerpt":"","text":"安装hexo1sudo npm install hexo-cli -g 图片显示123456789101112# 配置资源文件夹# hexo n xxx 会生成同名文件夹,# hexo g 会把同名文件夹内图片打包生成静态文件_config.yml里的post_asset_folder，改成true# 安装插件npm install hexo-asset-image --save# 设置typora编辑器# 图片插入路径= ./$&#123;filename&#125;# 优先使用相对路径在typora编辑器内粘贴图片时会自动把图片存储到同名文件夹 主题配置hexo-theme-Wikitten Github地址 部署hexo123456789# 进入blog目录hexo init# 启动服务器hexo serverhexo server -p 8080 # -p 端口# 生成静态文件hexo generate | hexo g` 插件自动生存目录树 categorieshexo-auto-category 1234567891011# 安装npm install hexo-auto-category --save# 在站点根目录下的_config.yml添加：# 自动生成目录树categories (depth层级上限)auto_category: enable: true depth: # 使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 绑定域名1234A (Address) 记录是域名到ip的映射，即为ip起别名CNAME是域名别名到域名的映射，即为域名起别名。政策导致国内无法绑定到github~~ 参考资料 Hexo 的个人 Wiki 主题 - Wikitten hexo-theme-Wikitten github地址 hexo中文官方文档","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"博客工具","slug":"编程基础/博客工具","permalink":"http://yoursite.com/categories/编程基础/博客工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"wiki","slug":"wiki","permalink":"http://yoursite.com/tags/wiki/"}]},{"title":"mongo","slug":"编程基础/数据库/mongo","date":"2019-02-28T08:41:56.000Z","updated":"2019-03-20T10:39:12.430Z","comments":true,"path":"wiki/编程基础/数据库/mongo/","link":"","permalink":"http://yoursite.com/wiki/编程基础/数据库/mongo/","excerpt":"","text":"### 服务器服务器启用mongo集群1234567891011121314151617181920212223242526# 进入mongo客户端mongo# 以下操作是在mongo客户端命令行内：# 创建集群，集群名字=“rs0”rs.initiate( &#123; _id: \"rs0\", members: [ &#123; _id: 0, host: \"mongo-r0:27017\" &#125;, &#123; _id: 1, host: \"mongo-r1:27017\" &#125;, &#123; _id: 2, host: \"mongo-r2:27017\" &#125; ] &#125;)# 查看集群状态rs.conf()rs.status() mongo客户端使用登录/验证/切换数据库12# 进入mongo客户端mongo 客户端模块调用pymongo/motor调用mongo集群当 mongo 是集群时，客户端连接时需要设置好要连接的所有 mongo 节点。 12345import pymongo# uri里的“rs0”是集群名称，前面是每个节点的IP和端口uri = 'mongodb://mongo-r0:27017,mongo-r1:27017,mongo-r2:27017/?replicaSet=rs0'conn = pymongo.MongoClient()[i for i in conn.list_databases()] 注释：pymongo和motor连接时使用的uri字符串可以是相同的，因为motor实际是调用pymongo实现的。 集群–官方文档 参考资料 官方文档","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"数据库","slug":"编程基础/数据库","permalink":"http://yoursite.com/categories/编程基础/数据库/"}],"tags":[{"name":"mongo","slug":"mongo","permalink":"http://yoursite.com/tags/mongo/"}]},{"title":"markdown说明","slug":"编程基础/博客工具/markdown说明","date":"2019-02-27T07:03:45.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/博客工具/markdown说明/","link":"","permalink":"http://yoursite.com/wiki/编程基础/博客工具/markdown说明/","excerpt":"","text":"$x^p_ {ij}$ 其中i表示第i个标签 $x^p_ {ij}$ 上标$^2$ 下标$_ 2$","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"博客工具","slug":"编程基础/博客工具","permalink":"http://yoursite.com/categories/编程基础/博客工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"pytorch功能","slug":"人工智能/深度学习/pytorch功能","date":"2019-02-26T07:00:45.000Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/深度学习/pytorch功能/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/pytorch功能/","excerpt":"","text":"计算 功能 代码 P范数（N方求和后开方） torch.norm(input, p=2) 指定GPU（3种方式） 123torch.cuda.set_device(id)os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;2&quot;CUDA_VISIBLE_DEVICES=1 python main.py 网络层","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"}]},{"title":"基础库：os/sys/dis","slug":"编程基础/python/基础库","date":"2019-02-26T07:00:45.000Z","updated":"2019-03-19T06:14:46.097Z","comments":true,"path":"wiki/编程基础/python/基础库/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/基础库/","excerpt":"","text":"常用功能 功能 代码 参数 判断文件是否存在 os.path.isfile(path) 判断文件或文件夹是否存在 os.path.exists(path) 判断文件权限 os.access(path, mode) os.F_OK存在 os.R_OK可读 os.W_OK:可写os.X_OK可执行 判断文件夹存在 os.path.isdir(dir) 得到当前工作目录 os.getcwd() 删除文件 os.remove() 列出目录里的文件夹和文件 os.listdir(dir) 改变工作目录到dirname os.chdir(dirname) https://www.cnblogs.com/wq242424/p/5803721.html dis – 查看解释器得出的执行码123import dis# fn 是想查看执行码的函数名print(dis.dis(fn))","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"os","slug":"os","permalink":"http://yoursite.com/tags/os/"},{"name":"sys","slug":"sys","permalink":"http://yoursite.com/tags/sys/"},{"name":"dis","slug":"dis","permalink":"http://yoursite.com/tags/dis/"},{"name":"python基础库","slug":"python基础库","permalink":"http://yoursite.com/tags/python基础库/"}]}]}