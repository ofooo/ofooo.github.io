{"meta":{"title":"AIfish","subtitle":"think how to think","description":"NLP AI","author":"aifish","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About Me","date":"2019-03-27T06:54:06.363Z","updated":"2019-03-27T06:54:06.363Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"王晓宇研究方向：自然语言处理 微信二维码： github: https://github.com/ofooo 博客: https://ofooo.github.io 邮箱: ofyu@163.com"},{"title":"Tags","date":"2019-03-18T02:07:20.002Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-03-18T02:07:20.002Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"allennlp 类","slug":"人工智能/深度学习/allennlp/allennlp-classes","date":"2019-03-31T12:14:52.000Z","updated":"2019-04-01T14:12:35.640Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-classes/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-classes/","excerpt":"","text":"allennlp.data.token_indexers.TokenIndexerallennlp.data.token_indexers.single_id_token_indexerallennlp.common.util.get_frozen_and_tunable_parameter_namesallennlp.common.params.Paramsallennlp.training.trainer.Trainerallennlp.models.archival.archive_modelallennlp.data.iterators.data_iteratorallennlp.models.modelallennlp.data.vocabularyallennlp.data.dataset_reader 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[]},{"title":"allennlp 命令","slug":"人工智能/深度学习/allennlp/allennlp-command","date":"2019-03-31T11:09:04.000Z","updated":"2019-04-01T14:12:35.640Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-command/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-command/","excerpt":"","text":"12345678# 训练# -r就会使用之前已经创建好的词典allennlp train XXX -s XXX# 启动配置助手(网页)allennlp configure --port 8123 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[{"name":"allennlp","slug":"allennlp","permalink":"http://yoursite.com/tags/allennlp/"},{"name":"command","slug":"command","permalink":"http://yoursite.com/tags/command/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"allennlp_json_config","slug":"人工智能/深度学习/allennlp/allennlp-json-config","date":"2019-03-31T11:04:31.000Z","updated":"2019-04-01T14:12:35.640Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-json-config/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-json-config/","excerpt":"","text":"第一层配置1234567&#123; \"dataset_reader\": &#123;&#125;, \"train_data_path\": \"\", \"model\": &#123;&#125;, \"iterator\": &#123;&#125;, \"trainer\": &#123;&#125;&#125; 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[{"name":"allennlp","slug":"allennlp","permalink":"http://yoursite.com/tags/allennlp/"},{"name":"配置文件","slug":"配置文件","permalink":"http://yoursite.com/tags/配置文件/"}]},{"title":"allennlp_models","slug":"人工智能/深度学习/allennlp/allennlp-models","date":"2019-03-29T09:29:52.000Z","updated":"2019-04-01T14:12:35.640Z","comments":true,"path":"wiki/人工智能/深度学习/allennlp/allennlp-models/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/allennlp/allennlp-models/","excerpt":"","text":"Coreference Resolution 指代消解该模型在CoNLL测试集的F1达到63.0% 123456# 引用模型from allennlp.predictors.predictor import Predictorpredictor = Predictor.from_path(\"https://s3-us-west-2.amazonaws.com/allennlp/models/coref-model-2018.02.05.tar.gz\")predictor.predict( document=\"The woman reading a newspaper sat on the bench with her dog.\") Named Entity Recognition 命名实体识别模型使用ELMo嵌入的biLSTM 参考资料 https://allennlp.org/models","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"},{"name":"allennlp","slug":"人工智能/深度学习/allennlp","permalink":"http://yoursite.com/categories/人工智能/深度学习/allennlp/"}],"tags":[{"name":"allennlp","slug":"allennlp","permalink":"http://yoursite.com/tags/allennlp/"},{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"}]},{"title":"python代码加密","slug":"编程基础/python/python代码加密","date":"2019-03-29T07:45:48.000Z","updated":"2019-03-29T12:25:47.306Z","comments":true,"path":"wiki/编程基础/python/python代码加密/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/python代码加密/","excerpt":"","text":"目前的加密手段： 源代码混淆：只降低源码可读性，对破解有一定的干扰作用 只发行 pyc: 可以用现成工具复原 打包 exe: 可以用现成工具复原 cython打包so文件: 要加密单一的模块 /特制算法很有效，不过对很多复杂模块无法兼容，比如 django 写的 app 修改python解释器: 未丢失信息，容易复原 总结：python语言在设计理念上倾向于开源，没有很完美的加密方案，只能有限程度上增加破解者的难度（对于有经验的破解者形同虚设） 其他方案： 核心代码逻辑替换成 C++ 或 go语言 终极方案： 只提供api服务，不提供本地运行的程序","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"命令行参数和环境变量","slug":"编程基础/python/命令行参数和环境变量","date":"2019-03-29T01:04:15.000Z","updated":"2019-03-29T12:25:47.306Z","comments":true,"path":"wiki/编程基础/python/命令行参数和环境变量/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/命令行参数和环境变量/","excerpt":"","text":"命令行参数12345import sysnum = len(sys.argv) # 参数个数script_name = sys.argv[0] # 脚本命令名称arg1 = sys.argv[1] # 参数1arg2 = sys.argv[2] # 参数2 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"thread多线程模块","slug":"编程基础/python/thread多线程","date":"2019-03-27T08:30:26.000Z","updated":"2019-03-28T13:19:23.503Z","comments":true,"path":"wiki/编程基础/python/thread多线程/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/thread多线程/","excerpt":"","text":"概述threading用于提供线程相关的操作，线程是应用程序中工作的最小单元。 python当前版本的多线程库没有实现优先级、线程组，线程也不能被停止、暂停、恢复、中断。 threading模块提供的类： Thread, Lock, Rlock, Condition, [Bounded]Semaphore, Event, Timer, local。 threading 模块提供的常用方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 ​ threading.currentThread().getName()获取当前程序的线程名称 threading 模块提供的常量： threading.TIMEOUT_MAX 设置threading全局超时时间。 Thread类构造方法： Thread(group=None, target=None, name=None, args=(), kwargs={}) group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 线程名； args/kwargs: 要传入方法的参数。 实例方法： isAlive(): 返回线程是否在运行。正在运行指启动后、终止前。 get/setName(name): 获取/设置线程名。 start(): 线程准备就绪，等待CPU调度 is/setDaemon(bool): 获取/设置是后台线程（默认前台线程（False））。（在start之前设置） 如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主线程和后台线程均停止 如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止 start(): 启动线程。 join([timeout]): 阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout（可选参数）。 123456789101112131415161718192021222324import threadingimport timedef action(arg): time.sleep(1) print('the arg is:%s\\r' %arg) #运行方法一：将要执行的方法作为参数传给Thread的构造方法for i in range(4): t =threading.Thread(target=action,args=(i,)) t.start()#运行方法二：从Thread继承，并重写run()class MyThread(threading.Thread): def __init__(self,arg): super().__init__()#注意：一定要显式的调用父类的初始化函数。 self.arg=arg def run(self):#定义每个线程要运行的函数===action() time.sleep(1) print('the arg is:%s\\r' % self.arg)for i in xrange(4): t = MyThread(i) t.start() 123456789101112thread_list = [] #线程存放列表for i in xrange(4): t =threading.Thread(target=action,args=(i,)) t.setDaemon(True) thread_list.append(t)for t in thread_list: t.start()for t in thread_list: t.join()# join()阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout，即使设置了setDeamon（True）主线程依然要等待子线程结束。 参考资料 [python–threading多线程总结]","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"Queue 队列模块相关","slug":"编程基础/python/queue","date":"2019-03-25T00:13:50.000Z","updated":"2019-03-27T06:57:59.326Z","comments":true,"path":"wiki/编程基础/python/queue/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/queue/","excerpt":"","text":"heap 堆 stack 栈 queue 队列 堆的逻辑结构就是完全二叉树，并且二叉树中父节点的值小于等于该节点的所有子节点的值。 特征：heap[k] &lt;= heap[2k+1] 并且 heap[k] &lt;= heap[2k+2] （其中 k 为索引，从 0 开始计数） heapq 堆队列基本操作12345678910111213141516171819202122import heapq heap = []#向堆中插入元素，heapq会维护列表heap中的元素保持堆的性质 heapq.heappush(heap, item) #heapq把列表x转换成堆 O(n)复杂度heapq.heapify(x) # 最小堆heapq._heapify_max(x) # 最大堆#从可迭代的迭代器中返回最大的n个数，可以指定比较的key heapq.nlargest(n, iterable[, key]) #从可迭代的迭代器中返回最小的n个数，可以指定比较的key heapq.nsmallest(n, iterable[, key]) #从堆中删除元素，返回值是堆中最小或者最大的元素 heapq.heappop(heap)heapq.heappushpop(heap, item)：向 heap 中加入 item 元素，并返回 heap 中最小元素。heapq.heapreplace(heap,item): python3中heappushpop的更高效版。 原理使用的比较函数：lt, gt, cmp 内置数据类型和自定义类型，默认使用 lt （小于比较函数）进行比较 元组类型默认使用 cmp 比较 （先比较第1列，相同再比较第2列，以此类推……） 代码示范12345678import heapqh = []# 默认是最小堆heapq.heappush(h, (5, 'write code'))heapq.heappush(h, (7, 'release product'))heapq.heappush(h, (1, 'write spec'))heapq.heappush(h, (3, 'create tests'))min_item = heapq.heappop(h) # (1, 'write spec') PriorityQueue 优先队列 queue库是线程安全的 1234567891011121314151617181920#向队列中添加元素Queue.put(item[, block[, timeout]])#从队列中获取元素Queue.get([block[, timeout]])#队列判空Queue.empty()#队列大小Queue.qsize()try: import Queue as Q #python version &lt; 3.0except ImportError: import queue as Q #python3.*q = Q.PriorityQueue()q.put(19)q.put(1)q.put(5)while not q.empty(): print(q.get()) 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"python基本数据类型","slug":"编程基础/python/python_datatype","date":"2019-03-21T06:35:53.000Z","updated":"2019-03-25T00:13:36.116Z","comments":true,"path":"wiki/编程基础/python/python_datatype/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/python_datatype/","excerpt":"","text":"时间复杂度注释n代表容器中元素的数量，k代表参数的值，或者参数的数量。 [注1] =这些业务依赖于“摊销最坏情况”的“Amortized摊销”部分。 根据容器的历史，个别动作可能需要很长时间。 [注2] =对于这些操作，最坏情况n是容器达到的最大尺寸，而不仅仅是当前尺寸。 例如，如果将N个对象添加到字典中，则删除N-1，仍然会为N个对象（至少）调整字典的大小，直到进行另一次插入为止。 list 列表是以数组（Array）实现的。最大的开销发生在超过当前分配大小的增长，这种情况下所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动。如果你需要在一个队列的两端进行增删的操作，应当使用collections.deque（双向队列） 操作 平均情况 最坏情况 复制 O(n) O(n) append[注1] O(1) O(1) 插入 insert O(n) O(n) 取元素 O(1) O(1) 更改元素 O(1) O(1) 删除元素 O(n) O(n) 遍历 O(n) O(n) 取切片 O(k) O(k) 删除切片 O(n) O(n) 更改切片 O(k+n) O(k+n) extend[注1] O(k) O(k) 排序 O(n log n) O(n log n) 列表乘法 O(nk) O(nk) x in s O(n) min(s), max(s) O(n) 获取长度 O(1) O(1) 双向队列（collections.deque） deque （double-ended queue，双向队列）是以双向链表的形式实现的 (Well, a list of arrays rather than objects, for greater efficiency)。双向队列的两端都是可达的，但从查找队列中间的元素较为缓慢，增删元素就更慢了。 操作 平均情况 最坏情况 复制 O(n) O(n) append O(1) O(1) appendleft O(1) O(1) pop O(1) O(1) popleft O(1) O(1) extend O(k) O(k) extendleft O(k) O(k) rotate O(k) O(k) remove O(n) O(n) 字典（dict） 下列字典的平均情况基于以下假设: 1 对象的散列函数足够撸棒（robust），不会发生冲突。2 字典的键是从所有可能的键的集合中随机选择的。 小窍门：只使用字符串作为字典的键。这么做虽然不会影响算法的时间复杂度，但会对常数项产生显著的影响，这决定了你的一段程序能多快跑完。 操作 平均情况 最坏情况 复制[注2] O(n) O(n) 取元素 O(1) O(n) 更改元素[注1] O(1) O(n) 删除元素 O(1) O(n) 遍历[注2] O(n) O(n) dict.setdefault(key, default=None)返回dict[key] 。如果没有key，则设置dict[key]=default并返回dict[key] 集合（set） 未列出的操作可参考 dict —— 二者的实现非常相似。 操作 平均情况 最坏情况 x in s O(1) O(n) 并集 s\\ t O(len(s)+len(t)) 交集 s&amp;t O(min(len(s), len(t)) O(len(s) * len(t)) 差集 s-t O(len(s)) s.difference_update(t) O(len(t)) 对称差集 s^t O(len(s)) O(len(s) * len(t)) s.symmetric_difference_update(t) O(len(t)) O(len(t) * len(s)) 由源码得知，求差集（s-t，或s.difference(t)）运算与更新为差集（s.difference_uptate(t)）运算的时间复杂度并不相同！前者是将在s中，但不在t中的元素添加到新的集合中，因此时间复杂度为O(len(s))；后者是将在t中的元素从s中移除，因此时间复杂度为O(len(t))。因此，使用时请留心，根据两个集合的大小以及是否需要新集合来选择合适的方法。 集合的s-t运算中，并不要求t也一定是集合。只要t是可遍历的对象即可。 参考资料Python内置方法的时间复杂度","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"配置vscode","slug":"编程基础/安装与配置/set-vscode","date":"2019-03-20T05:59:18.000Z","updated":"2019-03-21T10:41:17.117Z","comments":true,"path":"wiki/编程基础/安装与配置/set-vscode/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/set-vscode/","excerpt":"","text":"配置快捷键12向下复制一行---改成Ctrl+Deditor.action.copyLinesDownAction 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"双指针找环","slug":"编程基础/leetcode/141. Linked_List_Cycle","date":"2019-03-19T14:08:18.000Z","updated":"2019-03-25T00:13:36.116Z","comments":true,"path":"wiki/编程基础/leetcode/141. Linked_List_Cycle/","link":"","permalink":"http://yoursite.com/wiki/编程基础/leetcode/141. Linked_List_Cycle/","excerpt":"","text":"题目https://leetcode.com/problems/linked-list-cycle/ 141.给一个链表的头节点,判断链表是否有环 解法1: 用set判断重复优点: 逻辑直观, 容易理解 比双指针更快 缺点: 空间占用比双指针更多 解法2: 双指针 用两个指针指向head 进行循环: 每次慢指针下移一次,快指针下移两次 如果快指针指向结尾则无循环,如果两个指针指向同一个节点则有循环","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"leetcode","slug":"编程基础/leetcode","permalink":"http://yoursite.com/categories/编程基础/leetcode/"}],"tags":[]},{"title":"使用docker","slug":"编程基础/软件使用备忘/use-docker","date":"2019-03-19T06:49:42.000Z","updated":"2019-03-25T08:51:37.187Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-docker/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-docker/","excerpt":"","text":"配置### 服务设置刚安装完成后，需要重启机器，才能启动服务 1234567# Ubuntusudo service docker start # 启动服务# manjarosudo systemctl start docker # 启动服务sudo systemctl status docker # 查看服务状态systemctl enable docker # 开机启动 设置信任本地仓库123# 1. 在/etc/default/docker添加：-- insecure-registry 127.0.0.1:5000# 2. 再重启docker 服务 容器-常用命令123456# 查看容器列表 ## -a 查看全部，否则查看运行中的docker ps# 删除容器 -f强制删除docker rm -f xxx 容器自启动设置12docker run --restart=on-failure:10 xxxdocker run --restart=always xxx no 容器退出时不要自动重启。这个是默认值。 on-failure[:max-retries] 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数。在每次重启容器之前，重启延迟比上次增加一倍，从100毫秒开始，来防止影响服务器。这意味着daemon将等待100ms,然后200ms，直到超过on-failure限制，或执行docker stop或docker rm -f 。如果容器重启成功[容器启动后并运行至少10秒]，然后delay重置为默认的100ms。ms, 400, 800, 1600等等，直到超过on-failure限制，或执行docker stop或docker rm -f always 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启，不管容器当时的状态如何。(和unless-stopped 参数值效果一样) 镜像-常用命令123456789101112# 查看镜像列表docker images# 导出镜像的压缩文件（可以压缩多个镜像，例如xxx和yyy）docker save xxx:tag yyy:tag2 | gzip &gt; img.tar.gz # 镜像重命名docker tag xxx:tag xxx2:tag2# 删除镜像 ## -f强制删除docker rmi -f xxx:tag 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"交换变量（快捷写法和注意事项）","slug":"编程基础/python/交换2个变量","date":"2019-03-19T05:55:32.000Z","updated":"2019-03-19T10:25:03.600Z","comments":true,"path":"wiki/编程基础/python/交换2个变量/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/交换2个变量/","excerpt":"","text":"交换变量快捷写法：最多支持4个变量互换123a, b, c = 1,2,3a,b,c = c,a,b# 结果： a=3 b=1 c=2 如果交换内容涉及：对象及其属性，需要考虑先后顺序123456789101112131415161718class ListNode: def __init__(self, x): self.val = x self.next = None # 正确的交换 node = ListNode(1) ; node.next = 2node.next, node = node.val, node.next# 结果： node=2 # 错误的交换 node = ListNode(1) ; node.next = 2node, node.next = node.next, node.val# 结果报错信息：# AttributeError: 'int' object has no attribute 'next'# node = node.next (2)# node.next = node.val int没有next属性 原因 交换的不是变量，而是变量的地址。地址变化是有顺序的，并不是同时完成的。 如果没有涉及到对象及其属性，地址变化不会影响取值过程，所以不会报错。所以看起来像是一句代码同时完成了一样。 python解释得出的执行码中有4个指令：ROT_TWO /ROT_THREE/ROT_FOUR 所以交换赋值语句最多支持4个变量","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"基础语法","slug":"基础语法","permalink":"http://yoursite.com/tags/基础语法/"}]},{"title":"GPU相关","slug":"人工智能/深度学习/GPU相关","date":"2019-03-18T02:07:19.999Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/深度学习/GPU相关/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/GPU相关/","excerpt":"","text":"查看当前GPU使用情况 nvidia-smi 设置使用哪个GPU CUDA_VISIBLE_DEVICES=”1” 查看CUDA版本 nvcc –version 12# 查看显卡版本lspci | grep -i nvidia","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"}],"tags":[{"name":"gpu","slug":"gpu","permalink":"http://yoursite.com/tags/gpu/"}]},{"title":"es-搜索操作","slug":"人工智能/搜索引擎/es-search","date":"2019-03-17T01:25:03.000Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/搜索引擎/es-search/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/es-search/","excerpt":"","text":"搜索备忘一原生的url接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# 搜索位置(url)/_search # 在所有的索引中搜索所有的类型/gb/_search # 在 gb 索引中搜索所有的类型/gb,us/_search # 在 gb 和 us 索引中搜索所有的文档/g*,u*/_search # 在任何以 g 或者 u 开头的索引中搜索所有的类型/gb/user/_search # 在 gb 索引中搜索 user 类型/gb,us/user,tweet/_search # 在 gb 和 us 索引中搜索 user 和 tweet 类型/_all/user,tweet/_search # 在所有的索引中搜索 user 和 tweet 类型# 分页(url)POST /_search # 默认size=10, from=0 从0返回POST /_search?size=5 # 第二页POST /_search?size=5&amp;from=5POST /_search?size=5&amp;from=10# term 精确查找,不计算相关度.&#123; \"term\" : &#123; \"price\" : 20 &#125;&#125;# 用constant_score 把term包装成filterPOST /my_store/products/_search&#123; \"query\" : &#123; \"constant_score\" : &#123; \"filter\" : &#123; \"term\" : &#123; \"productID\" : \"XHDK-A-1293-#fJ3\" &#125; &#125; &#125; &#125;&#125;# range 过滤器(filter): age &gt; 30# 过滤器执行速度非常快，不会计算相关度. 精确的筛选.POST /megacorp/employee/_search&#123; \"query\" : &#123; \"bool\": &#123; \"must\": &#123; \"match\" : &#123;\"last_name\" : \"smith\" &#125; &#125;, \"filter\": &#123; \"range\" : &#123; \"age\" : &#123; \"gt\" : 30 &#125; &#125; &#125; &#125; &#125;&#125;# 全文搜索: 返回相关性排序的结果． 如果有rock没有climbing也可能会返回结果.POST /megacorp/employee/_search&#123; \"query\" : &#123; \"match\" : &#123; \"about\" : \"rock climbing\" &#125; &#125;&#125;&#123; \"query\": &#123; \"match_phrase\": &#123; \"content\" : &#123; \"query\" : \"我的宝马多少马力\", \"slop\" : 1 &#125; &#125; &#125;&#125;# 实际上下面的query才能正确返回结果，搜索的是content这个字段里包含对应文本的文档# 精确匹配一系列单词或者短语POST /megacorp/employee/_search&#123; \"query\" : &#123; \"match_phrase\" : &#123; \"about\" : \"rock climbing\" &#125; &#125;&#125;# 高亮搜索POST /megacorp/employee/_search&#123; \"query\" : &#123; \"match_phrase\" : &#123; \"about\" : \"rock climbing\" &#125; &#125;, \"highlight\": &#123; \"fields\" : &#123; \"about\" : &#123;&#125; &#125; &#125;&#125;# 返回:&#123; ... \"hits\": &#123; \"total\": 1, \"max_score\": 0.23013961, \"hits\": [ &#123; ... \"_score\": 0.23013961, \"_source\": &#123; \"first_name\": \"John\", \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] &#125;, \"highlight\": &#123; \"about\": [ \"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;\" ] &#125; &#125; ] &#125;&#125;# 聚合（aggregations）: 统计某些标签的数量(是在搜索结果中进行统计,可以结合其他query)POST /megacorp/employee/_search&#123; \"aggs\": &#123; \"all_interests\": &#123; \"terms\": &#123; \"field\": \"interests\" &#125; &#125; &#125;&#125; 搜索备忘二http://www.cnblogs.com/yjf512/p/4897294.html 12345678910111213组合式搜索&#123; \"query\": &#123; &#123; \"bool\": &#123; \"must\": &#123; \"match\": &#123; \"tweet\": \"elasticsearch\" &#125;&#125;, \"must_not\": &#123; \"match\": &#123; \"name\": \"mary\" &#125;&#125;, \"should\": &#123; \"match\": &#123; \"tweet\": \"full text\" &#125;&#125;, # 这些match可以是数组 \"filter\": &#123; \"range\": &#123; \"age\" : &#123; \"gt\" : 30 &#125;&#125; &#125; &#125; &#125; &#125; &#125; elasticsearch 查询（match和term）es中的查询请求有两种方式，一种是简易版的查询，另外一种是使用JSON完整的请求体，叫做结构化查询（DSL）。由于DSL查询更为直观也更为简易，所以大都使用这种方式。DSL查询是POST过去一个json，由于post的请求是json格式的，所以存在很多灵活性，也有很多形式。这里有一个地方注意的是官方文档里面给的例子的json结构只是一部分，并不是可以直接黏贴复制进去使用的。一般要在外面加个query为key的机构。 match最简单的一个match例子： 查询和”我的宝马多少马力”这个查询语句匹配的文档。 123456789&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot; : &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot; &#125; &#125; &#125;&#125; 上面的查询匹配就会进行分词，比如”宝马多少马力”会被分词为”宝马 多少 马力”, 所有有关”宝马 多少 马力”, 那么所有包含这三个词中的一个或多个的文档就会被搜索出来。并且根据lucene的评分机制(TF/IDF)来进行评分。 match_phrase比如上面一个例子，一个文档”我的保时捷马力不错”也会被搜索出来，那么想要精确匹配所有同时包含”宝马 多少 马力”的文档怎么做？就要使用 match_phrase 了 123456789&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;content&quot; : &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot; &#125; &#125; &#125;&#125; 完全匹配可能比较严，我们会希望有个可调节因子，少匹配一个也满足，那就需要使用到slop。 12345678910&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;content&quot; : &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot;, &quot;slop&quot; : 1 &#125; &#125; &#125;&#125; multi_match如果我们希望两个字段进行匹配，其中一个字段有这个文档就满足的话，使用multi_match 12345678&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot; : &quot;我的宝马多少马力&quot;, &quot;fields&quot; : [&quot;title&quot;, &quot;content&quot;] &#125; &#125;&#125; 但是multi_match就涉及到匹配评分的问题了。 我们希望完全匹配的文档占的评分比较高，则需要使用best_fields12345678910111213&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;我的宝马发动机多少&quot;, &quot;type&quot;: &quot;best_fields&quot;, &quot;fields&quot;: [ &quot;tag&quot;, &quot;content&quot; ], &quot;tie_breaker&quot;: 0.3 &#125; &#125;&#125; 意思就是完全匹配”宝马 发动机”的文档评分会比较靠前，如果只匹配宝马的文档评分乘以0.3的系数 我们希望越多字段匹配的文档评分越高，就要使用most_fields123456789101112&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;我的宝马发动机多少&quot;, &quot;type&quot;: &quot;most_fields&quot;, &quot;fields&quot;: [ &quot;tag&quot;, &quot;content&quot; ] &#125; &#125;&#125; 我们会希望这个词条的分词词汇是分配到不同字段中的，那么就使用cross_fields123456789101112&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;我的宝马发动机多少&quot;, &quot;type&quot;: &quot;cross_fields&quot;, &quot;fields&quot;: [ &quot;tag&quot;, &quot;content&quot; ] &#125; &#125;&#125; termterm是代表完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇 1234567&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;content&quot;: &quot;汽车保养&quot; &#125; &#125;&#125; 查出的所有文档都包含”汽车保养”这个词组的词汇。 使用term要确定的是这个字段是否“被分析”(analyzed)，默认的字符串是被分析的。 拿官网上的例子举例： mapping是这样的： 12345678910111213141516171819202122PUT my_index&#123; &quot;mappings&quot;: &#123; &quot;my_type&quot;: &#123; &quot;properties&quot;: &#123; &quot;full_text&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;exact_value&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;index&quot;: &quot;not_analyzed&quot; &#125; &#125; &#125; &#125;&#125;PUT my_index/my_type/1&#123; &quot;full_text&quot;: &quot;Quick Foxes!&quot;, &quot;exact_value&quot;: &quot;Quick Foxes!&quot; &#125; 其中的full_text是被分析过的，所以full_text的索引中存的就是[quick, foxes]，而extra_value中存的是[Quick Foxes!]。 那下面的几个请求： 12345678GET my_index/my_type/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;exact_value&quot;: &quot;Quick Foxes!&quot; &#125; &#125;&#125; 请求的出数据，因为完全匹配 12345678GET my_index/my_type/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;full_text&quot;: &quot;Quick Foxes!&quot; &#125; &#125;&#125; 请求不出数据的，因为full_text分词后的结果中没有[Quick Foxes!]这个分词。 bool联合查询: must,should,must_not如果我们想要请求”content中带宝马，但是tag中不带宝马”这样类似的需求，就需要用到bool联合查询。联合查询就会使用到must,should,must_not三种关键词。 这三个可以这么理解 must: 文档必须完全匹配条件 should: should下面会带一个以上的条件，至少满足一个条件，这个文档就符合should must_not: 文档必须不匹配条件 比如上面那个需求： 12345678910111213141516&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;term&quot;: &#123; &quot;content&quot;: &quot;宝马&quot; &#125; &#125;, &quot;must_not&quot;: &#123; &quot;term&quot;: &#123; &quot;tags&quot;: &quot;宝马&quot; &#125; &#125; &#125; &#125;&#125; 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"elastic_search","slug":"elastic-search","permalink":"http://yoursite.com/tags/elastic-search/"},{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"},{"name":"search","slug":"search","permalink":"http://yoursite.com/tags/search/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"安装ES","slug":"人工智能/搜索引擎/install-es","date":"2019-03-17T01:21:17.000Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/搜索引擎/install-es/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/install-es/","excerpt":"","text":"安装ES-E Configure a setting-V, –version-d, –daemonize 守护进程，后台启动-p, –pidfile Creates a pid file in the specified path on start-q, –quiet Turns off standard output/error streams logging in console-s, –silent show minimal output-v, –verbose show verbose output 1234567891011121314151617181920# 启动(先-s 启动成功, 再用-d后台启动)elasticsearch/bin/elasticsearch -s # 配置文件elasticsearch/config/elasticsearch.yml# 检查状态curl -XGET '192.168.31.185:9200/_cat/health?v'# 测试是否启动成功curl 'http://192.168.31.185:9200/?pretty'# 查看所有索引！！curl -XGET '192.168.31.185:9200/_cat/indices?v'# 创建一个名字=ip_focus 的索引 pretty参数让返回结果更易读curl -XPUT '192.168.31.185:9200/ip_focus?pretty'# 删除一个索引curl -XDELETE '192.168.31.185:9200/customer?pretty'# 新建/修改一个文档（一行数据） _id=1 如果索引不存在，会自动新建索引=customer# 当我们没有明确指定ID的时候，我们需要使用POST方法代替PUT来发送请求PUT /customer/doc/1 &#123; \"name\": \"John Doe\" &#125; 启动时报错：elasticsearch max virtual memory areas vm.max_map_count [65530] is too low 12345sudo vim /etc/sysctl.conf # 在文件末尾加入vm.max_map_count=655360# 然后执行sudo sysctl -p 安装Kibana1234567891011121314151617去官网下载https://www.elastic.co/cn/downloads/kibana# 解压文件tar –zxvf kibana-5.5.2-linux-x86_64.tar.gz–C ./kibana/# 去config文件夹编辑kibana.yml#配置本机ip server.host: \"192.168.252.129\" #配置es集群url elasticsearch.url: \"http://192.168.252.129:9200\" # 启动程序 使用&amp;命令启动后，退出当前窗口时需要使用exit退出cd /bin./kibana &amp;访问：http://ip:port ip为kibana安装节点ip，端口默认为5061 参考资料","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"elastic_search","slug":"elastic-search","permalink":"http://yoursite.com/tags/elastic-search/"},{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"},{"name":"Kibana","slug":"Kibana","permalink":"http://yoursite.com/tags/Kibana/"}]},{"title":"使用linux","slug":"编程基础/软件使用备忘/use-linux","date":"2019-03-17T01:05:41.000Z","updated":"2019-04-01T14:11:49.493Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-linux/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-linux/","excerpt":"","text":"tty终端1234# 进入tty终端Ctrl+Alt+F1 到F6 进入tty1～～tty6# 从tty回到桌面环境Ctrl+Alt+F7 Shell脚本Shell特殊变量 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 注意:$10 不能获取第十个参数，获取第十个参数需要${10} 常用shell脚本123456变量默认值#当变量a为null或为空字符串时则var=b var=$&#123;a:-b&#125; 脚本所在目录script_dir=$(cd \"`dirname $0`/.\"; pwd) 常用shell函数 函数定义前可选加”function “ 函数末尾可以加：return 返回 如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值范围 0-255 123456789101112131415161718192021222324252627282930313233# 第一个echo函数demoFun()&#123; echo \"这是我的第一个 shell 函数!\"&#125;# 需要键盘输入的函数funWithReturn()&#123; echo \"这个函数会对输入的两个数字进行相加运算...\" echo \"输入第一个数字: \" read aNum echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum 和 $anotherNum !\" return $(($aNum+$anotherNum))&#125;funWithReturn# 函数返回值在调用该函数后通过 $? 来获得。echo \"输入的两个数字之和为 $? !\"# 分支if condition1then command1elif condition2 then command2else commandNfi if [ $a == $b ] # \"a 等于 b\"if [ $a -gt $b ] # \"a 大于 b\"if [ $a -lt $b ] #\"a 小于 b\" 免密码SSH登录远程服务器 创建自己的私钥和公钥对 1ssh-keygen -C “备注信息” -f ~/.ssh/私钥名称 #【密码输入空】 设置私钥对应的网站,在~/.ssh/config 文件中写入： 12345Host 远程服务器 空格链接多个地址 HostName： 目标主机地址 User：指定的登陆用户名 Port：指定的端口号(可选) IdentifyFile：指定的私钥地址(可选) 免密码SSH远程登录服务器 -i ~/.ssh/私钥名称 远程帐号@远程服务器 ```12345678910111213141516171819202122 把公钥文件复制到远程服务器，并输入密码后，下次就可以自动验证私钥文件 开机启动设置软件：**Stacer**## 常用命令### 进程相关```bash# 查看占用内存CPUtop -p **进程ID# 查看所有进程 a=allps -ax# 查看占用socket端口的程序netstat -ap\\|grep **端口号** 文件相关1234567891011# 查看硬盘使用情况df -h# 查看当前文件夹递归1层大小/末尾可加文件夹du -h --max-depth=1# 切分并压缩文件 pre_xxx是切分文件的前缀tar cjf - file_or_dir |split -b 2000m - pre_xxx.# 合并然后解压文件 -C 输出到相对位置cat pre_xxx.* |tar xj -C ./../aim_dir/xxx_dir/ 权限相关12345# 给xxx账号设置root权限（sudo）sudo *user*mod-aG sudo xxx# 修改文件的所有者 -R表示递归目录下所有文件chown 用户名:用户组 文件名或目录名 -R 发送网络请求 curl1234567## post 方法# curl -i -X POST -H head文本 -d body_json_data# 示范如下:curl -i -X POST -H 'Content-type':'application/x-www-form-urlencoded; charset=UTF-8' -d &#123;\"json-body\":\"\"&#125; http://192.168.31.189:5858/handle/## get方法curl http://192.168.31.189:5858/ 远程挂载 说明 命令 参数 安装工具：sshfs sudo apt install sshfs 开始挂载 sshfs 用户名@host:远程目录 本地挂载点 -o -p端口 取消挂载 sudo umount -l 挂载点 取消挂载 fusermount -u 挂载点 rename perl版本程序 2个参数 参数一：’s/aaa/bbb/‘ 把aaa替换为bbb 参数二：用* 匹配1个或多个字符 rename ‘s/aaa/bbb/‘ *.json 一条命令kill某个进程1234567891011ps -aux|grep 50050|grep -v grep|cut -c 9-15|xargs kill -9# 截取输入行的第9个字符到第15个字符，而这正好是进程号PID。# xargs命令是用来把前面命令的输出结果（PID）作为“kill -9”命令的参数，并执行该命令# 用正则表达式来kill进程。而不用PIDpkill nginx# 用进程名字kill多个进程。killall nginx 1234# 新建用户sudo adduser 用户名# 增加root权限sudo usermod -aG sudo 用户名 sed-正则表达式 awk,sed都可以做字符串各种操作。 ^行的开头 $行的结尾 . 任意单个字符 * 匹配0-多次 + 匹配1次以上 ? 匹配0/1次 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[]},{"title":"使用git","slug":"编程基础/软件使用备忘/use-git","date":"2019-03-17T01:05:30.000Z","updated":"2019-03-28T07:11:14.353Z","comments":true,"path":"wiki/编程基础/软件使用备忘/use-git/","link":"","permalink":"http://yoursite.com/wiki/编程基础/软件使用备忘/use-git/","excerpt":"","text":"gitlab使用设置保护分支(master分支不能推送) 默认的master分支是收保护的，不能直接push 进入setting—&gt;Repository—&gt;Protected Branches 设置保护分支 git命令行标签123456789101112131415161718192021标签分为带附注和不带附注的。我们尽量使用带附注的。# 本地新建一个tag 名称=V1.2git tag -a V1.2 -m 'xxxxx'# 查看本地taggit tag# 查看tag详细信息git tag show V1.2# 推送到远程仓库git push origin --tags# 如果发现有问题，可以删除标签（本地）git tag -d V1.2# 推送空的同名版本到远程仓库，等同于删除远程库里的版本git push origin :refs/tags/V1.2# 获取远程版本，精确拉取某一个版本的代码git fetch origin tag V1.2 本地分支和远程分支1234567891011121314# 查看当前跟踪关系git branch -vv# 克隆时自动将创建好的`master`分支追踪`origin/master`分支git clone 服务器地址# 建立本地分支 xxx, 追踪远程分支origin/yyygit checkout -b xxx origin/yyy# 将 xxx 分支追踪远程分支 origin/yyygit branch --set-upstream xxx origin/yyy# 设置当前分支跟踪远程分支 origin/yyyygit branch -u origin/yyyy 设置git默认使用的编辑器12提交是出现nano界面，可以退出后设置默认编辑器成VIMgit config --global core.editor \"vim\" 配置远程仓库的密钥 创建自己的私钥和公钥对 -C “备注信息” -f ~/.ssh/私钥名称 ``` 【密码输入空】12. 设置私钥对应的网站,在~/.ssh/config 文件中写入： Host deeplycurious.ai 多个远程仓库地址用空格分隔IdentityFile ~/.ssh/私钥名称 12345678910113. 上传公钥4. 在phabricator里个人--setting--SSH Public Keys-- SSH Key Actions -- Upload Public Key5. Name 随便取， Public Key 是你的公钥的文本内容### 强制修改分支位置```bash可以直接使用 -f 选项让分支指向另一个提交# 例如下面。将 master 分支强制指向 HEAD 的第 3 级父提交。（代码恢复到老版本）git branch -f master HEAD~3 删除git子模组/子模块123456789101112131415161718菜鸟流程:1. 把子模组文件夹剪切到项目外2. add/commit/push(删除对应文件夹)3. 然后把文件夹剪切回来4. add/commit/push(增加对应文件夹)官方流程:# 删除子模块目录及源码rm -rf 子模块目录 # 删除项目目录下.gitmodules文件中子模块相关条目vi .gitmodules # 删除配置项中子模块相关条目vi .git/config # 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可rm .git/module/* # 如果仍然报错，执行如下：git rm --cached 子模块名称 TODO: 学习 git hooks自动更新提交空文件夹 空的.gitignore文件可以作为占位符，使git只创建一个文件夹，里面是空的（一个空.ignore文件） 删除文件的git控制 如果已经加到版本控制中（push或add过）：用该命令去除控制（不删除本地文件） git rm -r –cached 文件路径 如果刚删除caehed，或未add或push过：直接设置 .gitignore 忽略即可。 .git/info/exclude 该文件和.ignore格式相同，但是不会被提交，不会影响他人的忽略名单。 忽略已加入控制的文件改动 git update-index –assume-unchanged 文件名 用户名和密码123456# 设置用户名和密码(--global全局配置,否则为本地配置)git config --global user.email \"you@example.com\"git config --global user.name \"Your Name\"# 查看用户名和密码设置命令,不写最后的文本值,即为查看 给本地代码添加远程git仓库1234567891011# 添加远程仓库 origin是git默认仓库名称git remote add origin 远程仓库地址# 重设远程仓库git remote set-url origin URL# 查看远程仓库的地址 git remote -v# 第一次推送到远程仓库（并把默认远程仓库设置为origin）git push -u origin master 修改commit注释12# 如果commit内容还未push:git commit --amend 可视化交互git学习，知识点如下 创建和切换分支1234567# 创建分支（当前分支不变）git branch newxxx# 切换当前分支到xxxgit checkout xxx# 创建并切换到newxxx分支git checkout -b newxxx rebase1234567# 当前在bugFix分支，命令会把bugFix节点的父节点指向master# C1--&gt;C2（master） 命令结果：C1--&gt;C2(master)--&gt;C3‘(bugFix*)# --&gt;C3（bugFix*） --&gt;C3git rebase master# 当前C2(master)--&gt;C3‘(bugFix*) 则指向同一个git rebase bugFix HEAD 123456789101112131415161718HEAD 是指git当前正在操作的节点指针HEAD 可以指向某个分支名，也可以指向某个节点名# 查看当前HEAD cat .git/HEAD# 查看HEAD指向的引用git symbolic-ref HEAD# 查看提交树的节点的哈希值git log# 切换HEAD指针（绝对值切换）git checkout 节点-哈希值/分支名# 切换HEAD指针（相对切换） # 使用 ^ 向上移动 1 个提交记录 git checkout master^ git checkout HEAD^ # 使用 ~&lt;num&gt; 向上移动多个提交记录，（不加数字则向上1个） git checkout master~3 修改分支位置123# -f 选项让分支指向另一个提交# 下面命令将 master 分支强制指向 HEAD 的第 3 级父提交。git branch -f master HEAD~3 恢复到merge之前123# ORIG_HEAD 是git在做危险操作时候给HEAD做的备份git reset --hard ORIG_HEAD# ORIG_HEAD 等价于 HEAD@&#123;1&#125; 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"软件使用备忘","slug":"编程基础/软件使用备忘","permalink":"http://yoursite.com/categories/编程基础/软件使用备忘/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"操作系统重装记录","slug":"编程基础/安装与配置/system-record","date":"2019-03-17T00:56:59.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/安装与配置/system-record/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/system-record/","excerpt":"","text":"警告 应该备份.ssh文件夹, 重装后将消失 Ubuntu 重装记录 chrome插件 SwitchyOmega 有道词典Chrome划词插件 LingoCloud （彩云小译） smartUp Gesture （手势） Tampermonkey （油猴） 有道云笔记网页剪报 360浏览器 插件360屏幕截图 Adblock Super Proxy SwitchyOmega Tampermonkey 彩云小译 截图助手 有道云笔记网页剪报 有道划词翻译 油猴脚本导出文件（tampermonkey-backup-chrome-2019-03-13T01-41-21.545Z.zip） Omega备份文件 adblock备份文件 3、把ubuntu的设置记录下来 安装Tweaks(Ubuntu软件商店–GNOME Tweaks) https://extensions.gnome.org/ aifish f1 插件 Activities configurator 1.3 Scale Icon 0 Icon Padding ON Hide Text 6 Text Padding 100 Hot Corner Threhold 100 Panel Transparency 黑色 Panel Shadow Color 100 Transparency 0 Vertical Length 0 Spread Radius OFF Move Activities to the Right ON Enable Conflict Detection Clipboard indicator Places status indicator Drop down terminal（没怎么用过） 3、常用软件记录 typora pycharm vscode 插件 Beautify Better TOML TOML Language Support Docker Encode Decode Gitlens Image preview JavaScript (ES6) code snippets Mithril Emmet Prettier - Code formatter Project Manager Python Terminal Vetur wps 搜狗输入法 百度云（deepin） postman meld（文本对比） systemMonitor（系统监控器，进程、文件夹监控） virtuaBox（虚拟机） 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"配置vim","slug":"编程基础/安装与配置/set-vim","date":"2019-03-17T00:56:04.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/安装与配置/set-vim/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/set-vim/","excerpt":"","text":"vim配置（linux/manjaro/ubuntu/deepin通用）1234567891011121314151617181920212223242526272829303132333435363738sudo pacman -S vim\":关闭与vi的兼容模式set nocompatible \":显示行号set number \":显示匹配的括号set showmatch \":距离顶部和底部3行set scrolloff=3 \":编码set encoding=utf-8 set fenc=utf-8 \"编码设定Encodingset fileencoding=utf-8set fileencodings=utf-8,gbk,utf-16,big5 set langmenu=zh_CN.UTF-8source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.UTF-8\"忽略大小写检索set ignorecase\":搜索高亮set hlsearch \"输入检索时动态变化set incsearch\":语法高亮syntax on \":命令显示历史set history=500\"开启插件和缩进filetype plugin indent on\":鼠标set autoreadset mouse=set mousehide 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"配置和使用 pycharm","slug":"编程基础/python/pycharm","date":"2019-03-17T00:55:57.000Z","updated":"2019-03-28T07:19:22.200Z","comments":true,"path":"wiki/编程基础/python/pycharm/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/pycharm/","excerpt":"","text":"配置常用代码片段配置 配置路径 Setting—&gt;Editor—&gt;Live Templates—&gt;加号按钮 12345678910111213# ~errerror = '\\n'.join(traceback.format_exception(*sys.exc_info()))# ~rootdef root(*f, relative_root='../../../'): # relative_root 当前代码目录相对root的相对路径 for t in f: if t[:1] == '/': print('Warning: root()包含绝对路径 参数=&#123;&#125;'.format(f)) break code_dir = os.path.dirname(os.path.realpath(__file__)) long_path = os.path.join(code_dir, relative_root, *f) return long_path 快捷键配置12345678Keymap---方案设置成NetBeans# Code格式化代码 设置成 Ctrl+Alt+LReformat# 当前行往上挪一行 设置成 Alt+UpMove Line Up# 当前行往上挪一行 设置成 Alt+DownMove Line Down 跳转到上个光标所在位置​ 打开 View—toolbar 有左右箭头按钮。悬停可以查看快捷键 插件File—Setting—Plugins 数据库插件： ​ 搜索datebase ​ 安装 Database Navigator ​ 安装Mongo Plugin ​ 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[]},{"title":"安装ubuntu","slug":"编程基础/安装与配置/install-ubuntu","date":"2019-03-17T00:55:46.000Z","updated":"2019-04-01T14:12:35.640Z","comments":true,"path":"wiki/编程基础/安装与配置/install-ubuntu/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/install-ubuntu/","excerpt":"","text":"一 安装系统二 安装软件12345678910111213141516171819202122232425262728293031323334353637383940414243卸载软件命令： apt-get remove softname1 softname2 softname3……卸载并清除配置命令： apt-get remove --purge softname1更新软件信息数据库命令： apt-get update进行系统升级命令： apt-get upgrade搜索软件包命令： apt-cache search softname1 softname2 softname3……安装deb软件包命令： dpkg -i xxx.deb删除软件包命令： dpkg -r xxx.deb连同配置文件一起删除命令： dpkg -P xxx.deb (purge)查看软件包信息命令： dpkg -info xxx.deb查看文件拷贝详情命令： dpkg -L xxx.deb查看系统中已安装软件包信息命令： dpkg -l重新配置软件包命令： dpkg-reconfigure xxx 科学上网12345678910111213# 安装ss的GUI客户端sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5# 安裝ss的命令行工具sudo apt install shadowsockssslocal -c xxx.json -d start# -c config -d start/stop/restart daemon mode# 浏览器安装科学插件# 找到chrome执行程序目录，加代理启动，安装 SwitchyOmega插件./chrome --proxy-server='socks5://127.0.0.1:1080' 安装git git-lfs12345678910# 安装gitsudo apt install git# 安装git-lfs## 1. 设置url源curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash## 2. 安装lfssudo apt-get install git-lfs## 3. 初始化git lfs install 安装google输入法(不好用)12sudo apt-get install fcitx-googlepinyin然后注销再登陆操作系统 安装搜狗输入法 123456789101. 去搜狗拼音官网,下载linux版本安装文件(.deb)2. 双击打开界面安装3. 登出后登录操作系统4. 右键点击顶栏的键盘图标，选择配置5. 添加搜狗输入法如果候选栏显示乱码、无法显示中文，可按如下方式处理：cd ~/.configrm -rf SogouPY* sogou*然后重启后登录即可。 安装zsh 和 autojump12345678910111213sudo apt install zshsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"重启操作系统后终端变成zsh如果要切换回去bashchsh -s /bin/bash# 安裝autojumpgit clone git://github.com/wting/autojump.gitcd autojump./install.py or ./uninstall.py手工把提示腳本添加到 ~/.zshrc 安装node/npm1234567# 1. 安装默认版本sudo apt-get install npm# 2. 安装版本管理工具sudo npm install -g n# 3. 安装对应版本sudo n latest #最新版本sudo n stable #最新的稳定版本 配置Ubuntu界面123sudo apt install chrome-gnome-shell打开Ubuntu软件商店安装：GNOME Tweakshttps://extensions.gnome.org/ 快捷键设置 快捷键 配置路径 说明 Super+E 启动器—主目录 文件管理器 Ctrl+Alt+E 启动网页浏览器 浏览器 Super+D 导航—隐藏所有正常窗口 回到桌面 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"安装manjaro","slug":"编程基础/安装与配置/install-manjaro","date":"2019-03-17T00:55:36.000Z","updated":"2019-03-25T00:13:36.116Z","comments":true,"path":"wiki/编程基础/安装与配置/install-manjaro/","link":"","permalink":"http://yoursite.com/wiki/编程基础/安装与配置/install-manjaro/","excerpt":"","text":"零. 个人使用体验只使用了一周，还不太熟悉。再尝试一周，如果没有什么特别的优点就换成deepin试试。 优点 硬件支持好 软件版本非常新（滚动更新） 缺点 缺少软件360浏览器 对中文支持较差，需要自己配置的内容较多 很多软件都是deepin的，例如微信和naivicat（那我为什么不直接用deepin呢） 一. 安装manjaro系统二. 中文相关配置注意事项如果代码更新一直等待状态可以尝试删除/var/lib/pacman/db.lck 配置镜像源 测试国内的镜像源1sudo pacman-mirrors -i -c China -m rank 设置 archlinuxcn 源1234567891011# 修改 /etc/pacman.conf 添加以下内容[archlinuxcn]SigLevel = Optional TrustedOnlyServer = http://repo.archlinuxcn.org/$arch## 添加cn源签名key(这步不做，会报签名错误）sudo pacman -S archlinuxcn-keyring# 完成后执行下面的命令使配置生效## 更新源列表sudo pacman-mirrors -g## 更新pacman数据库并全面更新系统sudo pacman -Syyu #（必须先更新系统，不然无法安装输入法） 使界面可以输入中文123456在~/.xprofile中添加export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx如果还是无法使用，可能需要安装fcitx-gtk2sudo pacman -S fcitx-gtk2 把系统界面设置为中文1234点击设置--Manjaro Settings Manager--本地化设置：添加 中国-中文，然后在语言包中点击安装软件包在~/.xprofile中添加export LC_ALL=\"zh_CN.UTF-8\"export LANG=zh_CN.UTF-8 三. 安装软件和系统配置安装yay1234# 1. 下载代码git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si 安装git12sudo pacman -S gitsudo pacman -S git-lfs 安装 wps12sudo pacman -S wps-officesudo pacman -S ttf-wps-fonts 安装 typora1234567891011121314## 下载二进制文件（x64） 解压https://www.typora.io/#linux## 创建程序的软链接sudo ln -s /home/fish/soft/Typora-linux-x64/Typora /usr/bin/typora## 编辑/usr/share/applications/typora.desktop 文件[Desktop Entry]Version=1.0Terminal=falseIcon=/home/fish/soft/Typora-linux-x64/resources/app/asserts/icon/icon_256x256.pngType=ApplicationCategories=Office;Exec=/home/fish/soft/Typora-linux-x64/Typora %UName=TyporaComment=MarkDown Editor 安装node/npm1234sudo pacman -S nvm nvm install --latest-npm然后把/home/fish/.nvm/versions/node/v11.12.0/bin添加到系统路径 安装jdk123456sudo pacman -S jdk8# 配置环境export JAVA_HOME=/usr/lib/jvm/defaultexport JRE_HOME=$&#123;JAVA_HOEM&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib 命令简单安装： vscode/ vim/ 微信/ shadownsocks/ 网易云音乐/ qq/ chrome/docker12345678sudo pacman -S codesudo pacman -S electronic-wechat （网页版不能复制粘帖图片）sudo pacman -S shadownsocks-qt5sudo pacman -S vimsudo pacman -S netease-cloud-music # 网易云音乐sudo pacman -S deepin.com.qq.office # 可以先搜索qq 看看版本sudo pacman -S google-chromesudo pacman -S docker 安装下载工具Gwget12打开系统工具：添加/删除软件搜索工具后下载 百度云下载1234567打开系统工具：添加/删除软件：安装baidupcs-go-git说明：https://github.com/iikira/BaiduPCS-Go# 进入命令交互工具baidupcs# 帮助help 安装截图工具123sudo pacman -S deepin-screenshot添加快捷键： deepin-screenshot 安装zsh autojump1234567# zshsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"# autojump（zsh设置ubuntu通用）sudo pacman -S autojump再在~/.zshrc中添加: plugins=(git autojump) 安装googlepinyin谷歌拼音123456sudo pacman -S fcitx-im fcitx-configtool fcitx-googlepinyinsudo vim ~/.xprofile 输入下面命令：exportGTK_IM_MODULE=fcitxexportQT_IM_MODULE=fcitxexportXMODIFIERS=\"@im=fcitx\" 安装搜狗拼音12345678910# 前置：设置中国软件源sudo pacman -S fcitx-im #默认全部安装sudo pacman -S fcitx-configtoolsudo pacman -S fcitx-sogoupinyin在~/.xprofile添加如下内容：export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 关闭ssh远程root登录（ubuntu通用）1234# 设置不允许root帐号登录 修改文件 /etc/ssh/sshd_config PermitRootLogin no# 重启sshd服务sudo systemctl restart sshd 安装pycharm（ubuntu通用）12341.下载并解压pycharm.tar文件2.进入bin文件夹3.执行./pycharm.sh4.打开pycharm，在菜单栏选择tool---&gt;添加桌面快捷方式 时间显示设置操作：右键点击任务栏右下角的时间，选择属性：tips配置：%m-%d %j/365 第%V周时钟配置：周%u %H:%M ### 切换deepin桌面12# 安装桌面，然后重启电脑，选择桌面sudo pacman -S deepin deepin-extra lightdm 参考arch-wiki chrome安装插件 去官网下载插件文件 xxx.crx 去http://crxextractor.com/ 网站上传crx文件，获得zip文件 解压zip文件获得一个文件夹 打开chrome，打开开发者模式，加载已解压的扩展程序，选中解压文件夹，安装即可 四. 常用快捷键Ctrl+Alt+D 回到桌面（在设置界面里看不见这个快捷键，但是超级方便） Ctrl+Alt+F exo-open –launch FileManager 打开文件管理器 我改成了 Super ECtrl+Alt+M xfce4-taskmanager 资源监控器Ctrl+Alt+Delete xflock4 锁屏并黑屏Ctrl+Alt+X xkill 通过鼠标关闭某个程序新增： Ctrl+Alt+Q xfce4-terminal 终端Ctrl+H 文件管理器，显示隐藏文件 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"安装与配置","slug":"编程基础/安装与配置","permalink":"http://yoursite.com/categories/编程基础/安装与配置/"}],"tags":[]},{"title":"py2_and_py3","slug":"编程基础/python/py2-and-py3","date":"2019-03-17T00:39:15.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/python/py2-and-py3/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/py2-and-py3/","excerpt":"","text":"感受: 实际上还是不好用～～～能用3就用3～～～_future__python3出来的时候，python的设计者们当然也考虑过代码之间的兼容问题。许多为为兼容性设计的功能可以通过future这个包来导入。例如： 123456789101112# 使用python3的print函数，禁用python2的print语句。from __future__ import print_function# 导入该特征，代码中的文本变量默认是Unicode（如果不导入python2的文本变量默认是str）# python2 str.decode('utf8') --&gt; Unicodefrom __future__ import unicode_literals# 参见PEP 328 -- Imports: Multi-Line and Absolute/Relativefrom __future__ import absolute_import# 像python3一样，int除以int得float，而不像Python2那样是整除from __future__ import division six 字符串类型 文本 字节 python2 unicode str python3 str bytes six six.text_type six.binary_type 1234567891011# python2if isinstance(xxx, unicode): pass # 兼容python2和python3import sixif isinstance(xxx, six.text_type): pass## 使用input代替raw_inputfrom six.moves import input 判断版本写不同的内容if sys.version&gt;’3’: pass 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"兼容性","slug":"兼容性","permalink":"http://yoursite.com/tags/兼容性/"},{"name":"python版本","slug":"python版本","permalink":"http://yoursite.com/tags/python版本/"}]},{"title":"decorator装饰器","slug":"编程基础/python/decorator装饰器","date":"2019-03-17T00:38:37.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/python/decorator装饰器/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/decorator装饰器/","excerpt":"","text":"最简单的模板是这样的1234567891011def outer(func): def inner(): print 'before' func() print 'after' # return r return inner@outerdef F1(): print 'test' 函数带多个参数，装饰器对应修改以适合多种情况12345678910def ftfunc(func): def timef(*s,**gs): print \"[%s] %s() called\" % (ctime(),func.__name__) return func(*s,**gs) return timef@ftfuncdef foo(*s,**gs): print(s) print(gs) 函数带多个参数，装饰器也带多个参数123456789101112def decrator(*dargs, **dkargs): def wrapper(func): def _wrapper(*args, **kargs): print \"decrator param:\", dargs, dkargs print \"function param:\", args, kargs return func(*args, **kargs) return _wrapper return wrapper@decrator(1, a=2)def foo(x, y=0): print \"foo\", x, y 函数带多个参数，装饰器能转换参数类型1234567891011121314def validate(**vkargs): def decorator(func): def wrapper(**kargs): for key in vkargs: # 根据vkargs中的参数的类型对kargs的参数进行类型转换 kargs[key] = vkargs[key](kargs[key]) return func(**kargs) return wrapper return decorator@validate(x=int, y=float, z=float)def move(x, y, z): print \"move %d (%0.2f, %0.2f)\"%(x, y, z) 参考资料","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"decorator","slug":"decorator","permalink":"http://yoursite.com/tags/decorator/"},{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]},{"title":"elastic_search基础","slug":"人工智能/搜索引擎/elastic-search基础","date":"2019-03-05T02:39:39.000Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/搜索引擎/elastic-search基础/","link":"","permalink":"http://yoursite.com/wiki/人工智能/搜索引擎/elastic-search基础/","excerpt":"","text":"索引(库)、分类(表)数据查询数据删除数据123456789101112131415161718192021222324252627282930# es参考版本：elasticsearch：5.5# _delete_by_query会删除所有query语句匹配上的文档，用法如下：curl -X POST \"localhost:9200/twitter/_delete_by_query\" -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"match\": &#123; \"name\": \"测试删除\" &#125; &#125;&#125;# 其中twitter是索引名称# 因为internal版本控制不支持0为有效数字，所以版本号为0的文档不能删除，并且请求将会失败。# 删除多个索引(twitter,blog)的多个type(_docs,post)curl -X POST \"localhost:9200/twitter,blog/_docs,post/_delete_by_query\" -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125;# 出自上向下删除1000条数据curl -X POST \"localhost:9200/twitter/_delete_by_query?scroll_size=1000\" -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"term\": &#123; \"user\": \"kimchy\" &#125; &#125;&#125; 参考资料 Elasticsearch删除数据之_delete_by_query","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"搜索引擎","slug":"人工智能/搜索引擎","permalink":"http://yoursite.com/categories/人工智能/搜索引擎/"}],"tags":[{"name":"elastic","slug":"elastic","permalink":"http://yoursite.com/tags/elastic/"},{"name":"elastic_search","slug":"elastic-search","permalink":"http://yoursite.com/tags/elastic-search/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yoursite.com/tags/elasticsearch/"},{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"}]},{"title":"hexo","slug":"编程基础/博客工具/hexo","date":"2019-02-28T08:49:08.000Z","updated":"2019-03-25T00:13:36.116Z","comments":true,"path":"wiki/编程基础/博客工具/hexo/","link":"","permalink":"http://yoursite.com/wiki/编程基础/博客工具/hexo/","excerpt":"","text":"安装hexo1sudo npm install hexo-cli -g 图片显示123456789101112# 配置资源文件夹# hexo n xxx 会生成同名文件夹,# hexo g 会把同名文件夹内图片打包生成静态文件_config.yml里的post_asset_folder，改成true# 安装插件npm install hexo-asset-image --save# 设置typora编辑器# 图片插入路径= ./$&#123;filename&#125;# 优先使用相对路径在typora编辑器内粘贴图片时会自动把图片存储到同名文件夹 主题配置hexo-theme-Wikitten Github地址 部署hexo123456789# 进入blog目录hexo init# 启动服务器hexo serverhexo server -p 8080 # -p 端口# 生成静态文件hexo generate | hexo g` 插件自动生存目录树 categorieshexo-auto-category 1234567891011# 安装npm install hexo-auto-category --save# 在站点根目录下的_config.yml添加：# 自动生成目录树categories (depth层级上限)auto_category: enable: true depth: # 使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 绑定域名1234A (Address) 记录是域名到ip的映射，即为ip起别名CNAME是域名别名到域名的映射，即为域名起别名。政策导致国内无法绑定到github~~ 参考资料 Hexo 的个人 Wiki 主题 - Wikitten hexo-theme-Wikitten github地址 hexo中文官方文档","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"博客工具","slug":"编程基础/博客工具","permalink":"http://yoursite.com/categories/编程基础/博客工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"wiki","slug":"wiki","permalink":"http://yoursite.com/tags/wiki/"}]},{"title":"mongo","slug":"编程基础/数据库/mongo","date":"2019-02-28T08:41:56.000Z","updated":"2019-03-20T10:39:12.430Z","comments":true,"path":"wiki/编程基础/数据库/mongo/","link":"","permalink":"http://yoursite.com/wiki/编程基础/数据库/mongo/","excerpt":"","text":"### 服务器服务器启用mongo集群1234567891011121314151617181920212223242526# 进入mongo客户端mongo# 以下操作是在mongo客户端命令行内：# 创建集群，集群名字=“rs0”rs.initiate( &#123; _id: \"rs0\", members: [ &#123; _id: 0, host: \"mongo-r0:27017\" &#125;, &#123; _id: 1, host: \"mongo-r1:27017\" &#125;, &#123; _id: 2, host: \"mongo-r2:27017\" &#125; ] &#125;)# 查看集群状态rs.conf()rs.status() mongo客户端使用登录/验证/切换数据库12# 进入mongo客户端mongo 客户端模块调用pymongo/motor调用mongo集群当 mongo 是集群时，客户端连接时需要设置好要连接的所有 mongo 节点。 12345import pymongo# uri里的“rs0”是集群名称，前面是每个节点的IP和端口uri = 'mongodb://mongo-r0:27017,mongo-r1:27017,mongo-r2:27017/?replicaSet=rs0'conn = pymongo.MongoClient()[i for i in conn.list_databases()] 注释：pymongo和motor连接时使用的uri字符串可以是相同的，因为motor实际是调用pymongo实现的。 集群–官方文档 参考资料 官方文档","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"数据库","slug":"编程基础/数据库","permalink":"http://yoursite.com/categories/编程基础/数据库/"}],"tags":[{"name":"mongo","slug":"mongo","permalink":"http://yoursite.com/tags/mongo/"}]},{"title":"markdown说明","slug":"编程基础/博客工具/markdown说明","date":"2019-02-27T07:03:45.000Z","updated":"2019-03-18T02:07:20.002Z","comments":true,"path":"wiki/编程基础/博客工具/markdown说明/","link":"","permalink":"http://yoursite.com/wiki/编程基础/博客工具/markdown说明/","excerpt":"","text":"$x^p_ {ij}$ 其中i表示第i个标签 $x^p_ {ij}$ 上标$^2$ 下标$_ 2$","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"博客工具","slug":"编程基础/博客工具","permalink":"http://yoursite.com/categories/编程基础/博客工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"pytorch功能","slug":"人工智能/深度学习/pytorch功能","date":"2019-02-26T07:00:45.000Z","updated":"2019-03-18T02:07:19.999Z","comments":true,"path":"wiki/人工智能/深度学习/pytorch功能/","link":"","permalink":"http://yoursite.com/wiki/人工智能/深度学习/pytorch功能/","excerpt":"","text":"计算 功能 代码 P范数（N方求和后开方） torch.norm(input, p=2) 指定GPU（3种方式） 123torch.cuda.set_device(id)os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;2&quot;CUDA_VISIBLE_DEVICES=1 python main.py 网络层","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"},{"name":"深度学习","slug":"人工智能/深度学习","permalink":"http://yoursite.com/categories/人工智能/深度学习/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"}]},{"title":"基础库：os/sys/dis","slug":"编程基础/python/基础库","date":"2019-02-26T07:00:45.000Z","updated":"2019-03-19T06:14:46.097Z","comments":true,"path":"wiki/编程基础/python/基础库/","link":"","permalink":"http://yoursite.com/wiki/编程基础/python/基础库/","excerpt":"","text":"常用功能 功能 代码 参数 判断文件是否存在 os.path.isfile(path) 判断文件或文件夹是否存在 os.path.exists(path) 判断文件权限 os.access(path, mode) os.F_OK存在 os.R_OK可读 os.W_OK:可写os.X_OK可执行 判断文件夹存在 os.path.isdir(dir) 得到当前工作目录 os.getcwd() 删除文件 os.remove() 列出目录里的文件夹和文件 os.listdir(dir) 改变工作目录到dirname os.chdir(dirname) https://www.cnblogs.com/wq242424/p/5803721.html dis – 查看解释器得出的执行码123import dis# fn 是想查看执行码的函数名print(dis.dis(fn))","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"},{"name":"python","slug":"编程基础/python","permalink":"http://yoursite.com/categories/编程基础/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"os","slug":"os","permalink":"http://yoursite.com/tags/os/"},{"name":"sys","slug":"sys","permalink":"http://yoursite.com/tags/sys/"},{"name":"dis","slug":"dis","permalink":"http://yoursite.com/tags/dis/"},{"name":"python基础库","slug":"python基础库","permalink":"http://yoursite.com/tags/python基础库/"}]}]}